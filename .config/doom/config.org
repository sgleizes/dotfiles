#+title: Doom Emacs Configuration
#+author: St√©phane Gleizes
#+startup: overview
#+property: header-args:elisp :tangle yes :cache yes :results silent :comments link
#+property: header-args :tangle no :results silent

* System setup
** Systemd daemons

To avoid the loads of issues arising when using a single ~emacs~ daemon for both
terminal and graphical frames, I decided to use dedicated daemons for each type
of frame.

To that purpose, I created a systemd /template unit file/, derived from the default
one that ships with ~emacs~:
#+begin_src systemd :tangle ~/.config/systemd/user/emacs@.service :mkdirp yes
[Unit]
Description=Emacs text editor (%i)
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/
PartOf=emacs.target

[Service]
Type=notify
ExecStart=/usr/bin/emacs --fg-daemon=%i
ExecStop=/usr/bin/emacsclient --socket-name=%i --eval "(kill-emacs)"
# The location of the SSH auth socket varies by distribution, and some
# set it from PAM, so don't override by default.
# Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure
Nice=-10

[Install]
WantedBy=default.target
#+end_src

This unit file is extended by the following /drop-in snippet/ that sets-up the
right environment for ~emacs~ daemons:
#+begin_src systemd :tangle ~/.config/systemd/user/emacs@.service.d/env.conf :mkdirp yes
[Service]
Environment=XAUTHORITY=%C/Xauthority
Environment=DOOMDIR=%E/doom
Environment=DOOMLOCALDIR=%h/.local/share/emacs
#+end_src

To define and manage all instances, I use a systemd /target file/:
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.target :mkdirp yes
[Unit]
Description=Emacs text editor daemons
Wants=emacs@terminal.service emacs@graphical.service

[Install]
WantedBy=default.target
#+end_src

Which is then enabled and started with:
#+begin_src sh
systemctl --user enable --now emacs.target
#+end_src

** Desktop launcher

Since I don't want a new graphical frame to be created every time a file is
opened, I wrote this launcher script to wrap ~emacsclient~:
#+begin_src sh :tangle ~/.local/bin/emacs-xclient :tangle-mode (identity #o755)
#!/usr/bin/env bash
# Wrap the emacsclient command to open a new graphical frame if none exist or if
# no files are specified, else open the given files in the most-recent graphical
# frame.

# The command to use to contact the emacs server.
EMACSCLIENT="emacsclient --socket-name graphical"

# Elisp query to find the most recently opened graphical non-child frame.
FRAME_QUERY="car (filtered-frame-list #'(lambda (f) \
  (and (eq (framep f) 'x) \
  (not (frame-parent f)))))"

if [[ ! $* || "$($EMACSCLIENT --eval "($FRAME_QUERY)")" == 'nil' ]]; then
  $EMACSCLIENT --create-frame --no-wait
else
  DISPLAY=$($EMACSCLIENT --eval "(frame-parameter ($FRAME_QUERY) 'display)")
  $EMACSCLIENT --display "${DISPLAY//\"/}" --no-wait "$@"
fi
#+end_src

Let's add a new desktop icon that represents well what ~emacs~ truly is: a black
hole for the mind:
#+attr_html: :class img :alt The doom emacs desktop icon
[[file:./icon/black-hole.png]]

Install the icon:
#+begin_src sh
for size in 16 24 32 48 64 96 128 192 256; do
  orig="./icon/black-hole.png"
  icon="./icon/black-hole-$size.png"
  convert "$orig" -resize "${size}x${size}" "$icon"
  xdg-icon-resource install --size "$size" "$icon" doom-emacs
  rm -f "$icon"
done
#+end_src

The desktop entry must now be modified to use the above script and icon:
#+begin_src conf :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes
[Desktop Entry]
Categories=Development;TextEditor;
Comment=Edit text
Exec=emacs-xclient %F
GenericName=Text Editor
Icon=doom-emacs
Keywords=Text;Editor;
MimeType=text/x-tex;text/x-pascal;text/x-moc;text/x-makefile;text/x-java;text/x-csrc;text/x-csrc;text/x-chdr;text/x-c++src;text/x-c++hdr;text/tcl;text/plain;application/x-shellscript;
Name=Emacs
StartupNotify=true
StartupWMClass=Emacs
Terminal=false
Type=Application
#+end_src

** Ediff launcher

Add another launcher script to start an ~ediff~ session in a new graphical frame.

Note that it depends on a ~+workspace/rename-frame~ function that automatically
generates a unique name for the new perspective (workspace).
#+begin_src sh :tangle ~/.local/bin/ediff :tangle-mode (identity #o755)
#!/usr/bin/env bash
# Start an ediff session in a new emacs frame. Inspired by:
# https://gist.github.com/ptrv/0b460291e14a4a3c6372
#
# This script can be used as a `git mergetool` and `git difftool`.
# It automatically detects whether to run a diff/merge session
# and also supports directories.

# Abort if arguments are not provided.
if [ ! ${#} -ge 2 ]; then
  echo >&2 "Usage: ediff <local> <remote> [merged] [base]"
  exit 1
fi

# Process arguments.
LOCAL="$1"
REMOTE="$2"
[[ $3 ]] && MERGED="$3" || MERGED="$REMOTE"
[[ -d $LOCAL && -d $REMOTE ]] && MODE='directories' || MODE='files'

# Determine the emacs command to evaluate.
if [[ $4 && -r $4 ]]; then
  BASE="$4"
  EVAL="ediff-merge-$MODE-with-ancestor \"$LOCAL\" \"$REMOTE\" \"$BASE\" nil \"$MERGED\""
elif [[ $REMOTE != "$MERGED" ]]; then
  EVAL="ediff-merge-$MODE \"$LOCAL\" \"$REMOTE\" nil \"$MERGED\""
else
  EVAL="ediff-$MODE \"$LOCAL\" \"$REMOTE\" nil"
fi

# Use a graphical frame except in the console.
if [[ $TERM == 'linux' ]]; then
  EMACSCLIENT_OPTS="--socket-name terminal --tty"
else
  EMACSCLIENT_OPTS="--socket-name graphical --create-frame"
fi

# Run emacsclient.
emacsclient $EMACSCLIENT_OPTS --eval "
  (progn
    (+workspace/rename-frame \"ediff\")
    ($EVAL))"

# Check modified file for unresolved conflicts.
if [[ $MODE == 'files' && $(egrep -c '^(<<<<<<<|=======|>>>>>>>|####### Ancestor)' "$MERGED") != 0 ]]; then
  MERGEDSAVE=$(mktemp --tmpdir "$(basename "$MERGED").XXXXXXXX")
  cp "$MERGED" "$MERGEDSAVE"
  echo >&2 "Oops! Conflict markers detected in $MERGED"
  echo >&2 "Saved your changes to $MERGEDSAVE"
  exit 1
fi
#+end_src

* General configuration

Make this file run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).
#+begin_src elisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

** Personal information

Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.
#+begin_src elisp
(setq user-full-name "St√©phane Gleizes"
      user-mail-address "stephane.gleizes@gmail.com")
#+end_src

** Doom configuration
*** Modules
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

Doom has this lovely /modular configuration base/ that takes a lot of work out
of configuring Emacs. Each module (when enabled) can provide a list of packages
to install (on ~doom sync~) and configuration to be applied. The modules can
also have flags applied to tweak their behavior.

See the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#modules][doom documentation]] and the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/modules.org][modules appendix]].

**** Structure

#+name: init.el
#+begin_src elisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

**** Configuration

#+name: doom-config
#+begin_src elisp
literate
(default +bindings +smartparens)
#+end_src

#+name: doom-input
#+begin_src elisp
;;chinese
;;japanese
;;layout                      ; auie,ctsrnm is the superior home row
#+end_src

**** Completion

#+name: doom-completion
#+begin_src elisp
(company +childframe)                ; the ultimate code completion backend
;;helm                               ; the *other* search engine for love and life
;;ido                                ; the other *other* search engine...
(ivy +prescient +icons +childframe)  ; a search engine for love and life
#+end_src

**** Interface

#+name: doom-ui
#+begin_src elisp
;;deft                        ; notational velocity for Emacs
doom                          ; what makes DOOM look the way it does
doom-dashboard                ; a nifty splash screen for Emacs
;;doom-quit                   ; DOOM quit-message prompts when you quit Emacs
;;fill-column                 ; a `fill-column' indicator
hl-todo                       ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
hydra
;;indent-guides               ; highlighted indent columns
;;(ligatures +fira)           ; ligatures and symbols to make your code pretty again
;;minimap                     ; show a map of the code on the side
modeline                      ; snazzy, Atom-inspired modeline, plus API
;;nav-flash                   ; blink cursor line after big motions
;;neotree                     ; a project drawer, like NERDTree for vim
ophints                       ; highlight the region an operation acts on
(popup +all +defaults)        ; tame sudden yet inevitable temporary windows
tabs                          ; a tab bar for Emacs
treemacs                      ; a project drawer, like neotree but cooler
unicode                       ; extended unicode support for various languages
vc-gutter                     ; vcs diff in the fringe
vi-tilde-fringe               ; fringe tildes to mark beyond EOB
window-select                 ; visually switch windows
workspaces                    ; tab emulation, persistence & separate workspaces
;;zen                         ; distraction-free coding or writing
#+end_src

**** Editor

#+name: doom-editor
#+begin_src elisp
(evil +everywhere)            ; come to the dark side, we have cookies
file-templates                ; auto-snippets for empty files
fold                          ; (nigh) universal code folding
(format +onsave)              ; automated prettiness
;;god                         ; run Emacs commands without modifier keys
;;lispy                       ; vim for lisp, for people who don't like vim
multiple-cursors              ; editing in many places at once
;;objed                       ; text object editing for the innocent
;;parinfer                    ; turn lisp into python, sort of
rotate-text                   ; cycle region at point between text candidates
snippets                      ; my elves. They type so I don't have to
;;word-wrap                   ; soft wrapping with language-aware indent
#+end_src

**** Builtins

#+name: doom-emacs
#+begin_src elisp
(dired +icons)                ; making dired pretty [functional]
electric                      ; smarter, keyword-based electric-indent
(ibuffer +icons)              ; interactive buffer management
undo                          ; persistent, smarter undo for your inevitable mistakes
vc                            ; version-control and Emacs, sitting in a tree
#+end_src

**** Terminal

#+name: doom-term
#+begin_src elisp
;;eshell                      ; the elisp shell that works everywhere
;;shell                       ; simple shell REPL for Emacs
;;term                        ; basic terminal emulator for Emacs
vterm                         ; the best terminal emulation in Emacs
#+end_src

**** Checkers

#+name: doom-checkers
#+begin_src elisp
syntax                        ; tasing you for every semicolon you forget
(spell +flyspell +enchant)    ; tasing you for misspelling mispelling
;;grammar                     ; tasing grammar mistake every you make
#+end_src

**** Tools

#+name: doom-tools
#+begin_src elisp
;;ansible                     ; a crucible for infrastructure as code
;;debugger                    ; FIXME stepping through code, to help you add bugs
;;direnv                      ; be direct about your environment
docker                        ; port everything to containers
editorconfig                  ; let someone else argue about tabs vs spaces
;;ein                         ; tame Jupyter notebooks with emacs
(eval +overlay)               ; run code, run (also, repls)
;;gist                        ; interacting with github gists
lookup                        ; navigate your code and its documentation
lsp                           ; language server protocol
(magit +forge)                ; a git porcelain for Emacs
;;make                        ; run make tasks from Emacs
;;pass                        ; password manager for nerds
pdf                           ; pdf enhancements
;;prodigy                     ; FIXME managing external services & code builders
rgb                           ; creating color strings
taskrunner                    ; taskrunner for all your projects
;;terraform                   ; infrastructure as code
;;tmux                        ; an API for interacting with tmux
;;upload                      ; map local to remote projects via ssh/ftp
#+end_src

**** System

#+name: doom-os
#+begin_src elisp
(:if IS-MAC macos)            ; improve compatibility with macOS
;;tty                         ; improve the terminal Emacs experience
#+end_src

**** Language support

We can be rather liberal with enabling support for languages as the associated
packages/configuration are (usually) only loaded when first opening an
associated file.

#+name: doom-lang
#+begin_src elisp
;;agda                        ; types of types of types of types...
(cc +lsp)                     ; C/C++/Obj-C madness
;;clojure                     ; java with a lisp
;;common-lisp                 ; if you've seen one lisp, you've seen them all
;;coq                         ; proofs-as-programs
;;crystal                     ; ruby at the speed of c
;;csharp                      ; unity, .NET, and mono shenanigans
data                          ; config/data formats
;;(dart +flutter)             ; paint ui and not much else
;;elixir                      ; erlang done right
;;elm                         ; care for a cup of TEA?
emacs-lisp                    ; drown in parentheses
;;erlang                      ; an elegant language for a more civilized age
;;ess                         ; emacs speaks statistics
;;faust                       ; dsp, but you get to keep your soul
;;fsharp                      ; ML stands for Microsoft's Language
;;fstar                       ; (dependent) types and (monadic) effects and Z3
;;gdscript                    ; the language you waited for
(go +lsp)                     ; the hipster dialect
;;(haskell +dante)            ; a language that's lazier than I am
;;hy                          ; readability of scheme w/ speed of python
;;idris                       ; a language you can depend on
json                          ; At least it ain't XML
;;(java +meghanada)           ; the poster child for carpal tunnel syndrome
;;javascript                  ; all(hope(abandon(ye(who(enter(here))))))
;;julia                       ; a better, faster MATLAB
;;kotlin                      ; a better, slicker Java(Script)
;;latex                       ; writing papers in Emacs has never been so fun
;;lean                        ; proof that mathematicians need help
;;factor                      ; for when scripts are stacked against you
;;ledger                      ; an accounting system in Emacs
;;lua                         ; one-based indices? one-based indices
markdown                      ; writing docs for people to ignore
;;nim                         ; python + lisp at the speed of c
;;nix                         ; I hereby declare "nix geht mehr!"
;;ocaml                       ; an objective camel
(org +pretty)                 ; organize your plain life in plain text
;;php                         ; perl's insecure younger brother
;;plantuml                    ; diagrams for confusing people more
;;purescript                  ; javascript, but functional
;;python                      ; beautiful is better than ugly
;;qt                          ; the 'cutest' gui framework ever
;;racket                      ; a DSL for DSLs
;;raku                        ; the artist formerly known as perl6
;;rest                        ; Emacs as a REST client
;;rst                         ; ReST in peace
;;(ruby +rails)               ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;rust                        ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala                       ; java, but good
;;scheme                      ; a fully conniving family of lisps
(sh +lsp)                     ; she sells {ba,z,fi}sh shells on the C xor
;;sml                         ; no, the /other/ ML
;;solidity                    ; do you need a blockchain? No.
;;swift                       ; who asked for emoji variables?
;;terra                       ; Earth and Moon in alignment for performance.
;;web                         ; the tubes
yaml                          ; JSON, but readable
#+end_src

**** Applications

#+name: doom-email
#+begin_src elisp
;;(mu4e +org +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src elisp
calendar
;;irc                        ; how neckbeards socialize
(rss +org)                 ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src

*** Appearance
**** Fonts

Doom exposes five (optional) variables for controlling fonts in Doom, they are:
+ doom-font
+ doom-variable-pitch-font
+ doom-serif-font
+ doom-unicode-font (the fallback font for unicode symbols that your default font doesn‚Äôt support)
+ doom-big-font (used for doom-big-font-mode)
They all accept either a font-spec, font string (=‚ÄùInput Mono-12‚Äù=), or [[https://wiki.archlinux.org/index.php/X_Logical_Font_Description][xlfd font string]].

#+begin_src elisp
(setq doom-font (font-spec :family "Fira Code" :size 12)
      doom-variable-pitch-font (font-spec :family "Fira Sans")
      doom-unicode-font (font-spec :family "Noto Sans Mono")
      doom-big-font (font-spec :family "Fira Code" :size 18))
#+end_src

Add a global hydra to change the font-size interactively.
#+begin_src elisp
(after! pretty-hydra
  (pretty-hydra-define +hydra/font-size
    (:separator "‚ïê")
    ("Font size"
     (("+" doom/increase-font-size "increase")
      ("-" doom/decrease-font-size "decrease")
      ("0" doom/reset-font-size "reset"))))

  (map! :leader
        :desc "Adjust font size"
        "-"   #'+hydra/font-size/body))
#+end_src

**** Theme and modeline

#+begin_src elisp
(setq doom-theme 'doom-tomorrow-night)
(delq! t custom-theme-load-path) ; Remove default emacs theme from search path
#+end_src

Let's make graphical frames slightly transparent.
#+begin_src elisp
(add-to-list 'default-frame-alist
             '(alpha . (90 . 90)))
#+end_src

Do not show encoding in the modeline if the value is the default =LF UTF-8=.
#+begin_src elisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (or (eq buffer-file-coding-system 'utf-8-unix)
                          (eq buffer-file-coding-system 'utf-8)))))
(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

**** Dashboard

Customize the splash image of the doom dashboard.
#+begin_src elisp
(setq fancy-splash-image nil
      +doom-dashboard-banner-dir (concat doom-private-dir "banner/")
      +doom-dashboard-banner-file "black-hole.png")
#+end_src

Fix visually disturbing ~hl-line~ range in the dashboard.
#+begin_src elisp
(defun doom-dashboard-hl-button ()
  (cons (- (point) 5) (line-end-position)))
(add-hook! +doom-dashboard-mode
           '(lambda () (setq-local hl-line-range-function #'doom-dashboard-hl-button)))
#+end_src

*** General settings

Tweak various general settings to more opinionated values.
#+begin_src elisp
(setq-default delete-by-moving-to-trash t  ; Delete files to trash
              x-stretch-cursor t)          ; Stretch cursor to the glyph width

(setq undo-limit 80000000                  ; Raise undo-limit to 80Mb
      mark-ring-max 32                     ; Set mark ring size
      global-mark-ring-max 32              ; Set global mark ring size
      set-mark-command-repeat-pop t        ; Repeat jump to last mark with just C-SPC
      max-mini-window-height 0.25          ; Increase max-height of mini-windows
      auto-save-default t                  ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "‚Ä¶"         ; Unicode ellispis are nicer than "...", and also save precious space
      uniquify-buffer-name-style 'forward) ; Use path to uniquify buffer names

(global-subword-mode 1)                    ; Iterate through CamelCase words
#+end_src

*** Indentation

Set default values for the various indentation settings.
Even though ~dtrt-indent~ will properly update these by analyzing existing
files, it is still necessary to set the desired value for new files.
#+begin_src elisp
(setq-default tab-width 2
              ;; List of language-specific variables from dtrt-indent
              c-basic-offset          tab-width  ; C/C++/D/PHP/Java/...
              js-indent-level         tab-width  ; JavaScript/JSON
              js2-basic-offset        tab-width  ; JavaScript-IDE
              js3-indent-level        tab-width  ; JavaScript-IDE
              lua-indent-level        tab-width  ; Lua
              perl-indent-level       tab-width  ; Perl
              cperl-indent-level      tab-width  ; Perl
              raku-indent-offset      tab-width  ; Perl6/Raku
              erlang-indent-level     tab-width  ; Erlang
              ada-indent              tab-width  ; Ada
              sgml-basic-offset       tab-width  ; SGML
              nxml-child-indent       tab-width  ; XML
              pascal-indent-level     tab-width  ; Pascal
              typescript-indent-level tab-width  ; Typescript
              ;; Languages that use SMIE-based indent
              sh-basic-offset         tab-width  ; Shell Script
              ruby-indent-level       tab-width  ; Ruby
              enh-ruby-indent-level   tab-width  ; Ruby
              crystal-indent-level    tab-width  ; Crystal (Ruby)
              css-indent-offset       tab-width  ; CSS
              rust-indent-offset      tab-width  ; Rust
              rustic-indent-offset    tab-width  ; Rust
              scala-indent:step       tab-width  ; Scala
              ;; Default fallback
              standard-indent         tab-width
              smie-indent-basic       tab-width)
#+end_src

*** Terminal

Improve terminal integration. Taken from the ~tty~ module.
#+begin_src elisp
;; Some terminals offer two different cursors: a "visible" static cursor and a
;; "very visible" blinking one. By default, Emacs uses the very visible cursor
;; and will switch back to it when Emacs is started or resumed. A nil
;; `visible-cursor' prevents this.
(setq visible-cursor nil)

;; Enable the mouse in terminal Emacs
(add-hook 'tty-setup-hook #'xterm-mouse-mode)
#+end_src

Disable minor modes that are undesired in terminal frames.
#+begin_src elisp
(defun +doom-disable-graphical-modes (frame)
  "Disable undesired minor-modes in FRAME (default: selected frame)
if in terminal."
  (interactive)
  (unless (display-graphic-p frame)
    (remove-hook! doom-first-file #'centaur-tabs-mode)
    (remove-hook! doom-first-file #'beacon-mode)
    (remove-hook! doom-first-input #'evil-goggles-mode)
    ;; Since upgrading, the first-file hook seems to trigger before this hook, so I disable the hook manually...
    (centaur-tabs-mode -1)
    (beacon-mode -1)
    (evil-goggles-mode -1)
    ;; Disable flyspell hooks
    (remove-hook! '(org-mode-hook
                    markdown-mode-hook
                    TeX-mode-hook
                    rst-mode-hook
                    mu4e-compose-mode-hook
                    message-mode-hook
                    git-commit-mode-hook)
      #'flyspell-mode)
    (setq +ligatures-in-modes nil)))
(add-hook! 'after-make-frame-functions '+doom-disable-graphical-modes)
#+end_src

*** Frames

Automatically maximize and focus new graphical frames.
#+begin_src elisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(defun raise-frame-and-give-focus (&optional frame)
  (when (display-graphic-p frame)
    (raise-frame frame)
    (x-focus-frame frame)))
(add-hook 'after-make-frame-functions 'raise-frame-and-give-focus)
#+end_src

*** Workspaces

Add an API to create default workspace names for specific applications.
#+begin_src elisp
(defun +workspace--generate-named-id (&optional prefix)
  (or (cl-loop for name in (+workspace-list-names)
               when (string-match-p (format "^%s#[0-9]+$" prefix) name)
               maximize (string-to-number (substring name (+ (length prefix) 1))) into max
               finally return (if max (1+ max)))
      1))
(cl-defun +workspace/rename-frame (name &optional (frame (selected-frame)))
  "Create a blank, new perspective and associate it with FRAME."
  (when persp-mode
    (+workspace/rename (format "%s#%s" name (+workspace--generate-named-id name)))
    (set-frame-parameter frame 'workspace (+workspace-current-name))))
#+end_src

*** Windows
**** Settings

Focus the new window on vertical/horizontal splits.
#+begin_src elisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Prompt for the workspace buffer to show on new window.
#+begin_src elisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (+ivy/switch-workspace-buffer))
#+end_src

**** Hydra

Add a global hydra for window management.
#+begin_src elisp
(after! pretty-hydra
  (pretty-hydra-define +hydra/window-management
    (:separator "‚ïê" :title (+hydra/title-generator "Window Management" "windows" 47))
    ("Switch"
     (("h" evil-window-left "left")
      ("j" evil-window-down "down")
      ("k" evil-window-up "up")
      ("l" evil-window-right "right"))
     "Swap"
     (("H" +evil/window-move-left "left")
      ("J" +evil/window-move-down "down")
      ("K" +evil/window-move-up "up")
      ("L" +evil/window-move-right "right"))
     "Arrange"
     (("n" evil-window-new "new")
      ("d" +workspace/close-window-or-workspace "delete")
      ("s" evil-window-split "split horiz.")
      ("v" evil-window-vsplit "split vert."))
     "Focus"
     (("o" doom/window-enlargen "enlargen")
      ("mm" doom/window-maximize-buffer "maximize")
      ("ms" doom/window-maximize-horizontally "maximize horiz.")
      ("mv" doom/window-maximize-vertically "maximize vert."))
     "Layout"
     (("r" evil-window-rotate-downwards "rotate down")
      ("R" evil-window-rotate-upwards "rotate up")
      ("\\" rotate-layout "rotate layout")
      ("u" winner-undo "undo")
      ("C-r" winner-redo "redo"))
     "Popup"
     (("p" +popup/other "next")
      ("P" +popup/toggle "toggle")
      ("f" +popup/raise "raise")
      ("F" +popup/buffer "buffer"))
     "Resize"
     (("<" evil-window-decrease-width "-width")
      (">" evil-window-increase-width "+width")
      ("-" evil-window-decrease-height "-height")
      ("+" evil-window-increase-height "+height")
      ("=" balance-windows "balance"))
     "Buffer"
     (("[" previous-buffer "prev")
      ("]" next-buffer "next")
      ("," +ivy/switch-workspace-buffer "switch")
      ("." counsel-find-file "find file")))))
#+end_src

**** Bindings

Customize window management bindings.
#+begin_src elisp
(map!
 :n "]w"          #'evil-window-next
 :n "[w"          #'evil-window-prev

 :map evil-window-map
 :desc "Window management"
 "SPC"                #'+hydra/window-management/body
 ;; Navigation
 "a"                  #'ace-window
 "]"                  #'evil-window-next
 "["                  #'evil-window-prev
 ;; "<left>"             #'evil-window-left
 ;; "<down>"             #'evil-window-down
 ;; "<up>"               #'evil-window-up
 ;; "<right>"            #'evil-window-right
 ;; ;; Moving windows
 ;; "S-<left>"           #'+evil/window-move-left
 ;; "S-<down>"           #'+evil/window-move-down
 ;; "S-<up>"             #'+evil/window-move-up
 ;; "S-<right>"          #'+evil/window-move-right
 ;; Popups
 "p"                  #'+popup/other        ; Better than C-x p
 "P"                  #'+popup/toggle       ; Alternative to C-`
 "f"                  #'+popup/raise        ; Alternative to C-~
 "F"                  #'+popup/buffer
 ;; Miscellaneous
 "`"                  #'evil-window-mru     ; Consistent with SPC `
 "\\"                 #'rotate-layout       ; From rotate pkg
 "c"                  nil                   ; Confusing, use 'd'
 ;; Remove duplicate window bindings
 "C-_"                nil
 "C-h"                nil
 "C-l"                nil
 "C-j"                nil
 "C-k"                nil
 "C-n"                nil
 "C-p"                nil
 "C-b"                nil
 "C-t"                nil
 "C-s"                nil
 "C-v"                nil
 "C-u"                nil
 "C-S-r"              nil
 "C-S-s"              nil)
#+end_src

*** Buffers
**** Hydra

Add a global hydra for buffer management.
#+begin_src elisp
(after! pretty-hydra
  (pretty-hydra-define +hydra/buffer-management
    (:hint nil :separator "‚ïê" :title (+hydra/title-generator "Buffer Management" "files-o" 34))
    ("Tab"
     (("h" +tabs:previous-or-goto "prev")
      ("l" +tabs:next-or-goto "next")
      ("H" centaur-tabs-move-current-tab-to-left "move left")
      ("L" centaur-tabs-move-current-tab-to-right "move right")
      ("j" centaur-tabs-forward-group "next group")
      ("k" centaur-tabs-backward-group "prev group")
      ("g" centaur-tabs-counsel-switch-group "switch group"))
     "Switch"
     (("b" +ivy/switch-workspace-buffer "switch")
      ("B" +ivy/switch-buffer "switch all")
      ("n" evil-buffer-new "new")
      ("x" doom/open-scratch-buffer "scratch")
      ("f" counsel-find-file "find file"))
     "Region"
     (("-" doom/toggle-narrow-buffer "narrow" :toggle (buffer-narrowed-p))
      ;; TODO: +evil:narrow-buffer : How to specify arg BANG? <!>??
      ("+" doom/narrow-buffer-indirectly "narrow indirect"))
     "Save"
     (("s" basic-save-buffer "save")
      ("S" evil-write-all "save all")
      ("u" doom/sudo-save-buffer "sudo save")
      ("r" revert-buffer "revert"))
     "Kill"
     (("z" bury-buffer "bury")
      ("d" kill-current-buffer "kill")
      ("D" doom/kill-other-buffers "kill other")
      ("C-d" doom/kill-all-buffers "kill all")))))
#+end_src

**** Bindings

#+begin_src elisp
(after! pretty-hydra
  (map! :leader :prefix "b"
        :desc "Buffer management"
        "SPC" #'+hydra/buffer-management/body))
#+end_src

See [[*Centaur tabs][Centaur Tabs]].

*** Line numbers

Relative line numbers are fantastic for knowing how far away line numbers are,
then =12 <UP>= gets you exactly where you think.
Sadly, due to the (very) significant performance hit (mainly on scrolling),
they are disabled by default.
#+begin_src elisp
(setq display-line-numbers-type nil)
;; (setq display-line-numbers-type 'relative)
#+end_src

* Package configuration

See the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#configuring-doom][configuration instructions]] from the doom documentation.

** Beacon

#+begin_src elisp
(use-package! beacon
  :config
  (setq beacon-color 0.7
        beacon-size 24
        beacon-blink-delay 0.2
        beacon-blink-duration 0.2)
  (nconc beacon-dont-blink-commands
         '(evil-ex-search-next
           evil-ex-search-previous
           evil-ex-search-forward
           evil-ex-search-backward
           evil-ex-search-word-forward
           evil-ex-search-word-backward))
  ;; FIXME: Persp-mode must be doing something after the hook that cancels the blink.
  ;; (add-hook! 'persp-activated-functions
  ;;   (defun beacon--on-persp-activate (_target)
  ;;     (beacon-blink-automated)))
  (add-hook! doom-first-file #'beacon-mode))
#+end_src

** Better jumper

Add post-jump hook to show context around point in org-mode.
#+begin_src elisp
(after! better-jumper
  (add-hook! 'better-jumper-post-jump-hook
    (defun +psydev/org-better-jumper-visibility ()
      (when (derived-mode-p 'org-mode)
        (org-show-set-visibility 'lineage)))))
#+end_src

Bind better-jumper functions to a doom-like alternative.
#+begin_src elisp
(after! better-jumper
  (map!
   :n "g[" #'better-jumper-jump-backward
   :n "g]" #'better-jumper-jump-forward))
#+end_src

** Calendar

Configure localization settings.
#+begin_src elisp
(after! calendar
  (setq calendar-date-style 'european
        calendar-time-display-form
        '(24-hours ":" minutes
                   (if time-zone " (") time-zone (if time-zone ")"))
        calendar-latitude 44.81537
        calendar-longitude 4.48834
        calendar-location-name "Saint-Pierreville"))
#+end_src

*** Diary

Make holidays, diaries and today's date visible in calendar by default.
#+begin_src elisp
(after! calendar
  (setq calendar-mark-holidays-flag 't
        calendar-mark-diary-entries-flag 't)
  (add-hook! 'calendar-today-visible-hook #'calendar-mark-today))
#+end_src

Adapt sunrise/sunset diary sexp.
#+begin_src elisp
(require 'solar)

;; Sunrise (edits by Eph Zero)
;; Brady Trainor
;; http://stackoverflow.com/questions/22889036/custom-diary-sunrise-function-not-working-autoload-diary-emacs
(defun solar-sunrise-string (date &optional nolocation)
  "String of *local* time of sunrise and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "ÔÅë %s (%s de jour)" ;üåÖ
     (if (car l)
         (concat "Lever du Soleil " (apply 'solar-time-string (car l)))
       "Aucun Lever du Soleil")
     (nth 2 l))))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunrise ()
  "Local time of sunrise as a diary entry.
Accurate to a few seconds."
  (with-no-warnings (defvar date))
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunrise-string date))

;; Sunset
(defun solar-sunset-string (date &optional nolocation)
  "String of *local* time of sunset and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "ÔÅí %s" ;üåÖ
     (if (cadr l)
         (concat "Coucher du Soleil " (apply 'solar-time-string (cadr l)))
       "Aucun Coucher du Soleil"))))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunset ()
  "Local time of sunset as a diary entry.
Accurate to a few seconds."
  (with-no-warnings (defvar date))
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunset-string date))
#+end_src

Adapt solar holidays to diary-compatible expressions.
#+begin_src elisp
;;;###diary-autoload
(defun diary-equinoxes-solstices ()
  "Equinoxes/Solstices diary entry."
  (with-no-warnings (defvar displayed-month)
                    (defvar displayed-year))
  (let* ((displayed-month (calendar-extract-month date))
         (displayed-year  (calendar-extract-year  date))
         (event (solar-equinoxes-solstices)))
    (when (calendar-date-equal date (car (car event)))
      (car (cdr (car event))))))
(defun diary-daylight-saving-time ()
  "Daylight Saving Time diary entry."
  (let ((start (calendar-dst-starts (calendar-extract-year date)))
        (end (calendar-dst-ends (calendar-extract-year date))))
    (cond ((calendar-date-equal date start)
           (format "Heure d'√©t√© %s"
                   (solar-time-string
                    (/ calendar-daylight-savings-starts-time (float 60))
                    calendar-standard-time-zone-name)))
          ((calendar-date-equal date end)
           (format "Heure d'Hiver %s"
                   (solar-time-string
                    (/ calendar-daylight-savings-ends-time (float 60))
                    calendar-daylight-time-zone-name))))))
#+end_src

Add support for included diary files.
#+begin_src elisp
(after! calendar
  (add-hook 'diary-list-entries-hook #'diary-include-other-diary-files)
  (add-hook 'diary-list-entries-hook #'diary-sort-entries t)
  (add-hook 'diary-mark-entries-hook #'diary-mark-included-diary-files))
#+end_src

Add a default diary file since I will be using org mode for appointments and other diary entries.
This is a way to keep solar/lunar information available in the calendar.
#+begin_src diary :tangle ~/.local/share/emacs/etc/diary
&%%(diary-sunrise-sunset)
%%(diary-lunar-phases)
%%(diary-equinoxes-solstices)
%%(diary-daylight-saving-time)
#+end_src

*** Holidays

Customize solar/lunar phase names.
#+begin_src elisp
(after! calendar
  (setq lunar-phase-names
        '("üåë Nouvelle Lune"
          "üåì Premier Quartier de Lune"
          "üåï Pleine Lune"
          "üåó Dernier Quartier de Lune")
        solar-n-hemi-seasons
        '("Equinoxe de Printemps"
          "Solstice d'√ât√©"
          "Equinoxe d'Automne"
          "Solstice d'Hiver")))
#+end_src

Customize [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Holiday-Customizing.html][holidays]].
#+begin_src elisp
(after! calendar
  (setq holiday-general-holidays
        ;; Replace most US holidays by french/european holidays
        '((holiday-fixed  1  1    "Nouvel An")
          (holiday-fixed  5  1    "F√™te du Travail")
          (holiday-fixed  5  8    "F√™te de la Victoire")
          (holiday-fixed  5  9    "Jour de l'Europe")
          (holiday-fixed  7 14    "F√™te Nationale")
          (holiday-float  5  0  2 "F√™te Nationale de Jeanne d'Arc et du Patriotisme")
          (holiday-fixed 11 11    "Jour de l'Armistice")
          ;; Selected holidays from other countries
          (holiday-fixed  6 23    "F√™te Nationale (Luxembourg)")
          (holiday-float  1  1  3 "Martin Luther King Day (US)")
          (holiday-float  2  1  3 "President's Day (US)")
          (holiday-fixed  7  4    "Independence Day (US)")
          (holiday-float 11  4  4 "Thanksgiving (US)"))
        ;; Other national/international holidays
        holiday-other-holidays
        '((holiday-fixed  2 14    "F√™te de la Saint-Valentin")
          (holiday-fixed  3  8    "Journ√©e Internationale des Femmes")
          (holiday-fixed  3 17    "F√™te de la Saint-Patrick")
          (holiday-fixed  4  1    "Jour du Poisson d'Avril")
          (holiday-fixed  4 22    "Jour de la Terre")
          (holiday-fixed  5 22    "Journ√©e Internationale de la Biodiversit√©")
          (holiday-float  5  5 -1 "F√™te des Voisins")
          (holiday-sexp  '(if (equal (holiday-easter-etc 49) (holiday-float 5 0 -1 nil))
                              (calendar-nth-named-day 1 0 6 year)
                            (calendar-nth-named-day -1 0 5 year))
                         "F√™te des M√®res")
          (holiday-float  6  0  3 "F√™te des P√®res")
          (holiday-fixed  6 21    "F√™te de la Musique")
          (holiday-float  9  6  4 "F√™te de la Gastronomie") ; Fourth week-end of september
          (holiday-fixed 11 20    "Journ√©e Internationale des droits de l'Enfant"))
        ;; Astral events are converted to diary entries.
        holiday-solar-holidays nil
        ;; Christian holidays
        holiday-christian-holidays
        '((holiday-float  1  0  1 "√âpiphanie")
          (holiday-fixed  2  2    "Chandeleur")
          (holiday-fixed  8 15    "Assomption de Marie")
          (holiday-fixed 11  1    "Toussaint")
          (holiday-fixed 11  2    "Jour des Morts")
          (holiday-advent 0       "Premier dimanche de l'Avent")
          (holiday-fixed 12  6    "Saint-Nicolas")
          (holiday-fixed 12 25    "No√´l")
          (holiday-fixed 12 26    "Saint-√âtienne")
          ;; Easter-related holidays
          (apply 'append
                 (mapcar (lambda (e) (apply 'holiday-easter-etc e))
                         '((-47 "Mardi Gras")
                           (-46 "Mercredi des Cendres")
                           (-14 "Dimanche de la Passion")
                           (-7  "Dimanche des Palmes")
                           (-4  "Mercredi Saint")
                           (-3  "Jeudi Saint")
                           (-2  "Vendredi Saint")
                           (-1  "Samedi Saint")
                           (0   "Dimanche de P√¢ques")
                           (1   "Lundi de P√¢ques")
                           (39  "Ascension")
                           (49  "Pentec√¥te")
                           (50  "Lundi de Pentec√¥te")
                           (56  "F√™te de la Sainte Trinit√©")
                           (60  "Corpus Christi")
                           (68  "F√™te du Sacr√©-C≈ìur")))))
        ;; Other cultures
        holiday-islamic-holidays
        '((holiday-islamic-new-year)
          (holiday-islamic  9  1 "Ramadan Begins")
          (holiday-islamic 10 -1 "Ramadan Ends"))
        holiday-oriental-holidays
        '((holiday-chinese-new-year))
        holiday-hebrew-holidays nil
        holiday-bahai-holidays nil))
#+end_src

*** Bindings

Disable evil-snipe.
#+begin_src elisp
(after! evil-snipe
  (add-to-list 'evil-snipe-disabled-modes 'calendar-mode))
#+end_src

Configure bindings.
#+begin_src elisp
(map! :after calendar
      :map calendar-mode-map
      :n "C-k"    #'calendar-beginning-of-month
      :n "C-j"    #'calendar-end-of-month
      :n "C-h"    #'calendar-beginning-of-week
      :n "C-l"    #'calendar-end-of-week
      :n "C-S-k"  #'calendar-backward-year
      :n "C-S-j"  #'calendar-forward-year
      :n "C-S-h"  #'calendar-backward-month
      :n "C-S-l"  #'calendar-forward-month
      :n "M-k"    #'calendar-beginning-of-month
      :n "M-j"    #'calendar-end-of-month
      :n "M-h"    #'calendar-beginning-of-week
      :n "M-l"    #'calendar-end-of-week
      :n "M-S-k"  #'calendar-backward-year
      :n "M-S-j"  #'calendar-forward-year
      :n "M-S-h"  #'calendar-backward-month
      :n "M-S-l"  #'calendar-forward-month
      :n "C-u"    #'calendar-scroll-right
      :n "C-d"    #'calendar-scroll-left

      :n "r"      #'calendar-redraw
      :n "S"      #'calendar-sunrise-sunset
      :n "M"      #'calendar-lunar-phases
      :n "H"      #'calendar-cursor-holidays
      :n "s"      nil
      :n "ss"     #'calendar-sunrise-sunset
      :n "sm"     #'calendar-lunar-phases
      :n "sh"     #'calendar-cursor-holidays
      :n "sH"     #'calendar-list-holidays

      :n "i"      nil
      :n "id"     #'diary-insert-entry
      :n "iw"     #'diary-insert-weekly-entry
      :n "im"     #'diary-insert-monthly-entry
      :n "iy"     #'diary-insert-yearly-entry
      :n "ia"     #'diary-insert-anniversary-entry
      :n "ib"     #'diary-insert-block-entry
      :n "ic"     #'diary-insert-cyclic-entry
      :n "a"      #'diary-show-all-entries

      :n [return] #'org-calendar-goto-agenda
      :n "RET"    #'org-calendar-goto-agenda

      :leader
      (:prefix-map ("o" . "open")
       :desc "Calendar" "c" #'org-goto-calendar))
#+end_src

** Centaur tabs

Configure centaur-tabs appearance and behavior. Define rules for buffer groups
and restrict buffer list to workspace buffers.
#+begin_src elisp
(use-package! centaur-tabs
  :config
  (setq centaur-tabs-style "bar"
        centaur-tabs-set-bar 'under
        centaur-tabs-height 32
        centaur-tabs-set-icons t
        centaur-tabs-gray-out-icons nil
        centaur-tabs-show-new-tab-button t
        x-underline-at-descent-line t)
  (centaur-tabs-headline-match)

  ;; Override rules for grouping buffers.
  (defun centaur-tabs-buffer-groups ()
    "`centaur-tabs-buffer-groups' control buffers' group rules.

Group centaur-tabs with mode if buffer is derived from `vterm-mode'
`dired-mode' `org-mode' `magit-mode'.
All buffer name start with * will group to \"Emacs\".
Other buffer group by `centaur-tabs-get-group-name' with project name."
    (list
     (cond
      ((or (string-equal "*" (substring (buffer-name) 0 1))
           (memq major-mode '(magit-process-mode
                              magit-status-mode
                              magit-diff-mode
                              magit-log-mode
                              magit-file-mode
                              magit-blob-mode
                              magit-blame-mode
                              )))
       "Emacs")
      ((derived-mode-p 'term-mode 'vterm-mode)
       "Term")
      ;; ((derived-mode-p 'prog-mode)
      ;;  "Coding")
      ((derived-mode-p 'dired-mode)
       "Dired")
      ((memq major-mode '(org-mode org-agenda-mode diary-mode))
       "Org")
      (t
       (centaur-tabs-get-group-name (current-buffer))))))
  ;; Override centaur tabs to use workspace buffers as input list.
  (defun centaur-tabs-buffer-list ()
    "Return the list of buffers to show in tabs.
Exclude buffers whose name starts with a space, when they are not
visiting a file.  The current buffer is always included."
    (centaur-tabs-filter-out
     'centaur-tabs-hide-tab-cached
     (delq nil
           (cl-mapcar #'(lambda (b)
                          (cond
                           ;; Always include the current buffer.
                           ((eq (current-buffer) b) b)
                           ((buffer-file-name b) b)
                           ((char-equal ?\  (aref (buffer-name b) 0)) nil)
                           ((buffer-live-p b) b)))
                      (doom-buffer-list))))))
#+end_src

Provide additional bindings for centaur-tabs functions.
#+begin_src elisp
(after! centaur-tabs
  ;; Remove previous which-key descriptions.
  ;; TODO: Encapsulate in a function and use a regex.
  ;; TODO Move these bindings in a more appropriate, doom-related section
  ;; XXX: Breaks emacs...
  ;; (cl-delete-if
  ;;  (lambda (x)
  ;;    (member (car x)
  ;;            '(("\\`M-SPC b k\\'")
  ;;              ("\\`SPC b k\\'")
  ;;              ("\\`M-SPC b K\\'")
  ;;              ("\\`SPC b K\\'")
  ;;              ("\\`M-SPC b l\\'")
  ;;              ("\\`SPC b l\\'")
  ;;              ("\\`M-SPC b O\\'")
  ;;              ("\\`SPC b O\\'")
  ;;              ("\\`M-SPC b n\\'")
  ;;              ("\\`SPC b n\\'")
  ;;              ("\\`M-SPC b N\\'")
  ;;              ("\\`SPC b N\\'")
  ;;              ("\\`M-SPC b p\\'")
  ;;              ("\\`SPC b p\\'"))))
  ;;  which-key-replacement-alist)

  (map!
   ;; Rebind buffer switching to tab switching commands.
   :g [remap previous-buffer] #'+tabs:previous-or-goto
   :g [remap next-buffer]     #'+tabs:next-or-goto
   ;; Tab manipulation
   :g "C-<next>"    #'+tabs:next-or-goto
   :g "C-<prior>"   #'+tabs:previous-or-goto
   :g "C-M-<next>"  #'centaur-tabs-forward-group
   :g "C-M-<prior>" #'centaur-tabs-backward-group
   :n "gt"          #'+tabs:next-or-goto
   :n "gb"          #'+tabs:previous-or-goto
   :n "gT"          #'centaur-tabs-forward-group
   :n "gB"          #'centaur-tabs-backward-group
   :n "]B"          #'centaur-tabs-forward-group
   :n "[B"          #'centaur-tabs-backward-group
   :g "C-S-<prior>" #'centaur-tabs-move-current-tab-to-left
   :g "C-S-<next>"  #'centaur-tabs-move-current-tab-to-right

   ;; Bind most frequent cycling command to a convenient binding.
   :g "M-["                 #'+tabs:previous-or-goto
   :g "M-]"                 #'+tabs:next-or-goto

   :leader :prefix "b"
   ;; Buffer group navigation
   :desc "Switch buffer group"   "g" #'centaur-tabs-counsel-switch-group
   :desc "Next buffer group"     "j" #'centaur-tabs-forward-group
   :desc "Previous buffer group" "k" #'centaur-tabs-backward-group
   ;; Tab movement
   :desc "Next tab"              "l" #'+tabs:next-or-goto
   :desc "Previous tab"          "h" #'+tabs:previous-or-goto
   :desc "Move tab right"        "L" #'centaur-tabs-move-current-tab-to-right
   :desc "Move tab left"         "H" #'centaur-tabs-move-current-tab-to-left
   ;; Other stuff
   :desc "Kill other buffers"    "D" #'doom/kill-other-buffers
   :desc "Kill all buffers"      "C-d" #'doom/kill-all-buffers
   :desc ""                      "O" nil
   :desc "New empty buffer"      "n" #'evil-buffer-new
   :desc "New empty buffer"      "N" nil
   :desc ""                      "p" nil
   ;; Numbered buffer navigation
   :desc "Select tab 1"          "1" #'centaur-tabs-select-visible-tab
   :desc "Select tab 2"          "2" #'centaur-tabs-select-visible-tab
   :desc "Select tab 3"          "3" #'centaur-tabs-select-visible-tab
   :desc "Select tab 4"          "4" #'centaur-tabs-select-visible-tab
   :desc "Select tab 5"          "5" #'centaur-tabs-select-visible-tab
   :desc "Select tab 6"          "6" #'centaur-tabs-select-visible-tab
   :desc "Select tab 7"          "7" #'centaur-tabs-select-visible-tab
   :desc "Select tab 8"          "8" #'centaur-tabs-select-visible-tab
   :desc "Select tab 9"          "9" #'centaur-tabs-select-visible-tab
   :desc "Select last tab"       "0" #'centaur-tabs-select-end-tab))
#+end_src

** Company

Make aborting completions less annoying.
The ~evil-normal-state-entry-hook~ is triggered when the child frame opens to
describe the selected element (with ~+childframe~), so it can't be used here.
#+begin_src elisp
(after! company
  (add-hook 'evil-insert-state-exit-hook #'company-abort))
#+end_src

** Dired
*** Appearance

Customize general dired appearance.
#+begin_src elisp
(use-package! dired
  :config
  (setq dired-listing-switches "--group-directories-first -lhFG -v -a")
  ;; FIXME: dired--unhide removes text properties! Use revert-buffer to restore them
  (add-hook! (dired-mode dired-hide-details-mode)
    (defun dired-hide-dir-information ()
      (unless dired-hide-details-mode
        (add-to-invisibility-spec 'dired-hide-details-information))))
  ;; Disable evil-snipe as it shadows bindings for some reason.
  (add-hook! dired-mode
    (defun dired-disable-evil-snipe ()
      (evil-snipe-local-mode 0))))

(use-package! fd-dired
  :config
  (setq find-ls-option '("-print0 | xargs -0 ls -ldhFN" . "-ldhF"))
  (setq fd-dired-ls-option '("| xargs -0 ls -ldhFN" . "-ldhF")))
#+end_src

Omit some more files from being listed.
#+begin_src elisp
(use-package! dired-x
  :config
  (setq dired-omit-files (concat dired-omit-files "\\|\\.zwc\\'")))
#+end_src

Fix issues with all-the-icons:
- Use a consistent icon height.
- Disable icons on big folders (too slow).
- Use file-local-name for remote folders.
- Fix refresh issues on some dired operations.
#+begin_src elisp
(after! all-the-icons-dired
  ;; Patch the refesh function with a :height property to fix inconsistent line height.
  (defun all-the-icons-dired--refresh ()
    "Display the icons of files in a dired buffer."
    (all-the-icons-dired--remove-all-overlays)
    ;; Don't display icons in remote folders or if the folder has too many items.
    (if (<= (count-lines (point-min) (point-max)) 150)
        (save-excursion
          (goto-char (point-min))
          (while (not (eobp))
            (when (dired-move-to-filename nil)
              (let ((file (file-local-name (dired-get-filename 'relative 'noerror))))
                (when file
                  (let ((icon (if (file-directory-p file)
                                  (all-the-icons-icon-for-dir file
                                                              :face 'all-the-icons-dired-dir-face
                                                              :height 0.9 :v-adjust all-the-icons-dired-v-adjust)
                                (all-the-icons-icon-for-file file :height 0.9 :v-adjust all-the-icons-dired-v-adjust))))
                    (if (member file '("." ".."))
                        (all-the-icons-dired--add-overlay (point) "  \t")
                      (all-the-icons-dired--add-overlay (point) (concat icon "\t")))))))
            (forward-line 1)))))
  ;; Refresh the icons after some dired operations.
  (advice-add 'dired-add-entry :around #'all-the-icons-dired--refresh-advice)
  (advice-add 'dired-remove-entry :around #'all-the-icons-dired--refresh-advice)
  (advice-add 'dired-unsubdir :around #'all-the-icons-dired--refresh-advice)
  (advice-add 'dired-undo :around #'all-the-icons-dired--refresh-advice))
#+end_src

*** Commands

Add facilities to quickly toggle hidden files and recursive listing.
#+begin_src elisp
(defun dired-switches-all-p (switches)
  "Return non-nil if the string SWITCHES contains -a or --all."
  (dired-check-switches switches "a" "all"))

(defun +dired-toggle-hidden-files ()
  "Toggle hidden files in dired."
  (interactive)
  (dired-sort-other
   (if (dired-switches-all-p dired-actual-switches)
       (replace-regexp-in-string " \\(-a\\|--all\\)" "" dired-actual-switches)
     (concat dired-actual-switches " -a"))))

(defun +dired-toggle-recursive ()
  "Toggle recursive subdirectory listing in dired."
  (interactive)
  (dired-sort-other
   (if (dired-switches-recursive-p dired-actual-switches)
       (replace-regexp-in-string " \\(-R\\|--recursive\\)" "" dired-actual-switches)
     (concat dired-actual-switches " -R"))))
#+end_src

Open marked files in external applications.
#+begin_src elisp
(defun dired-do-open ()
  "Open file(s) in external applications."
  (interactive)
  (let* ((files (dired-get-marked-files)))
    (xdg-open-files files)))

(defun xdg-open-files (files)
  "Open a list of files with xdg-open."
  (dolist (file files)
    (xdg-open file)))

(defun xdg-open (file)
  "Open a file with xdg-open."
  (let ((command (format "nohup xdg-open </dev/null >/dev/null 2>&1 '%s'" file)))
    (shell-command command)))
#+end_src

Subroutine to jump to a standard directory. Totally stolen from ranger.
#+begin_src elisp
(defun +dired-go (path)
  "Go subroutine"
  (interactive
   (list
    (read-char-choice
     "e   : /etc
u   : /usr
d   : /dev
l   : follow directory link
L   : follow selected file
o   : /opt
v   : /var
h   : ~/
m   : /media
M   : /mnt
s   : /srv
r,/ : /
> "
     '(?q ?e ?u ?d ?l ?L ?o ?v ?h ?m ?M ?s ?r ?/))))
  (message nil)
  (let* ((c (char-to-string path))
         (new-path
          (cl-case (intern c)
            ('e "/etc")
            ('u "/usr")
            ('d "/dev")
            ('l (file-truename default-directory))
            ('L (file-truename (dired-get-filename)))
            ('o "/opt")
            ('v "/var")
            ('h  "~/")
            ('m "/media")
            ('M "/mnt")
            ('s "/srv")
            ('r "/")
            ('/ "/"))))
    (when (string-equal c "q")
      (keyboard-quit))
    (when (and new-path (file-directory-p new-path))
      (dired new-path))))
#+end_src

Run ediff from marked files in dired.
#+begin_src elisp
(after! dired
  ;; From https://oremacs.com/2017/03/18/dired-ediff/
  (defun +dired-ediff-files ()
    (interactive)
    (let ((files (dired-get-marked-files))
          (wnd (current-window-configuration)))
      (if (<= (length files) 2)
          (let ((file1 (car files))
                (file2 (if (cdr files)
                           (cadr files)
                         (read-file-name
                          "ediff with: "
                          (dired-dwim-target-directory)))))
            (if (file-newer-than-file-p file1 file2)
                (ediff-files file2 file1)
              (ediff-files file1 file2))
            (add-hook 'ediff-after-quit-hook-internal
                      (lambda ()
                        (setq ediff-after-quit-hook-internal nil)
                        (set-window-configuration wnd))))
        (error "no more than 2 files should be marked")))))
#+end_src

*** Hydra

Define a major-mode-hydra.
#+begin_src elisp
(after! dired
  (major-mode-hydra-define dired-mode
    (:color pink :title (+hydra/major-mode-title-generator 'dired-mode 58))
    ("Open"
     (("S-RET" dired-display-file "view other")
      ("M-RET" dired-view-file "view" :color blue)
      ("C-RET" dired-find-file-other-window "open other" :color blue)
      ("F" dired-do-find-marked-files "open marked" :color blue)
      ("o" dired-do-open "open ext")
      ("g" +dired-go "goto"))
     "Display"
     (("u" dired-undo "undo")
      ("r" dired-do-redisplay "redisplay")
      ("M-r" dired-do-redisplay "refresh")
      ("I" dired-maybe-insert-subdir "insert subdir")
      ("K" dired-kill-subdir "kill subdir"))
     "Toggle"
     (("s" dired-sort-toggle-or-edit "sort")
      ("M-i" dired-hide-details-mode "details" :toggle dired-hide-details-mode)
      ("M-v" dired-git-info-mode "git" :toggle dired-git-info-mode)
      ("M-h" +dired-toggle-hidden-files "hidden" :toggle (dired-switches-all-p dired-actual-switches))
      ("M-H" dired-omit-mode "omit-mode" :toggle dired-omit-mode)
      ("M-R" +dired-toggle-recursive "recursive" :toggle (dired-switches-recursive-p dired-actual-switches)))
     "Mark"
     (("m" dired-mark "mark")
      ("U" dired-unmark "unmark")
      ("M-u" dired-unmark-all-marks "unmark all")
      ("t" dired-toggle-marks "toggle"))
     "Basic"
     (("+" dired-create-directory "mkdir")
      ("Y" dired-copy-filename-as-kill "yank")
      ("O" dired-do-chown "chown")
      ("M-g" dired-do-chggrp "chgrp")
      ("M" dired-do-chgmode "chmod"))
     "Organize"
     (("C" dired-do-copy "copy")
      ("R" dired-do-rename "rename")
      ("D" dired-do-delete "delete")
      ("S" dired-do-symlink "symlink")
      ("Z" dired-do-compress "archive")
      ("M-z" dired-do-compress-to "archive to"))
     "Avanced"
     (("i" dired-toggle-read-only "wdired" :color blue)
      ("A" dired-do-find-regexp "find regexp" :color blue)
      ("Q" dired-do-find-regexp-and-replace "replace regexp" :color blue)
      ("e" +dired-ediff-files "ediff" :color blue)
      ("=" dired-diff "diff" :color blue)
      ("!" dired-do-shell-command "shell cmd" :color blue)

      ("q" nil :color blue)
      ("<escape>" nil :color blue)))))
#+end_src

*** Bindings

Customize default bindings.
#+begin_src elisp
(map! :after dired
      :map dired-mode-map
      ;; Prefer to navigate directories horizontally rather than the buffer.
      :n "h"          #'dired-up-directory
      :n "l"          #'dired-find-file
      ;; Rebind variants for opening the current file.
      :n "<C-return>" #'dired-find-file-other-window
      :n "<S-return>" #'dired-display-file
      :n "M-RET"      #'dired-view-file
      ;; Use TAB to fold/unfold as in other modes.
      :n "TAB"        #'dired-hide-subdir
      :n "<tab>"      #'dired-hide-subdir
      :n "<backtab>"  #'dired-hide-all
      ;; Miscellaneous
      :n "u"          #'dired-undo
      :nv "U"         #'dired-unmark
      :m "M-u"        #'dired-unmark-all-marks
      :n "K"          #'dired-kill-subdir
      :n "M-j"        #'dired-goto-subdir
      :n "s"          #'dired-sort-toggle-or-edit
      :n "o"          #'dired-do-open
      :n "f"          #'dired-create-empty-file
      :n "F"          #'dired-do-find-marked-files
      :n "M-g"        #'dired-do-chgrp
      :n "M-c"        #'dired-rsync
      :n "M-z"        #'dired-do-compress-to
      :n "M-r"        #'revert-buffer

      :n "e"          #'+dired-ediff-files
      :n "M-G"        #'+dired-go
      :n "M-i"        #'dired-hide-details-mode
      :n "M-v"        #'dired-git-info-mode
      :n "M-R"        #'+dired-toggle-recursive
      :n "M-h"        #'+dired-toggle-hidden-files
      :n "M-H"        #'dired-omit-mode

      :localleader
      "g"             #'+dired-go
      "d"             #'dired-hide-details-mode
      "i"             #'dired-git-info-mode
      "r"             #'+dired-toggle-recursive
      "h"             #'+dired-toggle-hidden-files
      "H"             #'dired-omit-mode
      "SPC"           #'major-mode-hydra)
#+end_src

** Ediff

Automatically kill unmodified buffers at the end of an ~ediff~ session.
In merge jobs, buffer C is never deleted. However, the side effect of using this
function is that you may not be able to compare the same buffer in two separate
~ediff~ sessions: quitting one of them will delete this buffer in another session
as well.
#+begin_src elisp
(after! ediff
  (setq-default ediff-keep-variants nil)
  (add-hook! 'ediff-cleanup-hook
    (defun ediff-kill-variants ()
      (ediff-janitor nil ediff-keep-variants))))
#+end_src

Automatically delete dedicated frames when quitting ~ediff~.
#+begin_src elisp
(after! ediff
  ;; Figure out if the session has a meta buffer during cleanup.
  ;; ediff-cleanup-mess seems to remove all possibilities of figuring that out.
  (defvar ediff--meta-session nil)
  (add-hook! 'ediff-cleanup-hook
    (defun ediff-mark-dedicated-frame-for-deletion ()
      (setq ediff--meta-session ediff-meta-buffer)))
  ;; Delete the current frame if it was dedicated to a simple ediff session.
  ;; This should be done after ediff-cleanup-mess.
  (add-hook! 'ediff-quit-hook :append
    (defun ediff-delete-dedicated-frame ()
      (unless ediff--meta-session
        (ediff-group-delete-dedicated-frame))))
  ;; Delete the current frame when quitting the last session group.
  (add-hook! 'ediff-quit-session-group-hook :append
    (defun ediff-group-delete-dedicated-frame ()
      (unless ediff-meta-session-number
        (when (string-match-p "^ediff#[0-9]+$" (frame-parameter nil 'workspace))
          (delete-frame))))))
#+end_src

Add evil bindings for ~ediff-meta-mode~:
#+begin_src elisp
(defvar evil-collection-ediff-registry-bindings
  '(("j" . ediff-next-meta-item)
    ("n" . ediff-next-meta-item)
    ("k" . ediff-previous-meta-item)
    ("p" . ediff-previous-meta-item)
    ("v" . ediff-registry-action)
    ("q" . ediff-quit-meta-buffer))
  "A list of bindings changed/added in evil-ediff-meta-buffer.")

(defun evil-collection-ediff-meta-buffer-startup-hook ()
  "Place evil-ediff-meta bindings in `ediff-meta-buffer-map'."
  (evil-make-overriding-map ediff-meta-buffer-map 'normal)
  (dolist (entry evil-collection-ediff-registry-bindings)
    (define-key ediff-meta-buffer-map (car entry) (cdr entry)))
  (evil-normalize-keymaps)
  nil)

(defun evil-collection-ediff-meta-buffer-setup ()
  "Initialize evil-ediff-meta-buffer."
  (interactive)
  (evil-set-initial-state 'ediff-meta-mode 'normal)
  (add-hook 'ediff-meta-buffer-keymap-setup-hook 'evil-collection-ediff-meta-buffer-startup-hook))
(evil-collection-ediff-meta-buffer-setup)
#+end_src

Customize default doom-theme faces for ~ediff~.
#+begin_src elisp
(custom-set-faces!
  '(ediff-even-diff-Ancestor    :inherit ediff-even-diff-A)
  '(ediff-odd-diff-Ancestor     :inherit ediff-even-diff-A)
  '(ediff-current-diff-Ancestor :inherit ediff-current-diff-A)
  `(ediff-current-diff-A        :background ,(doom-color 'base3))
  '(ediff-fine-diff-A           :inherit magit-diff-our-highlight :background unspecified :weight unspecified)
  '(ediff-fine-diff-B           :inherit magit-diff-their-highlight)
  '(ediff-fine-diff-C           :inherit magit-diff-base-highlight)
  `(ediff-fine-diff-Ancestor    :foreground ,(doom-color 'blue) :background ,(doom-blend 'blue 'bg 0.2) :weight bold :extend t))
#+end_src

** Elfeed

Configure elfeed and elfeed-org.
#+begin_src elisp
(use-package! elfeed
  :config
  (setq elfeed-search-remain-on-entry 't
        elfeed-search-sort-function #'psydev/elfeed-search-entry<
        elfeed-sort-order 'ascending)
  (elfeed-set-max-connections 8) ; default is 16
  (elfeed-set-timeout 60))       ; default is 30

(use-package! elfeed-org
  :after org
  :config
  (setq elfeed-search-filter "+unread +starred "
        rmh-elfeed-org-files (list (concat org-directory "elfeed/feed.org"))
        rmh-elfeed-org-tree-id "feed")
  (elfeed-org))
#+end_src

*** Integration

Fix elfeed-search-selected to avoid including the line below selection.
This is properly not the right approach to this issue but is functional.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-search-selected (&optional ignore-region-p)
    "Return a list of the currently selected feeds.

If IGNORE-REGION-P is non-nil, only return the entry under point."
    (let ((use-region (and (not ignore-region-p) (use-region-p))))
      (let ((start (if use-region (region-beginning) (point)))
            (end   (if use-region (- (region-end) 1) (point))))
        (cl-loop for line from (line-number-at-pos start)
                 to (line-number-at-pos end)
                 for offset = (- line elfeed-search--offset)
                 when (and (>= offset 0) (nth offset elfeed-search-entries))
                 collect it into selected
                 finally (return (if ignore-region-p
                                     (car selected)
                                   selected))))))
  (advice-add #'elfeed-search-selected :override #'psydev/elfeed-search-selected))
#+end_src

Add advice to elfeed-update to make sure the list of feed is up to date.
#+begin_src elisp
(after! elfeed-org
  (defadvice elfeed-update (before configure-elfeed activate)
    "Load all feed settings before elfeed updates."
    (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)))
#+end_src

Prevent killing org-mode buffers from ~rmh-elfeed-org-files~.
Also fix perspective issues: killing twice the elfeed-search buffers was messing up the persp.
#+begin_src elisp
(after! elfeed-org
  (defun +rss-cleanup-h ()
    "Clean up after an elfeed session. Kills all elfeed buffers."
    (interactive)
    ;; FIXME This bit was added in an attempt to return to dashboard, but breaks the persp
    ;; (if (persp-contain-buffer-p elfeed-dashboard--buf)
    ;;     (switch-to-buffer elfeed-dashboard--buf))
    ;; FIXME This seems to break the perspective as well, reason not understood
    ;; (let ((buf (switch-to-prev-buffer)))
    ;;   (when (or (null buf) (not (doom-real-buffer-p buf)))
    ;;     (switch-to-buffer (doom-fallback-buffer))))
    (let ((search-buffers (doom-buffers-in-mode 'elfeed-search-mode))
          (show-buffers (doom-buffers-in-mode 'elfeed-show-mode))
          kill-buffer-query-functions)
      (dolist (b search-buffers)
        (when (not (eq b (current-buffer)))
          (with-current-buffer b
            (remove-hook 'kill-buffer-hook #'+rss-cleanup-h :local)
            (kill-buffer b))))
      (mapc #'kill-buffer show-buffers))
    (+workspace/delete +rss-workspace-name)))
#+end_src

Override ~elfeed-db-compact~ to bypass the projectile cache.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-db-compact ()
    "Minimize the Elfeed database storage size on the filesystem."
    (interactive)
    ;; `delete-file-projectile-remove-from-cache' slows down `elfeed-db-compact'
    ;; tremendously, so we disable the projectile cache:
    (let (projectile-enable-caching)
      (elfeed-db-compact))))
#+end_src

*** Date Separators

Add date separator overlay. Thanks, [[https://gist.github.com/alphapapa/80d2dba33fafcb50f558464a3a73af9a][alphapapa!]]
#+begin_src elisp
(after! elfeed
  (cl-defun psydev/elfeed-search-add-separators (&key (min-group-size 2))
    "Insert overlay spacers where the current date changes.
If no group has at least MIN-GROUP-SIZE items, no spacers will be
inserted. "
    ;; TODO: Use column-specific functions so that, e.g. date column could be grouped by month/year
    (cl-labels ((insert-date (date)
                             (ov (line-beginning-position) (line-beginning-position)
                                 'before-string (propertize (format "%s%s\n"
                                                                    (if (= 1 (line-number-at-pos)) "" "\n")
                                                                    date)
                                                            'face 'elfeed-search-date-face)
                                 'type 'date-separator))
                (entry-date (offset)
                            (when-let ((entry (nth offset elfeed-search-entries)))
                              (elfeed-search-format-date (elfeed-entry-date entry)))))
      (ov-clear)
      (save-excursion
        (goto-char (point-min))
        (cl-loop with largest-group-size = 1
                 with offset = (- 1 elfeed-search--offset) ; 1 is first line
                 with prev-data = (entry-date offset)

                 initially do (when prev-data
                                (insert-date prev-data))

                 while (not (eobp))
                 do (progn
                      (forward-line 1)
                      (incf offset))

                 for current-data = (entry-date offset)
                 if (not (equal current-data prev-data))
                 do (when current-data
                      (insert-date current-data)
                      (setq prev-data current-data))
                 else do (incf largest-group-size)

                 finally do (when (< largest-group-size min-group-size)
                              (ov-clear))))))

  (defun psydev/elfeed-search-post-process ()
    (psydev/elfeed-search-add-separators :min-group-size 1))

  (defun psydev/elfeed-forward-day ()
    "Move forward to the next day."
    (interactive)
    (let ((o (ov-in-next 'type 'date-separator)))
      (if o (goto-char (ov-end o)))))
  (defun psydev/elfeed-backward-day ()
    "Move backward to the previous day."
    (interactive)
    (let ((o (ov-in-prev 'type 'date-separator)))
      (if o (goto-char (ov-end o)))))

  (add-hook 'elfeed-search-update-hook #'psydev/elfeed-search-post-process))
#+end_src

Add missing overlay commands.
NOTE: Hopefully these overlay functions can be merged into ov.el.  See
https://github.com/ShingoFukuyama/ov.el/issues/14
#+begin_src elisp
(after! ov
  (cl-defun ov-in-prev (&optional point-or-prop prop-or-val (val 'any))
    "Get the previous overlay satisfying a condition.

If POINT-OR-PROP is a symbol, get the previous overlay with this
property being non-nil.

If PROP-OR-VAL is non-nil, the property should have this value.

If POINT-OR-PROP is a number, get the previous overlay after this
point.

If PROP-OR-VAL and VAL are also specified, get the previous
overlay after POINT-OR-PROP having property PROP-OR-VAL set to
VAL (with VAL unspecified, only the presence of property is
tested)."
    (cl-labels ((any (pos)
                     (car (overlays-in (previous-overlay-change pos) (previous-overlay-change pos))))
                (property (pos property)
                          (save-excursion
                            (goto-char pos)
                            (cl-loop while (and (not (bobp))
                                                (goto-char (previous-overlay-change (point))))
                                     when (cl-loop for ov in (overlays-in (point) (point))
                                                   when (plist-get (ov-prop ov) property)
                                                   return ov)
                                     return it)))
                (property-value (pos property value)
                                (save-excursion
                                  (goto-char pos)
                                  (cl-loop while (and (not (bobp))
                                                      (goto-char (previous-overlay-change (point))))
                                           when (cl-loop for ov in (overlays-in (point) (point))
                                                         for ov-value = (plist-get (ov-prop ov) property)
                                                         when (equal ov-value value)
                                                         return ov)
                                           return it))))
      (pcase point-or-prop
        ((pred numberp) (pcase prop-or-val
                          (`nil (any point-or-prop))
                          (_ (pcase val
                               ('any (property point-or-prop prop-or-val))
                               (_ (property-value point-or-prop prop-or-val val))))))
        (`nil (any (point)))
        (_ (pcase prop-or-val
             (`nil (property (point) point-or-prop))
             (_ (pcase val
                  ('any (property (point) point-or-prop))
                  (_ (property-value point-or-prop prop-or-val val)))))))))

  (cl-defun ov-in-next (&optional point-or-prop prop-or-val (val 'any))
    "Get the next overlay satisfying a condition.

If POINT-OR-PROP is a symbol, get the next overlay with this
property being non-nil.

If PROP-OR-VAL is non-nil, the property should have this value.

If POINT-OR-PROP is a number, get the next overlay after this
point.

If PROP-OR-VAL and VAL are also specified, get the next overlay
after POINT-OR-PROP having property PROP-OR-VAL set to VAL (with
VAL unspecified, only the presence of property is tested)."
    (cl-labels ((any (pos)
                     (car (overlays-in (next-overlay-change pos) (next-overlay-change pos))))
                (property (pos property)
                          (save-excursion
                            (goto-char pos)
                            (cl-loop while (and (not (eobp))
                                                (goto-char (next-overlay-change (point))))
                                     when (cl-loop for ov in (overlays-in (point) (point))
                                                   when (plist-get (ov-prop ov) property)
                                                   return ov)
                                     return it)))
                (property-value (pos property value)
                                (save-excursion
                                  (goto-char pos)
                                  (cl-loop while (and (not (eobp))
                                                      (goto-char (next-overlay-change (point))))
                                           when (cl-loop for ov in (overlays-in (point) (point))
                                                         for ov-value = (plist-get (ov-prop ov) property)
                                                         when (equal ov-value value)
                                                         return ov)
                                           return it))))
      (pcase point-or-prop
        ((pred numberp) (pcase prop-or-val
                          (`nil (any point-or-prop))
                          (_ (pcase val
                               ('any (property point-or-prop prop-or-val))
                               (_ (property-value point-or-prop prop-or-val val))))))
        (`nil (any (point)))
        (_ (pcase prop-or-val
             (`nil (property (point) point-or-prop))
             (_ (pcase val
                  ('any (property (point) point-or-prop))
                  (_ (property-value point-or-prop prop-or-val val))))))))))
#+end_src

*** Sorting

Improved sort function. Thanks, [[https://gist.github.com/alphapapa/80d2dba33fafcb50f558464a3a73af9a][alphapapa!]]
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-search-entry< (a b)
    "Return non-nil if A should be sorted before B."
    (with-no-warnings (defvar a-tags) (defvar b-tags)) ; NOTE Needed to fix void a-tags?
    (cl-flet* ((tags (it) (elfeed-entry-tags it))
               (day (it) (time-to-days (seconds-to-time (elfeed-entry-date it))))
               (compare-days (a b)
                             (let* ((a-day (day a))
                                    (b-day (day b)))
                               (if (= a-day b-day)
                                   ;; Same day: compare unread, then tags, then domain, then timestamp
                                   (cl-case (psydev/elfeed-search-unread< a-tags b-tags)
                                     ('< nil)
                                     ('> 't)
                                     ('= ;; Same unread status; compare feed title
                                      ;; Same day: compare tags, then domain, then timestamp
                                      (cl-case (psydev/elfeed-search-tags< a-tags b-tags)
                                        ('< nil)
                                        ('> 't)
                                        ('= ;; Same tags; compare feed title
                                         (cl-case (psydev/elfeed-search-feed< a b)
                                           ('< nil)
                                           ('> 't)
                                           ('= ;; Same site; compare timestamp
                                            (< (elfeed-entry-date a) (elfeed-entry-date b))))))))
                                 ;; Different day: compare day
                                 (< a-day b-day)))))
      (let* ((a-tags (tags a))
             (b-tags (tags b))
             (a-starred (member 'starred a-tags))
             (b-starred (member 'starred b-tags)))
        ;; Inverting the values because we usually use descending order
        (cond ((and a-starred b-starred) (compare-days a b))
              (a-starred nil)
              (b-starred t)
              (t (compare-days a b))))))

  (defun psydev/elfeed-search-unread< (a-tags b-tags)
    "Return the relationship of A's unread tag to B's."
    (cl-flet ((unread (it) (member 'unread it)))
      (let ((a-unread (unread a-tags))
            (b-unread (unread b-tags)))
        (cond ((and a-unread b-unread) '=)
              ((not b-unread) '<)
              (t '>)))))

  (defun psydev/elfeed-search-tags< (a-tags b-tags)
    "Return the relationship of A's tags to B's."
    ;; Convert list of symbols to comma-separated string of tags
    (if (not (or a-tags b-tags))
        ;; No tags
        '=
      ;; Some tags
      (if (not (and a-tags b-tags))
          ;; One item has no tags
          (if a-tags
              '<
            '>)
        ;; Both items have tags
        (let ((a-length (length a-tags))
              (b-length (length b-tags)))
          (if (/= a-length b-length)
              ;; Different number of tags
              (if (< a-length b-length)
                  '<
                '>)
            ;; Same number of tags
            (let ((a-string (s-join "" (mapcar #'symbol-name a-tags)))
                  (b-string (s-join "" (mapcar #'symbol-name b-tags))))
              (cond ((string= a-string b-string) '=)
                    ((string< a-string b-string) '<)
                    (t '>))))))))

  (defun psydev/elfeed-search-feed< (a b)
    "Return the relationship of A's feed to B's.
If alphabetically less or greater than, return `<' or `>',
respectively.  If the same, return `='."
    (cl-flet ((feed (it) (elfeed-feed-title (elfeed-entry-feed it))))
      (let ((a-feed (feed a))
            (b-feed (feed b)))
        (cond ((string= a-feed b-feed) '=)
              ((string< a-feed b-feed) '<)
              (t '>))))))
#+end_src

Add commands to toggle custom sort (much slower).
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-toggle-sort ()
    "Toggle the advanced sort function."
    (interactive)
    (if (not elfeed-search-sort-function)
        (setq elfeed-search-sort-function #'psydev/elfeed-search-entry<
              elfeed-sort-order 'ascending)
      (setq elfeed-search-sort-function nil
            elfeed-sort-order 'descending))
    (elfeed-search-update :force)))
#+end_src

*** Appearance

See [[*Elfeed goodies][Elfeed goodies]].

*** Commands
**** Excerpt Display

Add commands to show entry contents in the search buffer directly.
#+begin_src elisp
(after! elfeed
  (defmacro psydev/elfeed-search-at-entry (entry &rest body)
    "Eval BODY with point at ENTRY."
    (declare (indent defun))
    `(when-let* ((n (cl-position ,entry elfeed-search-entries)))
       (elfeed-goto-line (+ elfeed-search--offset n))
       ,@body))

  (defun psydev/elfeed-search-excerpt-toggle-selected (&optional hide-all)
    "Toggle excerpts on selected entries.
With prefix, hide all excerpts."
    (interactive (list current-prefix-arg))
    (if hide-all
        (ov-clear 'type 'excerpt)
      (--each (elfeed-search-selected)
        (psydev/elfeed-search-at-entry it (psydev/elfeed-excerpt-toggle)))))

  (defun psydev/elfeed-excerpt-toggle ()
    (interactive)
    (or (psydev/elfeed-excerpt-hide)
        (psydev/elfeed-excerpt-insert)))

  (defun psydev/elfeed-excerpt-hide ()
    (interactive)
    (when-let ((pos (1+ (line-end-position)))
               (overlay (car (ov-in 'type 'excerpt pos pos))))
      (delete-overlay overlay)
      t))

  (defun psydev/elfeed-wrap-string (string length)
    "Wrap STRING to LENGTH."
    (if (<= (length string) length)
        string
      (s-trim (with-temp-buffer
                (insert string)
                (let ((fill-column length))
                  (fill-region (point-min) (point-max))
                  (buffer-string))))))

  (defun psydev/elfeed-excerpt-insert ()
    "Show excerpt of current entry."
    (interactive)
    (when-let* ((pos (1+ (line-end-position)))
                (width (window-text-width))
                (entry (elfeed-search-selected 'ignore-region))
                (ref (elfeed-entry-content entry))
                (content (elfeed-deref ref))
                (excerpt (--> content
                              (with-temp-buffer
                                (elfeed-insert-html it)
                                (buffer-string))
                              (psydev/elfeed-wrap-string it width)
                              (concat it "\n")
                              (propertize it 'face '(:inherit (variable-pitch default))))))
      (ov pos pos
          'type 'excerpt
          'after-string (concat "\n" excerpt "\n"))
      (elfeed-untag entry 'unread)
      (elfeed-search-update-entry entry))))
#+end_src

**** Quick tag toggles

Add commands to mark all items as read/unread (avoid having to select all entries).
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-search-mark-all-read ()
    "Mark all entries as read in the current buffer."
    (interactive)
    (when (y-or-n-p "Really mark all items as read?")
      (let* ((entries (--filter (not (member 'starred (elfeed-entry-tags it)))
                                elfeed-search-entries)))
        (elfeed-untag entries 'unread)
        (elfeed-search-update :force))))

  (defun psydev/elfeed-search-mark-all-unread ()
    "Mark all entries as unread in the current buffer."
    (interactive)
    (when (y-or-n-p "Really mark all items as unread?")
      (let* ((entries (--filter (not (member 'starred (elfeed-entry-tags it)))
                                elfeed-search-entries)))
        (elfeed-tag entries 'unread)
        (elfeed-search-update :force)))))
#+end_src

Add commands to mark more selective groups of items as read. Thanks, [[https://gist.github.com/alphapapa/80d2dba33fafcb50f558464a3a73af9a][alphapapa!]]
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-search-toggle-tag-group (tag predicate)
    "Mark all entries as read in the group at point, grouped by PREDICATE."
    (let* ((offset (- (line-number-at-pos) elfeed-search--offset))
           (current-entry (nth offset elfeed-search-entries))
           (value (funcall predicate current-entry))
           (starred (member 'starred (elfeed-entry-tags current-entry)))
           (entries (--filter (and (equal value (funcall predicate it))
                                   (equal starred (member 'starred (elfeed-entry-tags it))))
                              elfeed-search-entries)))
      (if (elfeed-tagged-p tag current-entry)
          (elfeed-untag entries tag)
        (elfeed-tag entries tag))
      (mapc #'elfeed-search-update-entry entries)))

  (defun psydev/elfeed-search-toggle-day-site-as-read ()
    "Mark all entries as read in the current site and day at point."
    (interactive)
    (psydev/elfeed-search-toggle-tag-group 'unread (lambda (entry)
                                                     (list (time-to-days (seconds-to-time (elfeed-entry-date entry)))
                                                           (elfeed-entry-feed entry)))))
  (defun psydev/elfeed-search-toggle-site-as-read ()
    "Mark all entries as read in the current site and day at point."
    (interactive)
    (psydev/elfeed-search-toggle-tag-group 'unread (lambda (entry)
                                                     (elfeed-entry-feed entry))))
  (defun psydev/elfeed-search-toggle-day-as-read ()
    "Mark all entries as unread in the day at point."
    (interactive)
    (psydev/elfeed-search-toggle-tag-group 'unread (lambda (entry)
                                                     (time-to-days (seconds-to-time (elfeed-entry-date entry)))))))
#+end_src

Add a command to quickly toggle the =unread= tag.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-search-toggle-unread ()
    "Toggle `unread' tag on selected entries."
    (interactive)
    (elfeed-search-toggle-all 'unread)))
#+end_src

Add a command to quickly toggle the =starred= tag.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-search-toggle-star ()
    "Toggle `starred' tag on selected entries."
    (interactive)
    (elfeed-search-toggle-all 'starred)))
#+end_src

**** Other commands

Add a command to delete entries from the database.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-delete-entries (pred)
    "Delete entries from `elfeed-db-index' and `elfeed-db-entries' that PRED returns non-nil for.
PRED is called with one argument, the entry."
    (let ((size-before (ht-size elfeed-db-entries))
          size-after )
      (cl-loop for key being the hash-keys of elfeed-db-entries
               using (hash-values entry)
               when (funcall pred entry)
               do (progn
                    (avl-tree-delete elfeed-db-index (elfeed-entry-id entry))
                    (ht-remove elfeed-db-entries key)))
      (a-list 'before size-before
              'after (ht-size elfeed-db-entries))))

  (defun psydev/elfeed-search-delete-selected ()
    "Delete selected entries from database."
    ;; TODO This could probably be much more efficient.
    (interactive)
    (when (y-or-n-p "Really delete entries from database?")
      (--each (elfeed-search-selected)
        (psydev/elfeed-delete-entries
         (lambda (entry)
           (eq (elfeed-entry-id entry) (elfeed-entry-id it)))))
      (elfeed-search-update :force))))
#+end_src

Add a command to delete old entries to keep decent performances.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-delete-old-entries (&optional before)
    "Delete elfeed entries older than BEFORE, defaults to 2 weeks."
    (interactive)
    (let* ((before (or before "1 year ago"))
           (before-time (elfeed-time-duration before))
           (old-entries (make-hash-table :test 'equal)))
      (psydev/elfeed-delete-entries
       (lambda (entry)
         (let ((date (elfeed-entry-date entry)))
           (and (< date (- (float-time) before-time))
                (not (member 'unread (elfeed-entry-tags entry)))
                (not (member 'starred (elfeed-entry-tags entry))))))))
    (psydev/elfeed-db-compact)
    (elfeed-dashboard-update-links)))
#+end_src

Add a command to list dead feeds.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-dead-feeds (&optional years)
    "List feeds that haven't posted anything in YEARS."
    (interactive "p")
    (with-current-buffer (get-buffer-create "*Elfeed Dead Feeds*")
      (erase-buffer)
      (--each (+rss-dead-feeds years) (insert it "\n"))
      (pop-to-buffer (current-buffer)))))
#+end_src

*** Hydra

Thanks again, [[https://github.com/alphapapa/unpackaged.el#filter-hydra][alphapapa!]]
#+begin_src elisp
(cl-defmacro unpackaged/elfeed-search-view-hydra-define (name body views)
  "Define a pretty hydra named NAME with BODY and VIEWS.
VIEWS is a plist: in it, each property is a string which becomes
a column header in the hydra, and each value is a list of lists
in this format: (KEY COMPONENT &optional LABEL).

The KEY is a key sequence passed to `kbd', like \"s\" or \"S
TAB\".  The COMPONENT is an Elfeed filter component, which may
begin with \"+\" or \"=\", and in which spaces are automatically
escaped as required by Elfeed.  The LABEL, if present, is a
string displayed next to the KEY; if absent, COMPONENT is
displayed.

In the resulting hydra, when KEY is pressed, the COMPONENT is
toggled in `elfeed-search-filter'.  It is toggled between three
states: normal, inverse, and absent.  For example, the component
\"+tag\" cycles between three states in the filter: \"+tag\",
\"-tag\", and \"\".  The appropriate inverse prefix is used
according to the component's prefix (i.e. for \"=\", the inverse
is \"~\", and for \"\" (a plain regexp), \"!\" is used).

These special components may be used to read choices from the
Elfeed database with completion and toggle them:

  :complete-age   Completes and sets the age token.
  :complete-feed  Completes and toggles a feed token.
  :selected-feed  Toggles the currently selected feed token.
  :complete-tag   Completes and toggles a tag token.
  nil             Sets default filter.

A complete example:

  (unpackaged/elfeed-search-view-hydra-define my/elfeed-search-view-hydra
    (:foreign-keys warn)
    (\"Views\"
     ((\"@\" :complete-age \"Date\")
      (\"d\" nil))
     \"Status\"
     ((\"su\" \"+unread\"))
     \"Feed\"
     ((\"f TAB\" :complete-feed \"Choose\")
      (\"fE\" \"=Planet Emacslife\" \"Planet Emacslife\"))
     \"Tags\"
     ((\"t TAB\" :complete-tag \"Choose\")
      (\"te\" \"+Emacs\"))
     \"\"
     ((\"tn\" \"+news\"))))"
  (declare (indent defun))
  (cl-labels ((escape-spaces (string)
                             ;; Return STRING with spaces escaped with "\s-".  Necessary
                             ;; because Elfeed treats all literal spaces as separating tokens.
                             (replace-regexp-in-string (rx space) "\\s-" string t t)))
    (let* ((completion-fns
            (list (cons :complete-age
                        (lambda ()
                          (interactive)
                          (save-match-data
                            (let* ((date-regexp (rx (group (or bos blank) "@" (1+ digit) (1+ (not blank)))))
                                   (date-tag (when (string-match date-regexp elfeed-search-filter)
                                               (match-string 1 elfeed-search-filter)))
                                   (date-new (read-string "Date: " date-tag)))
                              (elfeed-search-set-filter
                               (if date-tag
                                   (replace-regexp-in-string date-regexp date-new elfeed-search-filter t t)
                                 (concat date-new " " elfeed-search-filter)))))))
                  (cons :complete-feed
                        '(concat "=" (replace-regexp-in-string
                                      (rx space) "\\s-"
                                      (->> (hash-table-values elfeed-db-feeds)
                                           (--map (elfeed-meta it :title))
                                           (remove nil)
                                           (completing-read "Feed: ")
                                           regexp-quote) t t)))
                  (cons :selected-feed
                        '(concat "=" (replace-regexp-in-string
                                      (rx space) "\\s-"
                                      (--> (elfeed-search-selected 'ignore-region)
                                           (elfeed-entry-feed it)
                                           (elfeed-meta it :title)
                                           (regexp-quote it)) t t)))
                  (cons :complete-tag
                        '(concat "+" (completing-read "Tag: " (elfeed-db-get-all-tags))))))
           (body (append '(:title (concat (propertize "Filter: " 'face 'minibuffer-prompt)
                                          (propertize elfeed-search-filter 'face 'elfeed-search-filter-face))
                           :color amaranth :hint t :separator "‚ïê" :quit-key "<escape>")
                         body))
           (heads (cl-loop for (heading views) on views by #'cddr
                           collect heading
                           collect (cl-loop for (key component label) in views
                                            collect
                                            `(,key
                                              ,(cl-typecase component
                                                 ((and function (not null))
                                                  ;; I don't understand why nil matches
                                                  ;; (or lambda function), but it does,
                                                  ;; so we have to account for it.  See
                                                  ;; (info-lookup-symbol 'cl-typep).
                                                  `(funcall-interactively ,component))
                                                 (string
                                                  `(elfeed-search-set-filter
                                                    (unpackaged/elfeed-search-filter-toggle-component
                                                     elfeed-search-filter ,(escape-spaces component))))
                                                 (otherwise
                                                  `(elfeed-search-set-filter
                                                    ,(when component
                                                       `(unpackaged/elfeed-search-filter-toggle-component
                                                         elfeed-search-filter ,component)))))
                                              ,(or label component "Default"))))))
      ;; I am so glad I discovered `cl-sublis'.  I tried several variations of `cl-labels' and
      ;; `cl-macrolet' and `cl-symbol-macrolet', but this is the only way that has worked.
      (setf heads (cl-sublis completion-fns heads))
      `(pretty-hydra-define ,name ,body
         ,heads))))

(cl-defun unpackaged/elfeed-search-filter-toggle-component (string component)
  "Return STRING (which should be `elfeed-search-filter') having toggled COMPONENT.
Tries to intelligently handle components based on their prefix:
+tag, =feed, regexp."
  (save-match-data
    (cl-labels ((toggle (component +prefix -prefix string)
                        (let ((+pat (rx-to-string `(seq (or bos blank)
                                                        (group ,+prefix ,component)
                                                        (or eos blank))))
                              (-pat (rx-to-string `(seq (group (or bos (1+ blank)) ,-prefix ,component)
                                                        (or eos blank)))))
                          ;; TODO: In newer Emacs versions, the `rx' pattern `literal'
                          ;; evaluates at runtime in `pcase' expressions.
                          (pcase string
                            ((pred (string-match +pat)) (rm (concat -prefix component) string))
                            ((pred (string-match -pat)) (rm "" string))
                            (_ (concat string " " +prefix component)))))
                (rm (new string) (replace-match new t t string 1)))
      (pcase component
        ((rx bos "+" (group (1+ anything)))
         (toggle (match-string 1 component) "+" "-" string))
        ((rx bos "=" (group (1+ anything)))
         (toggle (match-string 1 component) "=" "~" string))
        ((pred string-empty-p)
         (replace-regexp-in-string "[^\s]*\s*$" "" string))
        (_ (toggle component "" "!" string))))))
#+end_src

The custom filter hydra.
#+begin_src elisp
(unpackaged/elfeed-search-view-hydra-define
  psydev/elfeed-search-filter-hydra
  (:foreign-keys warn)
  ("Filter"
   (("<tab>" (lambda () (elfeed-search-live-filter)) "Set")
    ;; FIXME: For some obscure reason, using cl-sublis to substitute with a lambda results in a
    ;; stack overflow. The lambda is copied here to avoid the substitution as a workaround.
    ;; ("@" :complete-age "Date")
    ("@" (lambda ()
           (interactive)
           (save-match-data
             (let* ((date-regexp (rx (group (or bos blank) "@" (1+ digit) (1+ (not blank)))))
                    (date-tag (when (string-match date-regexp elfeed-search-filter)
                                (match-string 1 elfeed-search-filter)))
                    (date-new (read-string "Date: " date-tag)))
               (elfeed-search-set-filter
                (if date-tag
                    (replace-regexp-in-string date-regexp date-new elfeed-search-filter t t)
                  (concat date-new " " elfeed-search-filter))))))
     "Date")
    ("d" "" "Delete")
    ("r" nil))
   "Status"
   (("u" "+unread")
    ("m" "+starred"))
   "Feed"
   (("f <tab>" :complete-feed "Choose")
    ("ff" :selected-feed "Selected"))
   "Tags"
   (("t <tab>" :complete-tag "Choose")
    ("tn" "+news")
    ("tl" "+list")
    ("tf" "+fun"))))
#+end_src

*** Hooks

Mark entries older than 2 weeks as read.
#+begin_src elisp
(after! elfeed
  (defvar psydev/elfeed-outdated-tagger
    (elfeed-make-tagger :before "2 weeks ago"
                        :remove 'unread))

  (defvar psydev/elfeed-odysee-marker
    (elfeed-make-tagger :feed-url "lbryfeed\\.melroy\\.org"
                        :callback (lambda (entry) (setf (elfeed-meta (elfeed-entry-feed entry) :source) "odysee"))))
  (defvar psydev/elfeed-bitchute-marker
    (elfeed-make-tagger :feed-url "bitchute\\.com"
                        :callback (lambda (entry) (setf (elfeed-meta (elfeed-entry-feed entry) :source) "bitchute"))))
  (defvar psydev/elfeed-youtube-marker
    (elfeed-make-tagger :feed-url "youtube\\.com"
                        :callback (lambda (entry) (setf (elfeed-meta (elfeed-entry-feed entry) :source) "youtube"))))
  (defvar psydev/elfeed-twitter-marker
    (elfeed-make-tagger :feed-url "bridge=Twitter"
                        :callback (lambda (entry) (setf (elfeed-meta (elfeed-entry-feed entry) :source) "twitter"))))
  (defvar psydev/elfeed-reddit-marker
    (elfeed-make-tagger :feed-url "reddit\\.com"
                        :callback (lambda (entry) (setf (elfeed-meta (elfeed-entry-feed entry) :source) "reddit"))))
  (defvar psydev/elfeed-github-marker
    (elfeed-make-tagger :feed-url "github\\.com"
                        :callback (lambda (entry) (setf (elfeed-meta (elfeed-entry-feed entry) :source) "github"))))

  ;; Mark entries older than 2 weeks as read.
  (add-hook! 'elfeed-new-entry-hook
    (defun psydev/elfeed-mark-outdated-as-read (entry)
      (when (not (elfeed-tagged-p 'starred entry))
        (funcall psydev/elfeed-outdated-tagger entry))))

  ;; Mark all video entries with an icon tag.
  (add-hook! 'elfeed-new-entry-hook
    (defun psydev/elfeed-mark-entry-source (entry)
      (cond
       ((funcall psydev/elfeed-odysee-marker entry))
       ((funcall psydev/elfeed-bitchute-marker entry))
       ((funcall psydev/elfeed-youtube-marker entry))
       ((funcall psydev/elfeed-twitter-marker entry))
       ((funcall psydev/elfeed-reddit-marker entry))
       ((funcall psydev/elfeed-github-marker entry))))))
#+end_src

*** Bindings

Configure bindings.
#+begin_src elisp
(map! :after elfeed-org
      :map elfeed-search-mode-map
      :n  "C-j"        #'psydev/elfeed-forward-day
      :n  "C-k"        #'psydev/elfeed-backward-day
      :n  "<S-return>" #'psydev/elfeed-search-excerpt-toggle-selected
      :n  "R"          #'elfeed-search-fetch
      :n  "H"          #'elfeed-apply-hooks-now
      :n  "J"          #'elfeed-apply-autotags-now
      :n  "t"          #'elfeed-search-set-entry-title
      :n  "T"          #'elfeed-search-set-feed-title
      :n  "="          #'elfeed-search-toggle-all
      :n  "s"          #'psydev/elfeed-toggle-sort
      :n  "f"          #'elfeed-search-live-filter
      :n  "F"          #'elfeed-search-clear-filter
      :n  "M-f"        #'psydev/elfeed-search-filter-hydra/body
      :nv "m"          #'psydev/elfeed-search-toggle-star
      :nv "u"          #'psydev/elfeed-search-toggle-unread
      :n  "i"          #'psydev/elfeed-search-toggle-day-site-as-read
      :n  "I"          #'psydev/elfeed-search-toggle-site-as-read
      :n  "o"          #'psydev/elfeed-search-toggle-day-as-read
      :n  "a"          #'psydev/elfeed-search-mark-all-read
      :n  "A"          #'psydev/elfeed-search-mark-all-unread
      :nv "d"          #'psydev/elfeed-search-delete-selected
      :n  "L"          #'elfeed-goodies/toggle-logs
      :n  "q"          #'elfeed-search-quit-window
      :n  "Q"          #'elfeed-kill-buffer

      :map elfeed-show-mode-map
      :n "<M-return>" #'elfeed-show-visit
      :n "C-j"        #'evil-forward-paragraph
      :n "C-k"        #'evil-backward-paragraph)
#+end_src

** Elfeed dashboard

Disable evil-snipe.
#+begin_src elisp
(after! evil-snipe
  (add-to-list 'evil-snipe-disabled-modes 'elfeed-dashboard-mode))
#+end_src

Configure dashboard.
#+begin_src elisp
(use-package! elfeed-dashboard
  :config
  (setq elfeed-dashboard-file (concat org-directory "elfeed/dashboard.org")
        +rss-workspace-name "elfeed")
  ;; Update feed counts on elfeed-quit
  ;; FIXME: Too slow, fallback to manual update
  ;; (advice-add 'elfeed-search-quit-window :after #'elfeed-dashboard-update-links)
  )
#+end_src

Add hooks to improve the usability and readability of the dashboard.
#+begin_src elisp
(after! elfeed-dashboard
  ;; Remove ineffective code called on dashboard open, use hook instead.
  ;; Also create a dedicated perspective for elfeed.
  (defun psydev/elfeed-dashboard ()
    "Open the elfeed dasboard."
    (interactive)
    (progn
      (+workspace-switch +rss-workspace-name t)
      (doom/switch-to-scratch-buffer)
      (setq elfeed-dashboard--buf (find-file elfeed-dashboard-file))
      (with-current-buffer elfeed-dashboard--buf
        (elfeed-dashboard-mode))
      (+workspace/display)))
  (advice-add #'elfeed-dashboard :override #'psydev/elfeed-dashboard)

  ;; Cleanup elfeed on dashboard exit.
  (add-hook! elfeed-dashboard-mode
    (add-hook 'kill-buffer-hook #'+rss-cleanup-h nil 'local))

  ;; Really update links when opening the dashboard.
  (add-hook! elfeed-dashboard-mode
    (defun psydev/elfeed-dashboard-setup ()
      ;; FIXME: If dashboard is restored on startup, elfeed-dashboard--buf is nil (link refresh fails).
      (setq elfeed-dashboard--buf (current-buffer))
      ;; FIXME: Too slow, fallback to manual update
      ;; (elfeed-dashboard-update-links)
      ))

  ;; Move point to the first selectable shortcut.
  (add-hook! elfeed-dashboard-mode
    (defun psydev/elfeed-dashboard-top ()
      (goto-line 3)))

  ;; Disable evil-org-mode for now, I could not find a way to make elfeed-dashboard-mode-map
  ;; override the evil-org-mode-map bindings, even using emulation-mode-map-alists.
  (add-hook! elfeed-dashboard-mode
    (defun psydev/elfeed-dashboard-override-keymap ()
      ;; FIXME: If dashboard is restored on startup, elfeed-dashboard--buf is nil (link refresh fails).
      (setq elfeed-dashboard--buf (find-file elfeed-dashboard-file))
      ;; (elfeed-dashboard-update-links)

      (evil-org-mode 0)))

  ;; Take advantage of org-mode capabilities to improve prettiness.
  (add-hook! elfeed-dashboard-mode
    (defun psydev/elfeed-dashboard-prettify ()
      (let ((org-image-actual-width 188))
        (org-toggle-inline-images 'include-linked))
      (psydev/elfeed-dashboard-emphasis)
      (+org-pretty-mode 1)))

  ;; Remove emphasis that can appear in feed titles.
  (defun psydev/elfeed-dashboard-emphasis ()
    (setq-local org-emphasis-alist
                '(("*" bold)
                  ("_" underline)
                  ("=" org-verbatim verbatim)
                  ("~" org-code verbatim))))

  ;; Toggle additional customization on edit.
  (defun psydev/elfeed-dashboard-edit ()
    "Edit dashboard."
    (interactive)
    (+org-pretty-mode 0)
    (org-toggle-inline-images)
    (evil-org-mode 1)
    (setq buffer-read-only nil)
    (org-mode)
    (psydev/elfeed-dashboard-emphasis))
  (advice-add #'elfeed-dashboard-edit :override #'psydev/elfeed-dashboard-edit))
#+end_src

Add custom command to open elfeed or the dashboard entry at point.
#+begin_src elisp
(after! elfeed-dashboard
  (defun psydev/elfeed-dashboard-open (&optional arg)
    "Open the first elfeed link on the current line, or open elfeed if none are found.

With a numeric prefix, opens the nth elfeed link on the current line."
    (interactive "p") ;; FIXME Why is this not working?
    (let ((nlink (or arg (prefix-numeric-value current-prefix-arg))))
      (save-excursion
        (org-beginning-of-line)
        (if (re-search-forward org-link-any-re (line-end-position) t nlink)
            (progn (forward-char -1) (org-open-at-point))
          (elfeed))))))
#+end_src

Generalize status updates while elfeed is updating.
#+begin_src elisp
(after! elfeed-dashboard
  (defun psydev/elfeed-dashboard-update ()
    "Fetch new feeds, if there are no updates already in progress."
    (interactive)
    (unless elfeed-dashboard--elfeed-update-timer
      (elfeed-update)))
  (advice-add #'elfeed-dashboard-update :override #'psydev/elfeed-dashboard-update)

  (add-hook! 'elfeed-update-init-hooks
    (defun psydev/elfeed-update-info ()
      "Display status information while elfeed fetches feeds."
      (unless elfeed-dashboard--elfeed-update-timer
        (setq elfeed-dashboard--elfeed-update-timer
              (run-with-timer 1 1 (lambda ()
                                    (if (> (elfeed-queue-count-total) 0)
                                        (message "elfeed: %d jobs pending..." (elfeed-queue-count-total))
                                      (cancel-timer elfeed-dashboard--elfeed-update-timer)
                                      (setq elfeed-dashboard--elfeed-update-timer nil)
                                      (elfeed-dashboard-update-links)
                                      (message "elfeed: Updated!")))))))))
#+end_src

Patch keymap function to support evil-mode and key combinations.
#+begin_src elisp
(after! elfeed-dashboard
  (defun psydev/elfeed-dashboard-parse-keymap ()
    "Install key binding defined as KEYMAP:VALUE.

VALUE is composed of \"keybinding | function-call\" with
keybidning begin a string describing a key sequence and a call to
an existing function. For example, to have 'q' to kill the
current buffer, the syntax would be:

,#+KEYMAP: q | kill-current-buffer

This can be placed anywhere in the org file even though I advise
to group keymaps at the same place."

    (org-element-map (org-element-parse-buffer) 'keyword
      (lambda (keyword)
        (when (string= (org-element-property :key keyword) "KEYMAP")
          (let* ((value (org-element-property :value keyword))
                 (key   (string-trim (nth 0 (split-string value "|"))))
                 (call  (string-trim (nth 1 (split-string value "|")))))
            (evil-define-key* 'normal elfeed-dashboard-mode-map (kbd key)
              (eval (car (read-from-string
                          (format "(lambda () (interactive) (%s))" call))))))))))
  (advice-add #'elfeed-dashboard-parse-keymap :override #'psydev/elfeed-dashboard-parse-keymap))
#+end_src

Add top level binding.
#+begin_src elisp
(map! :after elfeed-dashboard
      :leader
      (:prefix-map ("o" . "open")
       :desc "Elfeed" "n" #'elfeed-dashboard))
#+end_src

** Elfeed goodies

Configure basic settings and setup goodies.
#+begin_src elisp
(use-package! elfeed-goodies
  :after elfeed
  :config
  ;; Disable font-lock-mode in elfeed buffers (prevents faces from being applied)
  (setq font-lock-global-modes '(not elfeed-search-mode))

  ;; Configure the header
  (setq elfeed-goodies/powerline-default-separator 'slant
        elfeed-goodies/feed-source-column-width 42
        elfeed-goodies/tag-column-width 48
        elfeed-goodies/wide-threshold 0.42
        elfeed-goodies/entry-pane-size 0.5) ; Unused, using doom's popup (see popup rule)

  ;; Use a special (hidden) tag for feeds with HTML entry titles.
  (setq elfeed-goodies/html-decode-title-tags '(html))
  ;; Declare the list of hidden tags.
  (defvar psydev/elfeed-hidden-tags '("unread" "starred" "html")
    "Tags that are hidden from elfeed views.")

  ;; Customized version of elfeed-goodies/setup
  (defun psydev/elfeed-goodies/setup ()
    "Setup Elfeed with adaptive header bar and entries."
    (interactive)
    (add-hook 'elfeed-show-mode-hook #'elfeed-goodies/show-mode-setup)
    (add-hook 'elfeed-new-entry-hook #'elfeed-goodies/html-decode-title)
    (when (boundp 'elfeed-new-entry-parse-hook)
      (add-hook 'elfeed-new-entry-parse-hook #'elfeed-goodies/parse-author))
    (setq elfeed-search-header-function #'elfeed-goodies/search-header-draw
          elfeed-search-print-entry-function #'psydev/elfeed-goodies/entry-line-draw
          ;; NOTE Prefer doom's horizontal popup
          ;; elfeed-show-entry-switch #'elfeed-goodies/switch-pane
          ;; elfeed-show-entry-delete #'elfeed-goodies/delete-pane
          elfeed-show-entry-switch #'pop-to-buffer
          elfeed-show-entry-delete #'+rss/delete-pane
          elfeed-show-refresh-function #'elfeed-goodies/show-refresh--plain))
  (advice-add #'elfeed-goodies/setup :override #'psydev/elfeed-goodies/setup)

  (psydev/elfeed-goodies/setup))
#+end_src

*** Faces

Define the color theme for header and entries.
#+begin_src elisp
(after! elfeed-goodies
  ;; TODO Tricky to implement, try again if really needed
  (defface psydev/elfeed-search-shown-face '((t (:background "gray23")))
    "Face used in search mode for the entry shown in elfeed-show-mode."
    :group 'elfeed)

  ;; Configure powerline theme and elfeed faces.
  (custom-set-faces!
    '(powerline-inactive0 :background "gray23")
    '(powerline-inactive1 :background "gray37")
    '(powerline-inactive2 :background "wheat2")
    '(powerline-active0 :background "gray23" :foreground "wheat1")
    '(powerline-active1 :background "gray37" :foreground "wheat1")
    '(powerline-active2 :background "wheat2" :foreground "grey23")
    '(elfeed-search-filter-face :foreground "#b294bb")
    '(elfeed-search-unread-count-face :foreground "wheat1")
    '(elfeed-search-last-update-face :foreground "grey23")
    '(elfeed-search-date-face :foreground "wheat2")
    '(elfeed-search-feed-face :foreground "skyblue2")
    '(elfeed-search-tag-face :foreground "#f0c674")
    '(elfeed-search-title-face :foreground "wheat2")
    '(elfeed-search-unread-title-face :foreground unspecified :weight bold)))
#+end_src

*** Search Header

Patch the header drawing function for ~elfeed-search-mode~.
#+begin_src elisp
(after! elfeed-goodies
  ;; NOTE Updated attribution of powerline fonts
  ;; NOTE Added face properties for filter, (unread-count and last-update
  (defun psydev/elfeed-goodies/search-header/rhs (separator-left separator-right search-filter stats update)
    (list
     (funcall separator-right 'mode-line 'powerline-active0)
     (powerline-raw
      (propertize (concat " ÔÄÇ " search-filter (when (string-empty-p search-filter) "no filter"))
                  'face 'elfeed-search-filter-face)
      'powerline-active0 'r)
     (funcall separator-right 'powerline-active0 'powerline-active1)
     (cl-destructuring-bind (unread entry-count feed-count) stats
       (let ((content (format " ÔÅ∞ %d/%d:%d " unread entry-count feed-count)))
         (when url-queue
           (cl-destructuring-bind (total-feeds queue-length in-progress) (-elfeed/queue-stats)
             (setf content (concat content (format "(* %.0f%%%%) "
                                                   (* (/ (- total-feeds (+ queue-length
                                                                           in-progress))
                                                         total-feeds 1.0) 100))))))
         (propertize content 'face 'powerline-active1)))
     (funcall separator-right 'powerline-active1 'powerline-active2)
     (powerline-raw
      (propertize (concat " ÔÄó " update) 'face 'elfeed-search-last-update-face)
      'powerline-active2 'r)))

  ;; NOTE Changed Subject -> Title
  ;; NOTE Updated attribution of powerline fonts and removed columns
  (defun psydev/elfeed-goodies/search-header/draw-wide (separator-left separator-right search-filter stats db-time)
    (let* ((update (format-time-string "%Y-%m-%d %H:%M:%S" db-time)) ; NOTE Removed timezone
           (lhs (list
                 (powerline-raw
                  (-pad-string-to "ÔÇû Feed" (- elfeed-goodies/feed-source-column-width 6))
                  'powerline-active2 'l)
                 (funcall separator-left 'powerline-active2 'mode-line)
                 (powerline-raw
                  (propertize "ÔÄ∂ Title" 'face 'elfeed-search-title-face)
                  'mode-line 'l)))
           (rhs (search-header/rhs separator-left separator-right search-filter stats update)))
      (concat (powerline-render lhs)
              (powerline-fill 'mode-line (powerline-width rhs))
              (powerline-render rhs))))

  ;; NOTE Changed Subject -> Title
  (defun psydev/elfeed-goodies/search-header/draw-tight (separator-left separator-right search-filter stats db-time)
    (let* ((update (format-time-string "%H:%M:%S" db-time))
           (lhs (list
                 (powerline-raw "ÔÄ∂ Title" 'mode-line 'l)))
           (rhs (search-header/rhs separator-left separator-right search-filter stats update)))
      (concat (powerline-render lhs)
              (powerline-fill 'mode-line (powerline-width rhs))
              (powerline-render rhs))))

  (advice-add #'search-header/rhs :override #'psydev/elfeed-goodies/search-header/rhs)
  (advice-add #'search-header/draw-wide :override #'psydev/elfeed-goodies/search-header/draw-wide)
  (advice-add #'search-header/draw-tight :override #'psydev/elfeed-goodies/search-header/draw-tight))
#+end_src

Patch the header drawing function for ~elfeed-show-mode~.
#+begin_src elisp
(after! elfeed-goodies
  (defun psydev/elfeed-goodies/entry-header-line ()
    "Print the header line for elfeed-show-mode."
    (cl-flet ((tags (entry)
                    (seq-difference (--map (substring-no-properties (symbol-name it))
                                           (elfeed-entry-tags entry))
                                    psydev/elfeed-hidden-tags)))
      (let* (;; (entry-face 'elfeed-search-feed-face)
             ;; (entry-face (psydev/elfeed-search--entry-face elfeed-show-entry))
             (title-faces (elfeed-search--faces (elfeed-entry-tags elfeed-show-entry)))

             (tags (mapconcat
                    (lambda (t) (propertize t 'face 'elfeed-search-tag-face))
                    (tags elfeed-show-entry) ","))
             ;; (tags (mapconcat #'symbol-name (tags elfeed-show-entry) ","))
             (feed (elfeed-entry-feed elfeed-show-entry))
             (entry-author (elfeed-meta elfeed-show-entry :author))
             (feed-title (when feed (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
             (feed-title (if entry-author
                             (concat entry-author " (" feed-title ")")
                           feed-title))
             (date (format-time-string "%Y-%m-%d %H:%M:%S "
                                       (seconds-to-time (elfeed-entry-date elfeed-show-entry))))

             (title (elfeed-entry-title elfeed-show-entry))
             (title-width (- (window-width) (length tags) (length feed-title) (length date) 10))
             (title (truncate-string-to-width title title-width nil nil 'ellipsis))

             (separator-left (intern (format "powerline-%s-%s"
                                             elfeed-goodies/powerline-default-separator
                                             (car powerline-default-separator-dir))))
             (separator-right (intern (format "powerline-%s-%s"
                                              elfeed-goodies/powerline-default-separator
                                              (cdr powerline-default-separator-dir))))
             (lhs (list
                   (powerline-raw (concat " ÔÇû " feed-title ) 'powerline-active2 'r)
                   (funcall separator-left 'powerline-active2 'powerline-active1)
                   (powerline-raw (propertize (concat "ÔÄ∂ " title " ") 'face title-faces) 'powerline-active1 'l)
                   (funcall separator-left 'powerline-active1 'mode-line)))
             (rhs (list
                   (funcall separator-right 'mode-line 'powerline-active1)
                   (powerline-raw (concat " ÔÄ´ " tags " ") 'powerline-active1)
                   (funcall separator-right 'powerline-active1 'powerline-active2)
                   (powerline-raw (concat "ÔÄó " date) 'powerline-active2 'l))))
        (concat
         (powerline-render lhs)
         (powerline-fill 'mode-line (powerline-width rhs))
         (powerline-render rhs)))))
  (advice-add #'elfeed-goodies/entry-header-line :override #'psydev/elfeed-goodies/entry-header-line))
#+end_src

*** Search Entries

Add a function to define how the face is selected for each entry.
#+begin_src elisp
(after! elfeed-goodies
  (defun psydev/elfeed-search--entry-face (entry)
    "Return face for ENTRY."
    (let ((rainbow-identifiers-cie-l*a*b*-color-count 256)
          (rainbow-identifiers-cie-l*a*b*-lightness 60)
          (rainbow-identifiers-cie-l*a*b*-saturation 27))
      (or (--> entry
               (elfeed-entry-feed it)
               (elfeed-feed-meta it)
               (-let (((&plist :background background :foreground foreground) it)
                      (face nil))
                 (when (or background foreground)
                   (when background
                     (setq face (plist-put face :background background)))
                   (when foreground
                     (setq face (plist-put face :foreground foreground)))
                   face)))
          (->> entry
               elfeed-entry-feed
               elfeed-feed-url
               rainbow-identifiers--hash-function
               rainbow-identifiers-cie-l*a*b*-choose-face)))))
#+end_src

Add functions to define how icons are selected for each entry.
#+begin_src elisp
(after! elfeed-goodies
  (defun psydev/elfeed-search--entry-status (entry)
    "Return the status character for ENTRY."
    (let* ((unread-p (member 'unread (elfeed-entry-tags entry)))
           (starred-p (member 'starred (elfeed-entry-tags entry))))
      (cond ((and unread-p starred-p) "ÔÄÖ") ; ÔÄÆ ÔÇó
            (starred-p "ÔÄÜ") ; ‚òÖ
            (unread-p "‚Ä¢")
            (t " "))))

  (defun psydev/elfeed-search--entry-icon (entry)
    "Return the feed icon for ENTRY."
    (let* ((feed (elfeed-entry-feed entry))
           (feed-source (elfeed-meta feed :source)))
      (pcase feed-source
        ("odysee"   (all-the-icons-faicon "renren"         :height 1.0  :v-adjust 0)) ; "ÔÜã"
        ("bitchute" (all-the-icons-faicon "circle-o-notch" :height 0.85 :v-adjust 0)) ; "Ôáé"
        ("youtube"  (all-the-icons-faicon "youtube-play"   :height 0.9  :v-adjust 0)) ; "ÔÖ™"
        ("twitter"  (all-the-icons-faicon "twitter"        :height 1.0  :v-adjust 0)) ; "ÔÇô"
        ("reddit"   (all-the-icons-faicon "reddit-alien"   :height 1.0  :v-adjust 0)) ; "ÔäÅ"
        ("github"   (all-the-icons-faicon "github"         :height 1.0  :v-adjust 0)) ; "ÔÇõ"
        (_ "  ")))))
#+end_src

Custom entry-draw function, mainly thanks to [[https://gist.github.com/alphapapa/80d2dba33fafcb50f558464a3a73af9a][alphapapa]].
#+begin_src elisp
(after! elfeed-goodies
  (defun psydev/elfeed-goodies/entry-line-draw (entry)
    "Print ENTRY to the buffer."
    (cl-flet ((add-faces (str &rest faces)
                         (dolist (face faces str)
                           (add-face-text-property 0 (length str)
                                                   face 'append str)))
              (tags (entry)
                    (seq-difference (--map (substring-no-properties (symbol-name it))
                                           (elfeed-entry-tags entry))
                                    psydev/elfeed-hidden-tags)))
      (let* (;; Choose color and faces first
             ;; See https://www.reddit.com/r/emacs/comments/7a976a/face_applied_to_result_of_symbolname_becomes/
             (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
             (entry-face (psydev/elfeed-search--entry-face entry))
             (entry-status (psydev/elfeed-search--entry-status entry))
             (entry-icon (psydev/elfeed-search--entry-icon entry))

             ;; Feed
             (feed (elfeed-entry-feed entry))
             (feed-title (when feed (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
             (feed-width elfeed-goodies/feed-source-column-width)
             (feed-column (elfeed-format-column feed-title (- feed-width 4) :left))
             (feed-column (apply #'add-faces feed-column entry-face title-faces))

             ;; Tags
             (tags (mapconcat
                    (lambda (t) (propertize t 'face 'elfeed-search-tag-face))
                    (tags entry) ","))
             ;; (tags-width elfeed-goodies/tag-column-width)                     ; Fixed alignment
             (tags-width (min (length tags) elfeed-goodies/tag-column-width)) ; Dynamic Alignment
             (tags-column (elfeed-format-column tags tags-width :right))
             (tags-column (apply #'add-faces tags-column title-faces))

             ;; Title
             (title (substring-no-properties (or (elfeed-meta entry :title) (elfeed-entry-title entry) "")))
             (title-width (- (window-width) feed-width tags-width 3))
             (title-column (elfeed-format-column
                            (truncate-string-to-width title title-width nil nil 'ellipsis)
                            title-width :left))
             (title-column (apply #'add-faces title-column title-faces))

             (line (propertize
                    (concat entry-status " "
                            (if (>= (window-width) (* (frame-width) elfeed-goodies/wide-threshold))
                                (concat feed-column " " entry-icon " " title-column " " tags-column)
                              (apply #'add-faces title entry-face title-faces)))
                    'kbd-help title)))
        (insert line))))

  (advice-add #'elfeed-goodies/entry-line-draw :override #'psydev/elfeed-goodies/entry-line-draw))
#+end_src

Replace "End of entries." string by empty-list placeholder.
#+begin_src elisp
(after! elfeed
  (defun elfeed-search-update (&optional force)
    "Update the elfeed-search buffer listing to match the database.
When FORCE is non-nil, redraw even when the database hasn't changed."
    (interactive)
    (with-current-buffer (elfeed-search-buffer)
      (when (or force (and (not elfeed-search-filter-active)
                           (< elfeed-search-last-update (elfeed-db-last-update))))
        (elfeed-save-excursion
          (let ((inhibit-read-only t)
                (standard-output (current-buffer)))
            (erase-buffer)
            (elfeed-search--update-list)
            (dolist (entry elfeed-search-entries)
              (funcall elfeed-search-print-entry-function entry)
              (insert "\n"))
            (when (not elfeed-search-entries) (insert "No entries.\n")) ; NOTE Changed to placeholder
            (setf elfeed-search-last-update (float-time))))
        (run-hooks 'elfeed-search-update-hook)))))
#+end_src

Remove string sort on tags to keep original order by tag-inheritance from org file.
#+begin_src elisp
(after! elfeed
  (defun psydev/elfeed-normalize-tags (tags &rest more-tags)
    "Return the normalized tag list for TAGS."
    (let ((all (apply #'append tags (nconc more-tags (list ())))))
      (cl-delete-duplicates all)))
  (advice-add #'elfeed-normalize-tags :override #'psydev/elfeed-normalize-tags))
#+end_src

*** Bindings

Add goodies-specific bindings.
#+begin_src elisp
(map! :after elfeed-goodies
      :map elfeed-show-mode-map
      :n "C-S-j" #'elfeed-goodies/split-show-next
      :n "C-S-k" #'elfeed-goodies/split-show-prev
      :n "n" #'elfeed-goodies/split-show-next
      :n "p" #'elfeed-goodies/split-show-prev)
#+end_src

** Evil
*** Settings

Customize general evil options.
#+begin_src elisp
(setq evil-want-fine-undo t          ; By default while in insert all changes are one big blob. Be more granular
      evil-move-cursor-back nil      ; Leave cursor in place when exiting insert-mode
      evil-cross-lines nil           ; Allow horizontal ops to move to the next line (or not)
      evil-kill-on-visual-paste nil) ; Do not kill replaced text in visual mode
#+end_src

Enable evil-mode in the minibuffer. Or not.
#+begin_src elisp
;; (use-package! evil-collection
;;   :custom (evil-collection-setup-minibuffer t))
#+end_src

Add a delete operator that does not add to kill-ring.
#+begin_src elisp
(after! evil
  (evil-define-operator evil-black-hole-delete (beg end type)
    (interactive "<R>")
    (evil-delete beg end type ?_)))
#+end_src

*** Extensions

Customize options for evil extensions.
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src

Fix incompatibility between evil-mc and evil-move-cursor-back.
TODO: Contribute this.
#+begin_src elisp
(after! evil-mc
  (defun evil-mc-execute-evil-change ()
    "Execute an `evil-change' command."
    (let ((point (point)))
      (evil-with-state normal
        (unless (or (not evil-move-cursor-back) ; NOTE: EDIT
                    (and region (< (evil-mc-get-region-mark region)
                                   (evil-mc-get-region-point region)))
                    (eq point (point-at-bol)))
          (evil-forward-char 1 nil t))
        (evil-mc-execute-with-region-or-macro 'evil-change)
        (evil-maybe-remove-spaces nil)))))
#+end_src

*** Hydra

Replace evil-mc bindings by a convenient hydra.
#+begin_src elisp
(after! pretty-hydra
  (defhydra evil-mc-hydra
    (:color pink
     :hint nil
     :pre (evil-mc-pause-cursors)
     :post (evil-mc-resume-cursors))
    "

                       ü§Ø Multiple Cursors

 ^Match^            ^Line-wise^                 ^Manual^
‚ïê^‚ïê^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^‚ïê^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^‚ïê^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 _a_: match all     _J_: make & go down         _z_: toggle here
 _m_: make & next   _K_: make & go up           _r_: remove last/region
 _M_: make & prev   _I_: make in region (beg)   _R_: remove all
 _n_: skip & next   _A_: make in region (end)   _p_: pause/resume
 _N_: skip & prev

Current pattern: %`evil-mc-pattern
"
    ("a" #'evil-mc-make-all-cursors)
    ("m" #'evil-mc-make-and-goto-next-match)
    ("M" #'evil-mc-make-and-goto-prev-match)
    ("n" #'evil-mc-skip-and-goto-next-match)
    ("N" #'evil-mc-skip-and-goto-prev-match)
    ("J" #'evil-mc-make-cursor-move-next-line)
    ("K" #'evil-mc-make-cursor-move-prev-line)
    ("I" #'evil-mc-make-cursor-in-visual-selection-beg :color blue)
    ("A" #'evil-mc-make-cursor-in-visual-selection-end :color blue)
    ("z" #'+multiple-cursors/evil-mc-toggle-cursor-here)
    ("r" #'+multiple-cursors/evil-mc-undo-cursor)
    ("R" #'evil-mc-undo-all-cursors)
    ("p" #'+multiple-cursors/evil-mc-toggle-cursors)
    ("q" nil :color blue)
    ("<escape>" nil :color blue)))
#+end_src

*** Bindings

Provide more consistent navigation bindings and add missing evil bindings.
Add the missing arrow-key variants of the window navigation commands.
#+begin_src elisp
(map!
 ;; Bind missing evil bindings
 :m "<backspace>"     #'evil-black-hole-delete
 :nv "gX"             #'evil-exchange-cancel
 :nv "god"            #'evil-quick-diff
 :nv "goD"            #'evil-quick-diff-cancel
 :textobj "b"         #'evil-textobj-anyblock-inner-block #'evil-textobj-anyblock-a-block
 ;; Customize RET behavior for normal/insert modes
 :i "<return>"        #'+default/newline
 :i "S-<return>"      #'newline-and-indent ;; NOTE: Difference with default-indent-new-line is not clear
 :n "S-<return>"      #'newline-and-indent
 ;; Rebind fold commands
 :m "TAB"             #'+fold/toggle
 :m "<tab>"           #'+fold/toggle
 :m "<backtab>"       #'+fold/close-all
 :m "C-<iso-lefttab>" #'+fold/open-all
 ;; Rebind macro command, q is for quitting.
 :n "q"               nil
 :n "zq"              #'evil-record-macro
 ;; Use M-/ to toggle comments (M-; for comment-dwim), rebind dabbrev-expand
 :nv "M-/"            #'evilnc-comment-or-uncomment-lines
 :g  "C-/"            #'dabbrev-expand
 ;; Rebind evil-lion to ga (align) to avoids gl conflicts with org-mode
 :nv "ga"             #'evil-lion-left
 :nv "gA"             #'evil-lion-right
 :nv "gl"             nil
 :nv "gL"             nil
 ;; Rearrange some yank/paste commands
 :n "M-p"             #'evil-paste-pop
 :n "C-p"             #'+default/yank-pop
 (:map evil-mc-key-map
  :nv "C-p" nil
  :nv "C-n" nil)
 ;; Rebind multiple-cursors hydra
 (:when (featurep! :editor multiple-cursors)
  :nv "M-z"             #'evil-mc-hydra/body)
 ;; Use more consistent bindings for workspaces/window navigation
 :m "] TAB"           #'+workspace/switch-right
 :m "[ TAB"           #'+workspace/switch-left
 :m "]w"              #'evil-window-next
 :m "[w"              #'evil-window-prev
 ;; Bind more motion/editing commands to hjkl
 :i "C-k"             #'evil-previous-line
 :i "C-j"             #'evil-next-line
 :i "C-h"             #'left-char
 :i "C-l"             #'right-char
 :m "C-k"             #'evil-backward-paragraph
 :m "C-j"             #'evil-forward-paragraph
 :m "C-h"             #'evil-backward-word-begin
 :m "C-l"             #'evil-forward-word-begin
 :i "C-S-k"           #'evil-backward-paragraph
 :i "C-S-j"           #'evil-forward-paragraph
 :i "C-S-h"           #'evil-backward-word-begin
 :i "C-S-l"           #'evil-forward-word-begin
 :m "C-S-k"           #'evil-backward-section-end
 :m "C-S-j"           #'evil-forward-section-end
 :m "C-S-h"           #'evil-backward-WORD-begin
 :m "C-S-l"           #'evil-forward-WORD-end
 :g "M-k"             #'drag-stuff-up
 :g "M-j"             #'drag-stuff-down
 :g "M-h"             #'evil-shift-left
 :g "M-l"             #'evil-shift-right
 :g "M-K"             #'drag-stuff-up
 :g "M-J"             #'drag-stuff-down
 :g "M-H"             #'drag-stuff-left
 :g "M-L"             #'drag-stuff-right)
#+end_src

** Evil goggles

Customize evil-goggles visual hints.
#+begin_src elisp
(use-package! evil-goggles
  :config
  (custom-set-faces!
    '(evil-goggles-paste-face  :inherit custom-state)
    '(evil-goggles-indent-face :inherit custom-modified)
    '(evil-goggles-change-face :inherit custom-invalid)
    '(evil-goggles-delete-face :inherit custom-invalid))
  (setq evil-goggles-enable-delete t
        evil-goggles-enable-change t)

  ;; Add custom delete command to the list of commands
  (pushnew! evil-goggles--commands
            '(evil-black-hole-delete
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)))
#+end_src

** Evil visual mark

Customize, disabled by default for now as I often mistype and set marks unwillingly. Enable as needed.
#+begin_src elisp
(use-package! evil-visual-mark-mode
  :config
  (custom-set-faces!
    '(evil-visual-mark-face :weight bold :foreground "#0d0d0d" :background "#de935f"))
  ;; (evil-visual-mark-mode)
)
#+end_src

** Evil terminal cursor

#+begin_src elisp
(add-hook! 'tty-setup-hook #'evil-terminal-cursor-changer-activate)
;; Restore my default terminal cursor.
(add-hook! 'delete-terminal-functions
  (defun +doom-restore-terminal-cursor (terminal)
    (unless (display-graphic-p terminal)
      (etcc--apply-to-terminal (etcc--make-cursor-shape-seq 'bar)))))
#+end_src

** Fasd

#+begin_src elisp
(use-package! fasd
  :config
  (map! :leader
        :desc "Find frecent file" ">" #'fasd-find-file)
  (global-fasd-mode))
#+end_src

** Fast scroll

#+begin_src elisp
(use-package! fast-scroll
  :config
  (setq fast-scroll-throttle 0.1)
  ;; Add scroll-up/down commands for mouse wheel.
  (defun fast-scroll-advice-scroll-functions ()
    "Wrap as many scrolling functions that we know of in this advice."
    (interactive)
    (advice-add #'scroll-up-command :around #'fast-scroll-run-fn-minimally)
    (advice-add #'scroll-down-command :around #'fast-scroll-run-fn-minimally)
    (advice-add #'evil-scroll-up :around #'fast-scroll-run-fn-minimally)
    (advice-add #'evil-scroll-down :around #'fast-scroll-run-fn-minimally)
    (advice-add #'scroll-up :around #'fast-scroll-run-fn-minimally)
    (advice-add #'scroll-down :around #'fast-scroll-run-fn-minimally))
  (defun fast-scroll-unload-function ()
    "Remove advice added by `fast-scroll-advice-scroll-functions'.
Note this function's name implies compatibility with `unload-feature'."
    (interactive)
    (advice-remove #'scroll-up-command #'fast-scroll-run-fn-minimally)
    (advice-remove #'scroll-down-command #'fast-scroll-run-fn-minimally)
    (advice-remove #'evil-scroll-up #'fast-scroll-run-fn-minimally)
    (advice-remove #'evil-scroll-down #'fast-scroll-run-fn-minimally)
    (advice-remove #'scroll-up #'fast-scroll-run-fn-minimally)
    (advice-remove #'scroll-down #'fast-scroll-run-fn-minimally)
    nil)
  ;; Remove modes from default modeline.
  (defun fast-scroll-default-mode-line ()
    "An Emacs default/bare bones mode-line."
    (list "%e" mode-line-front-space
          mode-line-client
          mode-line-modified
          mode-line-frame-identification
          mode-line-buffer-identification "   "
          mode-line-position
          "  " mode-line-misc-info mode-line-end-spaces))
  ;; Bind mouse button to toggle mode.
  (map! :g "<mouse-8>" #'fast-scroll-mode))
#+end_src

** Flyspell

Provide language cycling.
#+begin_src elisp
(defvar-local lang-ring nil
  "The list of available ispell languages.")

(let ((langs '("fr_FR" "en_US")))
  (let ((ring (make-ring (length langs))))
    (dolist (elem langs) (ring-insert ring elem))
    (setq-default lang-ring ring)))

(defun +spell/cycle-languages ()
  "Cycle between ispell languages for the current buffer."
  (interactive)
  (setq-local lang-ring (ring-copy lang-ring))
  (let ((lang (ring-ref lang-ring -1)))
    (ring-insert lang-ring lang)
    (ispell-change-dictionary lang)))

(map! :leader :prefix "n"
      :desc "Cycle ispell languages" "L" #'+spell/cycle-languages)
#+end_src

** Format

Override format-on-save default enabled modes to add emacs-lisp-mode.
#+begin_src elisp
(setq +format-on-save-enabled-modes
      '(not sql-mode         ; sqlformat is currently broken
            tex-mode         ; latexindent is broken
            latex-mode
            elfeed-search-mode
            elfeed-show-mode))
#+end_src

Disable ~shfmt~ formatting for zsh buffers (not supported).
#+begin_src elisp
(add-hook! 'sh-set-shell-hook
  (defun +sh-shell-zsh-no-format ()
    (if (string= sh-shell "zsh")
        (setq +format-with :none)
      (setq +format-with nil))))
#+end_src

Redefine the ~shfmt~ formatter with consistent indent settings.
Also format ~zsh~ regions using bash syntax by default (org-mode code snippets).
#+begin_src elisp
(set-formatter! 'shfmt
  '("shfmt"
    "-s"   ; simplify the code
    "-bn"  ; binary ops like && and | may start a line
    ("-i" "%d" tab-width)
    ("-ln" "%s" (cl-case (and (eql major-mode 'sh-mode)
                              (boundp 'sh-shell)
                              (symbol-value 'sh-shell))
                  (zsh "bash")
                  (bash "bash")
                  (mksh "mksh")
                  (t "posix"))))
  :modes 'sh-mode)
#+end_src

** Hydra major mode

#+begin_src elisp
(use-package! major-mode-hydra
  :after hydra
  :config
  (setq major-mode-hydra-separator "‚ïê"
        major-mode-hydra-title-generator #'+hydra/major-mode-title-generator)

  ;; Title generator for pretty hydras.
  (defun +hydra/title-generator--generic (title &optional icon offset)
    (let ((prefix (when offset (s-repeat offset " ")))
          (icon (when icon (concat icon " "))))
      (s-concat prefix icon title)))

  (defun +hydra/title-generator (title &optional icon offset)
    (+hydra/title-generator--generic
     title
     (all-the-icons-faicon icon :v-adjust 0.05)
     offset))

  (defun +hydra/major-mode-title-generator (mode &optional offset)
    (+hydra/title-generator--generic
     (s-concat (s-capitalized-words (s-chop-suffix "-mode" (symbol-name mode))) " commands")
     (all-the-icons-icon-for-mode mode :v-adjust 0.05)
     offset)))
#+end_src

** Hydra posframe

#+begin_src elisp
(use-package! hydra-posframe
  :after hydra
  :config
  (hydra-posframe-mode)
  (setq hydra-posframe-border-width 1
        hydra-posframe-poshandler #'posframe-poshandler-frame-bottom-center
        hydra-posframe-parameters `((left-fringe . 15)
                                    (right-fringe . 15)))

  (custom-set-faces!
    '(hydra-posframe-face :inherit unspecified)
    '(hydra-posframe-border-face :background "gray30")))
#+end_src

** Info colors

#+begin_src elisp
(use-package! info-colors
  :after info
  :hook (Info-selection . info-colors-fontify-node))
#+end_src

** Ivy

Enable Ivy buffer previews. This only applies to workspace buffer switching,
as it seems that previewing buffers from other workspaces adds them to the
current workspace, which is totally unwanted behavior.
#+begin_src elisp
(setq +ivy-buffer-preview t)
#+end_src

Override doom's ~+ivy-format-function-line-or-arrow~ and use the line highlight,
even in terminal mode.
#+begin_src elisp
(after! ivy
  (setf (alist-get 't ivy-format-functions-alist)
        #'ivy-format-function-line))
#+end_src

Use a cache for ivy-rich transformations on ~switch-buffer~.
See the [[https://github.com/Yevgnen/ivy-rich/issues/87][related issue]].
#+begin_src elisp
(after! ivy-rich
  (defvar ivy-rich--ivy-switch-buffer-cache
    (make-hash-table :test 'equal))

  (define-advice ivy-rich--ivy-switch-buffer-transformer
      (:around (old-fn x) cache)
    (let ((ret (gethash x ivy-rich--ivy-switch-buffer-cache)))
      (unless ret
        (setq ret (funcall old-fn x))
        (puthash x ret ivy-rich--ivy-switch-buffer-cache))
      ret))

  (define-advice +ivy/switch-buffer
      (:before (&rest _) ivy-rich-reset-cache)
    (clrhash ivy-rich--ivy-switch-buffer-cache)))
#+end_src

Customize ivy-posframe.
#+begin_src elisp
(after! ivy-posframe
  (setq ivy-posframe-min-height ivy-height
        ivy-posframe-min-width 90
        ivy-posframe-size-function #'psydev/ivy-posframe-get-size
        ivy-posframe-border-width 8
        ivy-posframe-parameters `((left-fringe . 2)
                                  (right-fringe . 2)))

  ;; posframe doesn't work well with async sources (the posframe will
  ;; occasionally stop responding/redrawing), and causes violent resizing of the
  ;; posframe.
  (dolist (fn '(swiper-isearch))
    (setf (alist-get fn ivy-posframe-display-functions-alist)
          #'ivy-display-function-fallback))

  (defun psydev/ivy-posframe-get-size ()
    "Dynamic, fixed size function used by `ivy-posframe-size-function'."
    (setq ivy-posframe-width (round (* (frame-width) 0.618))) ; NOTE EDIT
    (list
     :height ivy-posframe-height
     :width ivy-posframe-width
     :min-height (or ivy-posframe-min-height
                     (let ((height (+ ivy-height 1)))
                       (min height (or ivy-posframe-height height))))
     :min-width (or ivy-posframe-min-width
                    (let ((width (round (* (frame-width) 0.618))))
                      (min width (or ivy-posframe-width width))))))

  (setf (alist-get t ivy-posframe-display-functions-alist)
        #'+ivy-display-at-frame-center-near-bottom-fn))
#+end_src

Extend the default hydra for ivy.
#+begin_src elisp
(after! ivy-hydra
  (defhydra+ hydra-ivy (:hint nil :color pink)
    "

                                   üîé Ivy

 Move     ^^^^^^^^^^   Call         ^^^^   Cancel^^   Options^^
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^^^^^^^^^^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^^^^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 _g_ ^ ^ _k_ ^ ^ _u_   _f_orward _o_ccur   _i_nsert   _c_alling: %-7s(if ivy-calling \"on\" \"off\")  _C_ase-fold: %-10`ivy-case-fold-search
 ^‚Üï^ _h_ ^+^ _l_ ^ü°ô^   _RET_ done     ^^   _q_uit     _M_atcher: %-7s(ivy--matcher-desc)  _T_runcate: %-11`truncate-lines
 _G_ ^ ^ _j_ ^ ^ _d_   _TAB_ alt-done ^^   ^ ^        _<_/_>_: shrink/grow  _m_ark _t_oggle _U_nmark

Action _w_/_s_/_a_: %s(ivy-action-name)
       _K_ill                                                        _?_: help
"
    ;; Movement
    ("l" ivy-alt-done)
    ("h" ivy-backward-kill-word)
    ;; Restore mark bindings
    ("m" ivy-mark)
    ("U" ivy-unmark)
    ("<deletechar>" ivy-unmark-backward)
    ("t" ivy-toggle-marks)
    ;; Actions
    ("<escape>" nil)
    ("M-o" nil)
    ("K" (ivy-exit-with-action #'ivy--kill-buffer-action))
    ("?" ivy-help)))
#+end_src

Customize bindings.
#+begin_src elisp
(after! ivy
  (map! :map ivy-minibuffer-map
        "C-h" #'ivy-backward-kill-word
        "C-<return>" #'ivy-immediate-done))
#+end_src

** Ligatures

Remove annoying programming ligatures.
#+begin_src elisp
;; (cl-delete-if
;;  (lambda (x)
;;    (member (car x)
;;            '("[]"
;;              "##"
;;              "###"
;;              "####")))
;;  +ligatures-fira-font-alist)
#+end_src

** Lsp

Ignore prompts to restart server to avoid hangs on server-restart.
#+begin_src elisp
(after! lsp-mode
  (setq-default lsp-restart 'auto-restart))
#+end_src

*** Sh

Integrate lsp-mode with Flycheck `sh-shellcheck' checker. It will become
redundant if bash-language-server implements
https://github.com/bash-lsp/bash-language-server/issues/104
#+begin_src elisp
(defun lsp-flycheck-enable-shellcheck ()
  "Enable Shellcheck for shell buffers under LSP."
  (when (derived-mode-p 'sh-mode)
    (flycheck-add-next-checker 'lsp 'sh-shellcheck)))

(add-hook 'lsp-after-open-hook #'lsp-flycheck-enable-shellcheck)
#+end_src

** Magit

Enable gravatars when viewing commits. The service used by default is [[https://www.libravatar.org/][Libravatar]].
#+begin_src elisp
(after! magit
  :config
  (setq git-commit-summary-max-length 72)
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src

Customize bindings.
#+begin_src elisp
(map! :leader :prefix "g"
      "m" nil) ; unbind smerge hydra - use ediff instad.
#+end_src

** Magit delta

#+begin_src elisp
(use-package! magit-delta
  :after magit
  :config
  (setq magit-delta-delta-args
        '("--features" "truecolor"
          "--max-line-distance" "0.6"
          "--24-bit-color" "always"
          "--color-only"))
  (magit-delta-mode))
#+end_src

** Man

Add shortcut to man command.
#+begin_src elisp
(use-package! man
  :config
  (map! :leader :prefix "h"
        "H" #'man))
#+end_src

** Org
*** General Settings

Change the default org directory.
#+begin_src elisp
(setq org-directory "~/Notes/")
#+end_src

Configure region behavior for org commands.
#+begin_src elisp
(after! org
  (setq org-loop-over-headlines-in-active-region 'start-level
        org-agenda-loop-over-headlines-in-active-region 't))
#+end_src

Configure the context shown when revealing an org heading.
#+begin_src elisp
(setq org-show-context-detail
      '((agenda . local)
        (bookmark-jump . lineage)
        (isearch . lineage)
        (default . ancestors)))
#+end_src

*** Document Structure

Configure the behavior of M-RET and friends, and ensure that headings are terminated by blank lines.
#+begin_src elisp
(after! org
  (setq org-insert-heading-respect-content nil
        org-M-RET-may-split-line '((default . t))
        org-blank-before-new-entry
        '((heading . always)
          (plain-list-item . nil))))
#+end_src

Patch doom's org-insert-item variant to better respect blank settings.
#+begin_src elisp
(after! org
  (defun psydev/+org--insert-item (direction)
    (let ((context (org-element-lineage
                    (org-element-context)
                    '(table table-row headline inlinetask item plain-list)
                    t)))
      (pcase (org-element-type context)
        ;; Add a new list item (carrying over checkboxes if necessary)
        ((or `item `plain-list)
         (let ((orig-point (point)))
           ;; Position determines where org-insert-todo-heading and `org-insert-item'
           ;; insert the new list item.
           (if (eq direction 'above)
               (org-beginning-of-item)
             (end-of-line))
           (let* ((ctx-item? (eq 'item (org-element-type context)))
                  (ctx-cb (org-element-property :contents-begin context))
                  ;; Hack to handle edge case where the point is at the
                  ;; beginning of the first item
                  (beginning-of-list? (and (not ctx-item?)
                                           (= ctx-cb orig-point)))
                  (item-context (if beginning-of-list?
                                    (org-element-context)
                                  context))
                  ;; Horrible hack to handle edge case where the
                  ;; line of the bullet is empty
                  (ictx-cb (org-element-property :contents-begin item-context))
                  (empty? (and (eq direction 'below)
                               ;; in case contents-begin is nil, or contents-begin
                               ;; equals the position end of the line, the item is
                               ;; empty
                               (or (not ictx-cb)
                                   (= ictx-cb
                                      (1+ (point))))))
                  (pre-insert-point (point)))
             ;; Insert dummy content, so that `org-insert-item'
             ;; inserts content below this item
             (when empty?
               (insert " "))
             (org-insert-item (org-element-property :checkbox context))
             ;; Remove dummy content
             (when empty?
               (delete-region pre-insert-point (1+ pre-insert-point))))))
        ;; Add a new table row
        ((or `table `table-row)
         (pcase direction
           ('below (save-excursion (org-table-insert-row t))
                   (org-table-next-row))
           ('above (save-excursion (org-shiftmetadown))
                   (+org/table-previous-row))))

        ;; Otherwise, add a new heading, carrying over any todo state, if
        ;; necessary.
        (_
         (let ((level (or (org-current-level) 1)))
           ;; I intentionally avoid `org-insert-heading' and the like because they
           ;; impose unpredictable whitespace rules depending on the cursor
           ;; position. It's simpler to express this command's responsibility at a
           ;; lower level than work around all the quirks in org's API.
           (pcase direction
             (`below
              (let (org-insert-heading-respect-content
                    (blank? (org--blank-before-heading-p))) ; NOTE: EDIT
                (goto-char (line-end-position))
                (org-end-of-subtree)
                ;; NOTE: BEGIN: Respect blank settings, at least when inserting headlines below.
                (insert "\n")
                (unless (and blank? (org-previous-line-empty-p))
                  (org-N-empty-lines-before-current (if blank? 1 0)))
                (insert (make-string level ?*) " ")))
             ;; NOTE: END
             (`above
              (org-back-to-heading)
              (insert (make-string level ?*) " ")
              (save-excursion (insert "\n"))))
           (when-let* ((todo-keyword (org-element-property :todo-keyword context))
                       (todo-type    (org-element-property :todo-type context)))
             (org-todo
              (cond ((eq todo-type 'done)
                     ;; Doesn't make sense to create more "DONE" headings
                     (car (+org-get-todo-keywords-for todo-keyword)))
                    (todo-keyword)
                    ('todo)))))))

      (when (org-invisible-p)
        (org-show-hidden-entry))
      (when (and (bound-and-true-p evil-local-mode)
                 (not (evil-emacs-state-p)))
        (evil-insert 1))))
  (advice-add #'+org--insert-item :override #'psydev/+org--insert-item))
#+end_src

Add functions to move to prev/next (potentially invisible) heading
#+begin_src elisp
(after! org
  (defun +psydev/org-previous-heading (arg)
    "Move to the previous (potentially invisible) heading.
With ARG, repeats or can move forward if negative."
    (interactive "p")
    (outline-previous-heading)
    (org-show-set-visibility 'minimal))
  (defun +psydev/org-next-heading (arg)
    "Move to the next (potentially invisible) heading.
With ARG, repeats or can move forward if negative."
    (interactive "p")
    (outline-next-heading)
    (org-show-set-visibility 'minimal)))
#+end_src

Add helper function to help with blank line consistency.
#+begin_src elisp
(defun +org/fix-blank-lines (&optional prefix)
  "Ensure that blank lines exist between headings and between headings and their contents.
With prefix, operate on whole buffer. Ensures that blank lines
exist after each headings's drawers."
  (interactive "P")
  (org-map-entries (lambda ()
                     (org-with-wide-buffer
                      ;; `org-map-entries' narrows the buffer, which prevents us from seeing
                      ;; newlines before the current heading, so we do this part widened.
                      (when (and (forward-line -1) (not (org-at-heading-p)) (forward-line))
                        (while (not (looking-back "\n\n" nil))
                          ;; Insert blank lines before heading.
                          (insert "\n"))))
                     (let ((end (org-entry-end-position)))
                       ;; Insert blank lines before entry content
                       (forward-line)
                       (while (and (org-at-planning-p)
                                   (not (looking-at-p "\n"))
                                   (< (point) (point-max)))
                         ;; Skip planning lines
                         (forward-line))
                       (while (re-search-forward org-drawer-regexp end t)
                         ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
                         ;; for some reason it doesn't work correctly when operating on hidden text.
                         ;; This works, taken from `org-agenda-get-some-entry-text'.
                         (re-search-forward "^[ \t]*:END:.*\n?" end t)
                         (goto-char (match-end 0)))
                       (unless (or (= (point) (point-max))
                                   (org-at-heading-p)
                                   (looking-at-p "\n"))
                         (insert "\n"))))
                   t (if prefix
                         nil
                       'tree)))
#+end_src

*** TODO-items & Checkboxes

Define todo workflows and associated faces.
Use ~#+TODO~ (or ~#+SEQ_TODO~ / ~#+TYP_TODO~) to define per-file keywords
#+begin_src elisp
(after! org
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"          ; A task that needs doing & is ready to do
           "ACTV(a!)"         ; A task that is active/in progress
           "WAIT(w@/!)"       ; A task that is waiting on something external
           "HOLD(h@/!)"       ; A task that is paused/on hold because of me
           "|"
           "DONE(d!/!)")      ; Task successfully completed
          (sequence
           "IDEA(i)"          ; A captured task or project that must be processed and is not yet ready to do
           "SMDY(s)"          ; A task or project that could be done someday, but should not appear in dashboards
           "PROJ(p)"          ; A project, which usually contains other tasks/subprojects
           "|"
           "DONEPROJ(d)")
          (sequence
           "|"
           "CANCELED(c@/!)")) ; Task was aborted or is no longer applicable
        org-todo-keyword-faces
        '(("ACTV" . +org-todo-active)
          ("WAIT" . +org-todo-onhold)
          ("HOLD" . +org-todo-onhold)
          ("SMDY" . +org-todo-onhold)
          ("IDEA" . +org-todo-idea)
          ("PROJ" . +org-todo-project)))
  (custom-declare-face '+org-todo-idea '((t (:inherit (bold org-drawer org-todo)))) "")
  (custom-set-faces!
    '(+org-todo-active :inherit (bold font-lock-constant-face org-todo))
    '(+org-todo-onhold :inherit (bold warning org-todo))
    '(+org-todo-idea :inherit (bold org-formula org-todo))
    '(+org-todo-project :inherit (bold org-priority org-todo))))
#+end_src

Prefer using the ~LOGBOOK~ drawer rather than a CLOSED: entry (~org-log-done~).
#+begin_src elisp
(after! org
  (setq org-log-done nil
        org-log-repeat 'time        ; Ensure that a timestamp is logged when repeating
        org-log-redeadline 'note    ; Ask to record a note when rescheduling a deadline
        org-todo-repeat-to-state 't ; Repeat tasks to the previous state
        org-log-into-drawer "LOGBOOK"))
#+end_src

Block headings from changing to DONE if they have TODO headings that are not DONE.
#+begin_src elisp
(after! org
  (setq org-enforce-todo-dependencies 't
        org-enforce-todo-checkbox-dependencies nil))
#+end_src

Set statistics cookies to be recursive by default.
Set the ~COOKIE_DATA~ property to ~todo~ or ~checkbox~ to resolve conflicts, and
add ~recursive~ to keep the recursive behavior.
#+begin_src elisp
(after! org
  (setq org-hierarchical-todo-statistics nil
        org-checkbox-hierarchical-statistics nil))
#+end_src

Automatically change TODO item with a stats cookie to DONE when children are done.
Unfortunately it does not appear to work with checkboxes.
It also inconveniently switches headlines with no subtasks to DONE.
Kept for reference, but is probably a bad idea.
#+begin_src elisp
;; (after! org
;;   (defun org-todo-done-when-stats-full (n-done n-not-done)
;;     "Switch entry to DONE when all subentries are done."
;;     (let (org-log-done
;;           org-log-states  ; turn off logging
;;           (state (org-get-todo-state)))
;;       (when (= n-not-done 0)
;;         (cond ((equal state "PROJ")
;;                (org-todo "DONEPROJ"))
;;               ((not (equal state "DONEPROJ"))
;;                (org-todo "DONE"))
;;               ))))
;;   (add-hook! 'org-after-todo-statistics-hook #'org-todo-done-when-stats-full))
#+end_src

*** Tags

Configure default tags behavior and appearance.
#+begin_src elisp
(after! org
  ;; Default list of toplevel tags.
  ;; My org files redefine these tags for explicitness and might add their own specific tags.
  (setq org-tag-alist
        '((:startgrouptag . nil)
          ("date"         . ?1)
          (:grouptags     . nil)
          ("event"        . ?e)
          ("appointment"  . ?t)
          (:endgrouptag   . nil)
          (:startgrouptag . nil)
          ("activity"     . ?2)
          (:grouptags     . nil)
          ("read"         . ?r)
          ("listen"       . ?a)
          ("watch"        . ?v)
          (:endgrouptag   . nil)
          (:startgrouptag . nil)
          ("task"         . ?3)
          (:grouptags     . nil)
          ("bug"          . ?b)
          ("improvement"  . ?m)
          ("feature"      . ?f)
          (:endgrouptag   . nil)
          (:startgrouptag . nil)
          ("context"      . ?4)
          (:grouptags     . nil)
          ("@self"        . ?s)
          ("@home"        . ?h)
          ("@work"        . ?w)
          ("@people"      . ?l)
          ("{@.+}"        . ?@)
          (:endgrouptag . nil))
        org-tag-faces
        ;; Teal/Blue version, matches org-formula
        '(("date"        . (:foreground "LightSkyBlue" :weight bold))
          ("activity"    . (:foreground "#b5bd68" :weight bold))
          ("task"        . (:foreground "#cc6666" :weight bold))
          ("context"     . (:foreground "#8abeb7" :weight bold))
          ;; Date tags
          ("event"       . (:foreground "LightSkyBlue" :weight bold))
          ("appointment" . (:foreground "#f0c674" :weight bold))
          ;; Activity tags
          ("read"        . (:foreground "#b5bd68" :weight bold))
          ("listen"      . (:foreground "#b5bd68" :weight bold))
          ("watch"       . (:foreground "#b5bd68" :weight bold))
          ;; Task tags
          ("need"        . (:foreground "#de935f" :weight bold))
          ("issue"       . (:foreground "#cc6666" :weight bold))
          ("bug"         . (:foreground "#cc6666" :weight bold))
          ("improvement" . (:foreground "#de935f" :weight bold))
          ("feature"     . (:foreground "#b5bd68" :weight bold))
          ;; Context tags
          ("@self"       . (:foreground "#8abeb7" :weight bold))
          ("@home"       . (:foreground "#8abeb7" :weight bold))
          ("@work"       . (:foreground "#8abeb7" :weight bold))
          ("@people"     . (:foreground "#8abeb7" :weight bold)))
        org-fast-tag-selection-single-key 't)
  (custom-set-faces!
    ;; '(org-tag :foreground "#717171" :weight normal)
    ;; '(org-tag :foreground "#de935f" :weight normal)
    '(org-tag :foreground "#8abeb7" :weight normal)
    '(org-tag-group :foreground unspecified :weight unspecified)))
#+end_src

Configure tags alignment.
#+begin_src elisp
(after! org
  (setq org-tags-column -132)
  ;; Workaround incorrect tag alignments on headings containing links with a title
  (add-hook 'org-cycle-hook
            (defun psydev/org-cycle-align-tags (state)
              (setq org-tags-column (- 3 (window-body-width)))
              (when (not (memq state '(overview folded))) (org-align-tags 't)))))
#+end_src

*** Dates & Times

Configure org-habit.
#+begin_src elisp
(after! org
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-completed-glyph ?‚úî
        org-habit-today-glyph ?!))
#+end_src

*** Refiling & Archiving

Configure archiving behavior.
#+begin_src elisp
(after! org
  (setq org-archive-location "archive/%s_archive::datetree/"
        org-export-with-archived-trees nil))
#+end_src

*** Agenda
**** Settings

Customize agenda settings.
#+begin_src elisp
(after! org
  ;; Customize window-setup style for agenda.
  (setq org-agenda-window-setup 'current-window
        org-agenda-restore-windows-after-quit nil)

  ;; General agenda setup
  (setq org-agenda-files (list org-directory)
        org-agenda-sticky 't
        org-agenda-span 'week
        org-agenda-start-on-weekday 1
        org-agenda-start-day nil)

  ;; Agenda settings related to items with dates.
  (setq org-agenda-skip-timestamp-if-done 't
        org-agenda-skip-scheduled-if-done 't
        org-agenda-skip-deadline-if-done nil
        org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled
        org-agenda-skip-timestamp-if-deadline-is-shown nil
        org-agenda-skip-scheduled-if-deadline-is-shown 'not-today
        org-agenda-skip-scheduled-delay-if-deadline nil
        org-agenda-show-future-repeats 't))
#+end_src

**** Appearance

Add a separator line between days.
#+begin_src elisp
(after! org
  (setq org-agenda-compact-blocks nil
        org-agenda-format-date
        (lambda (date)
          (concat
           (make-string (window-width) 8943) "\n"
           (org-agenda-format-date-aligned date)))))
#+end_src

Configure prefix.
#+begin_src elisp
(after! org
  ;; NOTE: Category is removed from todo/tags/search views since it is redundant with
  ;; my default org-super-agenda grouping and causes display issues in org-ql-view.
  (setq org-agenda-prefix-format
        '((agenda . " %i %-17:c%?-12t% s")
          (todo . " %i ") ; For category: %-17:c
          (tags . " %i ")
          (search . " %i "))))
#+end_src

Configure time grid.
#+begin_src elisp
(after! org
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          "......" "‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ")
        org-agenda-current-time-string
        "‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ now"))
#+end_src

Customize org scheduled/deadline faces.
#+begin_src elisp
(after! org
  (setq org-deadline-faces
        '((1.001 . error)
          (1.0 . org-imminent-deadline)
          (0.5 . org-upcoming-deadline)
          (0.0 . org-upcoming-distant-deadline)))
  (custom-set-faces!
    '(org-scheduled :foreground unspecified :inherit default)
    '(org-scheduled-today :foreground "#ffffff")
    '(org-scheduled-previously :foreground "#ffffff")
    '(org-upcoming-distant-deadline :foreground unspecified :weight light :inherit org-warning)
    '(org-upcoming-deadline :foreground unspecified :inherit org-warning)
    '(org-imminent-deadline :weight semi-bold :inherit org-warning)))
#+end_src

Do not show blocked tasks as dimmed by default. With my configuration they are usually projects (subtasks not done).
Also customize the face to be brighter, in case locally enabled.
#+begin_src elisp
(after! org
  (setq org-agenda-dim-blocked-tasks nil)
  (custom-set-faces! '(org-agenda-dimmed-todo-face :foreground "#717171")))
#+end_src

Always highlight the current agenda line.
#+begin_src elisp
(add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1)))
#+end_src

**** Diary

Configure diary/agenda integration.
#+begin_src elisp
(after! org
  (setq org-agenda-include-diary nil
        org-agenda-diary-file (concat org-directory "life.org")))
#+end_src

**** Filtering

Configure the custom tag filter accessible via <RET> from the tag filter prompt in agenda (f t).
Also accessible via a triple prefix on the main agenda filter command (f f)
#+begin_src elisp
(after! org
  (defun +org-agenda-exclude-events (tag)
    (when (string= tag "event")
      (concat "-" tag)))
  (setq org-agenda-auto-exclude-function #'+org-agenda-exclude-events))
#+end_src

**** Custom Views

Definition of stuck projects.
#+begin_src elisp
(after! org
  (setq org-stuck-projects
        '("+TODO=\"PROJ\""
          ("TODO" "ACTV")
          ("event" "appointment") "")))
#+end_src

Configure default sorting.
#+begin_src elisp
(after! org
  (setq org-agenda-sorting-strategy
        '((agenda habit-down time-up priority-down category-up)
          (todo category-up priority-down)
          (tags category-up priority-down)
          (search category-up))))
#+end_src

Define custom agenda views.
#+begin_src elisp
(after! org
  (defvar +psydev/org-agenda-groups
        '((:name "Schedule" :time-grid t)
          (:auto-outline-path t :order 99)))

  (setq org-agenda-custom-commands
        '(("d" "Agenda for current day" agenda ""
           ((org-agenda-span 'day)
            (org-super-agenda-groups +psydev/org-agenda-groups)))

          ("w" "Agenda for current week" agenda ""
           ((org-super-agenda-groups +psydev/org-agenda-groups)))

          ("e" "Appointments for current week" agenda* ""
           ((org-super-agenda-groups +psydev/org-agenda-groups)))

          ("l" "Log of the current week" agenda ""
           ((org-agenda-overriding-header "Activity Log")
            (org-agenda-archives-mode 't)
            (org-agenda-start-with-log-mode 'only)
            (org-agenda-log-mode-items '(closed clock state))
            (org-agenda-use-time-grid nil)
            (org-super-agenda-groups nil))))))
#+end_src

**** Commands

Add interactive functions to cycle todo states from agenda.
#+begin_src elisp
(after! org
  (defun +org-agenda-todo-prev ()
    (interactive)
    (org-agenda-todo 'left))
  (defun +org-agenda-todo-next ()
    (interactive)
    (org-agenda-todo 'right)))
#+end_src

**** Hydra

Define a major-mode-hydra.
#+begin_src elisp
(after! org
  (defun org-agenda-cts ()
    (and (eq major-mode 'org-agenda-mode)
         (let ((args (get-text-property
                      (min (1- (point-max)) (point))
                      'org-last-args)))
           (nth 2 args))))

  (major-mode-hydra-define org-agenda-mode
    (:color red :title (+hydra/major-mode-title-generator 'org-agenda-mode 55))
    ("Span"
     (("zd" org-agenda-day-view (format "%s day" (if (eq 'day (org-agenda-cts)) "[x]" "[ ]")))
      ("zw" org-agenda-week-view (format "%s week" (if (eq 'week (org-agenda-cts)) "[x]" "[ ]")))
      ("zt" org-agenda-fortnight-view (format "%s fortnight" (if (eq 'fortnight (org-agenda-cts)) "[x]" "[ ]")))
      ("zm" org-agenda-month-view (format "%s month" (if (eq 'month (org-agenda-cts)) "[x]" "[ ]")))
      ("zy" org-agenda-year-view (format "%s year" (if (eq 'year (org-agenda-cts)) "[x]" "[ ]")))
      ("]" org-agenda-later "later")
      ("[" org-agenda-earlier "earlier"))
     "View"
     (("zg" org-agenda-toggle-time-grid (format "time grid: % -3S" org-agenda-use-time-grid))
      ("ze" org-agenda-entry-text-mode (format "text: % -3S" org-agenda-entry-text-mode))
      ("zA" (org-agenda-archives-mode 'files) (format "archive: %s" org-agenda-archives-mode))
      ("zl" org-agenda-log-mode (format "log: % -3S" org-agenda-show-log))
      ("zL" (org-agenda-log-mode '(4)) "log all")
      ("zc" (org-agenda-log-mode 'clockcheck) "clockcheck")
      ("zr" org-agenda-clockreport-mode (format "clockreport: % -3S" org-agenda-clockreport-mode)))
     "Filter"
     (("fc" org-agenda-filter-by-category "category")
      ("fh" org-agenda-filter-by-top-headline "top heading")
      ("ft" org-agenda-filter-by-tag "tag")
      ("fr" org-agenda-filter-by-regexp "regexp")
      ("ff" org-agenda-filter "edit")
      ("F" org-agenda-filter-remove-all "remove"))
     "Open"
     (("zf" org-agenda-follow-mode (format "follow: % -3S" org-agenda-follow-mode))
      ("S-RET" org-agenda-recenter "view other")
      ("M-RET" org-agenda-tree-to-indirect-buffer "view indirect")
      ("C-RET" org-agenda-goto "open other"))
     "Action"
     (("d" org-agenda-date-prompt "date")
      ("a" org-agenda-add-note "note" :color blue)
      ("i" org-agenda-diary-entry "journal" :color blue)
      ("r" org-agenda-refile "refile")
      ("D" org-agenda-archive-default-with-confirmation "archive"))
     "Mark"
     (("m" org-agenda-bulk-toggle "toggle")
      ("M" org-agenda-bulk-toggle-all "toggle all")
      ("U" org-agenda-bulk-unmark-all "unmark all")
      ("x" org-agenda-bulk-action "action")

      ("q" nil :color blue)
      ("<escape>" nil :color blue)))))
#+end_src

**** Bindings

Customize bindings.
#+begin_src elisp
(after! evil-org-agenda
  ;; Leader bindings
  ;; TODO: Remove the which-key description which are not overridden...
  (map!
   :leader
   ;; Simplify agenda commands in notes prefix.
   (:prefix "n"
    :desc "Org agenda"     "a" #'org-agenda
    "m" nil)

   ;; Unbind agenda commands in open prefix.
   (:prefix "o"
    "a" nil
    "A" nil))

  ;; Agenda bindings
  (map! :map evil-org-agenda-mode-map
        ;; Avoid spurious bindings kicking in with ESC
        :g [escape]   #'transient-noop
        ;; This is more consistent for me
        :m [C-return] #'org-agenda-goto
        :m "C-RET"    #'org-agenda-goto
        :m [S-return] #'org-agenda-recenter
        :m "S-RET"    #'org-agenda-recenter
        :m [M-return] #'org-agenda-tree-to-indirect-buffer
        :m "M-RET"    #'org-agenda-tree-to-indirect-buffer

        ;; Move cursor by items instead of lines by default
        :m "j" #'org-agenda-next-line
        :m "k" #'org-agenda-previous-line
        :m "M-j" #'org-agenda-next-item
        :m "M-k" #'org-agenda-previous-item
        :m "C-j" #'outline-next-heading
        :m "C-k" #'outline-previous-heading

        ;; Add equivalence for org-mode bindings
        :m "C-M-k"    #'org-agenda-priority-up
        :m "C-M-j"    #'org-agenda-priority-down
        :m "C-M-h"    #'+org-agenda-todo-prev
        :m "C-M-l"    #'+org-agenda-todo-next
        :m "C-M-S-h"  #'org-agenda-todo-previousset
        :m "C-M-S-l"  #'org-agenda-todo-nextset

        ;; Bind filter commands to 'f' prefix
        :m "ff"       #'org-agenda-filter
        :m "fh"       #'org-agenda-filter-by-top-headline
        :m "fc"       #'org-agenda-filter-by-category
        :m "fe"       #'org-agenda-filter-by-effort
        :m "fr"       #'org-agenda-filter-by-regexp
        :m "fq"       #'org-agenda-filter-by-tag
        :m "fl"       #'org-agenda-limit-interactively
        :m "F"        #'org-agenda-filter-remove-all
        :m "s^"       nil
        :m "sc"       nil
        :m "se"       nil
        :m "sr"       nil
        :m "st"       nil
        :m "ss"       nil

        ;; Bind "show" commands to 's' prefix
        :m "sh"       #'org-habit-toggle-display-in-agenda
        :m "sH"       #'org-agenda-holidays
        :m "sm"       #'org-agenda-phases-of-moon
        :m "ss"       #'org-agenda-sunrise-sunset
        :m "sq"       #'org-agenda-show-tags
        :m "sd"       #'org-agenda-convert-date
        :m "gh"       nil
        :m "gm"       nil
        :m "gs"       nil
        :m "gt"       nil
        :m "gC"       nil

        ;; Bind additional commands
        :m "S"        #'org-save-all-org-buffers
        :m "M"        #'org-agenda-bulk-toggle-all
        :m "D"        #'org-agenda-archive-default-with-confirmation
        :m "T"        #'org-agenda-set-tags
        :m "p"        #'org-agenda-priority
        :m "d"        #'org-agenda-date-prompt
        :m "cd"       #'org-agenda-date-prompt
        :m ">"        #'org-agenda-remove-restriction-lock

        :map org-agenda-mode-map
        ;; Unbind obsolete and/or misleading bindings
        :m "C-SPC"    nil
        :m "o"        #'org-agenda-open-link

        ;; Bind missing agenda-equivalent of frequent org commands
        :localleader
        "a"           #'org-attach
        "p"           #'org-agenda-priority
        "T"           #'org-timer-set-timer
        "SPC"         #'major-mode-hydra

        :prefix "d"
        "t"           #'org-agenda-date-prompt))
#+end_src

*** Views
**** Org QL Views

Interactive functions to display custom Org QL Views.
#+begin_src elisp
(after! org-ql
  (defvar +psydev/org-view-scope 'buffer
    "The currently selected scope for Org Views.

The special symbol `buffer' means to use the current buffer.")
  (defvar +psydev/org-view-context nil
    "The currently selected context tag for Org Views.

The special symbol `none' means to not match headlines with any context tag.")
  (defvar +psydev/org-view-tags nil
    "The currently selected tags for Org Views.")

  ;; ‚ú¥‚ú≥üèµüåº‚òò
  (defvar +psydev/org-view-groups-dashboard
    '((:name "üìÖ Scheduled" :scheduled t)
      (:name "üåÄ Projects" :todo "PROJ")
      (:auto-outline-path t))
    "Org super agenda groups for dashboard views.")

  (defvar +psydev/org-view-groups-planning
    '((:name "üî• Active" :todo "ACTV") ;
      (:name "‚≠ï Top Priorities" :and (:priority>= "B" :not (:todo "PROJ")))
      (:name "üìÖ Scheduled" :scheduled t)
      (:name "üåÄ Projects" :todo "PROJ")
      ;; Life-specific heading groups
      (:name "üéß Musique" :and (:outline-path-regexp "Musique" :tag "listen"))
      (:name "üé• Cin√©ma" :and (:outline-path-regexp "Cin√©ma" :tag "watch"))
      ;; Default groups
      (:auto-outline-path t))
    "Org super agenda groups for planning views.")

  (defvar +psydev/org-view-groups-backlog
    '((:name "üéØ Goals" :transformer #'+psydev/org-view-goals-transformer :todo nil)
      (:auto-outline-path t))
    "Org super agenda groups for backlog views.")

  (defun +psydev/org-view-goals-transformer (item)
    (org-super-agenda--when-with-marker-buffer (org-super-agenda--get-marker item)
      (s-replace-regexp "Goals\\|Objectifs" (car (last (org-get-outline-path))) item)))

  (defun +psydev/org-view-upcoming ()
    (interactive)
    (+psydev/org-view-make
     :buffers-files +psydev/org-view-scope
     :narrow t
     :query '(and (or (scheduled)
                      (deadline auto))
                  (not (done)))
     :context +psydev/org-view-context
     :tags +psydev/org-view-tags
     :super-groups '((:auto-planning t))
     :title "Upcoming"))

  (defun +psydev/org-view-dashboard ()
    (interactive)
    (+psydev/org-view-make
     :buffers-files +psydev/org-view-scope
     :narrow t
     :query '(and (todo)
                  (not (todo "SMDY" "IDEA"))
                  (not (ancestors (todo "SMDY" "IDEA")))
                  (or (todo "ACTV") (priority '>= "B")))
     :context +psydev/org-view-context
     :tags +psydev/org-view-tags
     :super-groups +psydev/org-view-groups-dashboard
     :title "Dashboard"))

  (defun +psydev/org-view-planning ()
    (interactive)
    (+psydev/org-view-make
     :buffers-files +psydev/org-view-scope
     :narrow t
     :query '(and (todo)
                  (not (todo "SMDY" "IDEA"))
                  (not (ancestors (todo "SMDY" "IDEA"))))
     :context +psydev/org-view-context
     :tags +psydev/org-view-tags
     :super-groups +psydev/org-view-groups-planning
     :title "Planning"))

  (defun +psydev/org-view-backlog ()
    (interactive)
    (+psydev/org-view-make
     :buffers-files +psydev/org-view-scope
     :narrow t
     :query '(and (or (todo)
                      (heading-regexp "^\\(Goals\\|Objectifs\\)$"))
                  (not (tags "read" "listen" "watch")))
     :context +psydev/org-view-context
     :tags +psydev/org-view-tags
     :super-groups +psydev/org-view-groups-backlog
     :title "Backlog"))

  (cl-defun +psydev/org-view-make (&key buffers-files query narrow super-groups sort title context tags)
    (let ((buffers-files (cond ((equal buffers-files 'buffer) (current-buffer))
                               (buffers-files)
                               (t #'org-agenda-files)))
          (query (append query (+psydev/org-view-make-query context tags)))
          (sort (or sort '(priority scheduled))))
      (org-ql-search buffers-files query
        :narrow narrow
        :super-groups super-groups
        :sort sort
        :title (+psydev/org-view--make-title title buffers-files context tags))))

  (defun +psydev/org-view-make-query (&optional context tags)
    (append
     (when context
       (if (eq context 'none)
           '((not (tags-regexp "@.+")))
         `((tags ,context))))
     (when tags `((tags ,@tags)))))

  (defun +psydev/org-view--make-title (name &optional buffers-files context tags)
    (let ((source (when buffers-files (format " in %s" buffers-files)))
          (suffix (mapconcat (lambda (it) (format "%s" it))
                             (remove nil (list context tags))
                             " ")))
      (cond ((and name (not (string-empty-p suffix))) (concat name source ": " suffix))
            ((and (not name) suffix) suffix)
            (t (concat name source))))))
#+end_src

**** Sidebar

Define sidebar views.
#+begin_src elisp
(after! org-sidebar
  (defun +psydev/org-sidebar--daily-agenda-fn (source-buffer)
    "Return an Org Agenda buffer showing the daily agenda in SOURCE-BUFFER."
    (save-window-excursion (org-agenda nil "d"))
    org-agenda-buffer)

  (defun +psydev/org-sidebar--upcoming-fn (source-buffer)
    "Return an Org QL View buffer showing unscheduled, un-deadlined items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Upcoming*")))
      (let ((org-ql-view-buffer display-buffer)
            (+psydev/org-view-scope 'buffer))
        (save-window-excursion (+psydev/org-view-upcoming)))
      display-buffer))
  (defun +psydev/org-sidebar-agenda-upcoming ()
    (interactive)
    (let ((org-sidebar-default-fns '(+psydev/org-sidebar--daily-agenda-fn +psydev/org-sidebar--upcoming-fn)))
      (org-sidebar-toggle)))

  (defun +psydev/org-sidebar--dashboard-fn (source-buffer)
    "Return an Org QL View buffer showing active and high-priority items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Dashboard*")))
      (let ((org-ql-view-buffer display-buffer)
            (+psydev/org-view-scope 'buffer))
        (save-window-excursion (+psydev/org-view-dashboard)))
      display-buffer))
  (defun +psydev/org-sidebar-dashboard ()
    (interactive)
    (let ((org-sidebar-default-fns '(+psydev/org-sidebar--dashboard-fn)))
      (org-sidebar-toggle)))

  (defun +psydev/org-sidebar--planning-fn (source-buffer)
    "Return an Org QL View buffer showing active and high-priority items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Planning*")))
      (let ((org-ql-view-buffer display-buffer)
            (+psydev/org-view-scope 'buffer))
        (save-window-excursion (+psydev/org-view-planning)))
      display-buffer))
  (defun +psydev/org-sidebar-planning ()
    (interactive)
    (let ((org-sidebar-default-fns '(+psydev/org-sidebar--planning-fn)))
      (org-sidebar-toggle)))

  (defun +psydev/org-sidebar--backlog-fn (source-buffer)
    "Return an Org QL View buffer showing active and high-priority items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Backlog*")))
      (let ((org-ql-view-buffer display-buffer)
            (+psydev/org-view-scope 'buffer))
        (save-window-excursion (+psydev/org-view-backlog)))
      display-buffer))
  (defun +psydev/org-sidebar-backlog ()
    (interactive)
    (let ((org-sidebar-default-fns '(+psydev/org-sidebar--backlog-fn)))
      (org-sidebar-toggle)))

  (setq org-sidebar-default-fns '(+psydev/org-sidebar--dashboard-fn +psydev/org-sidebar--planning-fn)))
#+end_src

**** Hydra

Define a view dispatcher hydra.
#+begin_src elisp
(after! (org-ql pretty-hydra)
  (defun +hydra/org-view--format-view-head (name)
    (concat name " "
            (when (not (eq +psydev/org-view-scope #'org-agenda-files)) "<")
            (when +psydev/org-view-context "@")
            (when +psydev/org-view-tags "+")))
  (defun +hydra/org-view--format-tree-head (name)
    (concat name " "
            (when +psydev/org-view-context "@")
            (when +psydev/org-view-tags "+")))
  (defun +hydra/org-view--format-context-head (val)
    (format "%s %s" (if (equal +psydev/org-view-context val) "[x]" "[ ]") val))
  (defun +hydra/org-view--format-tag-head (tag)
    (format "%s %s" (if (member tag +psydev/org-view-tags) "[x]" "[ ]") tag))

  (defun +hydra/org-view--set-scope (scope)
    (cl-case scope
      ('buffer (progn (setq +psydev/org-view-scope 'buffer)))
      ('file (let ((file (read-file-name "Select File: " org-directory nil (confirm-nonexistent-file-or-buffer))))
               (when file
                 (setq +psydev/org-view-scope file))))
      (t (progn (setq +psydev/org-view-scope #'org-agenda-files)))))

  (pretty-hydra-define +hydra/org-view
    (:color teal :separator "‚ïê" :title (+hydra/title-generator "Org Views" "tasks" 51))
    ("Agenda"
     (("ad" (org-agenda current-prefix-arg "d") "day agenda")
      ("aw" (org-agenda current-prefix-arg "w") "week agenda")
      ("ae" (org-agenda current-prefix-arg "e") "week events")
      ("al" (org-agenda current-prefix-arg "l") "week log"))
     "View"
     (("u" +psydev/org-view-upcoming (+hydra/org-view--format-view-head "upcoming") :width 13)
      ("d" +psydev/org-view-dashboard (+hydra/org-view--format-view-head "dashboard") :width 13)
      ("p" +psydev/org-view-planning (+hydra/org-view--format-view-head "planning") :width 13)
      ("b" +psydev/org-view-backlog (+hydra/org-view--format-view-head "backlog") :width 13))
     "Tree"
     (("tp" (org-ql-sparse-tree
             (append '(and (todo "PROJ"))
                     (+psydev/org-view-make-query +psydev/org-view-context +psydev/org-view-tags)))
       (+hydra/org-view--format-tree-head "project") :width 10)
      ("tt" (org-ql-sparse-tree
             (append '(and (todo))
                     (+psydev/org-view-make-query +psydev/org-view-context +psydev/org-view-tags)))
       (+hydra/org-view--format-tree-head "todo") :width 10)
      ("tm" (org-ql-sparse-tree
             (append '(and (tags))
                     (+psydev/org-view-make-query +psydev/org-view-context +psydev/org-view-tags)))
       (+hydra/org-view--format-tree-head "tag") :width 10)
      ;; NOTE: Occur command does not support tags as it would hardly make sense
      ("to" (progn (org-check-for-org-mode)
                   (unless +psydev/org-view-context
                     (error "Cannot show occurrences of unset context"))
                   (when (eq +psydev/org-view-context 'none)
                     (error "Cannot show occurrences of `none' context"))
                   (org-occur +psydev/org-view-context))
       (+hydra/org-view--format-tree-head "occur") :width 10))
     "Scope (<)"
     (("<" (+hydra/org-view--set-scope 'all)
       (format "%s all" (if (eq +psydev/org-view-scope #'org-agenda-files) "[x]" "[ ]")) :width 18
       :color red)
      ("/" (+hydra/org-view--set-scope 'file)
       (if (and (stringp +psydev/org-view-scope) (s-starts-with-p "/" +psydev/org-view-scope))
           (format "[x] %s" (file-name-nondirectory +psydev/org-view-scope))
         (format "[ ] select file")) :width 18
       :color red)
      ("." (+hydra/org-view--set-scope 'buffer)
       (format "%s current buffer" (if (equal +psydev/org-view-scope 'buffer) "[x]" "[ ]")) :width 18
       :color red))
     "Context (@)"
     (("@" (setq +psydev/org-view-context nil)
       (format "%s all" (if (not +psydev/org-view-context) "[x]" "[ ]")) :width 11
       :color red)
      ("!" (setq +psydev/org-view-context 'none) (+hydra/org-view--format-context-head 'none) :width 11 :color red)
      ("s" (setq +psydev/org-view-context "@self") (+hydra/org-view--format-context-head "@self") :width 11 :color red)
      ("h" (setq +psydev/org-view-context "@home") (+hydra/org-view--format-context-head "@home") :width 11 :color red)
      ("w" (setq +psydev/org-view-context "@work") (+hydra/org-view--format-context-head "@work") :width 11 :color red)
      ("P" (setq +psydev/org-view-context "@people") (+hydra/org-view--format-context-head "@people") :width 11 :color red))
     "Tags (+)"
     (("+" (setq +psydev/org-view-tags nil)
       (format "%s all" (if (not +psydev/org-view-tags) "[x]" "[ ]")) :width 10
       :color red)
      ("r" (add-to-list '+psydev/org-view-tags "read") (+hydra/org-view--format-tag-head "read") :width 10 :color red)
      ("l" (add-to-list '+psydev/org-view-tags "listen") (+hydra/org-view--format-tag-head "listen") :width 10 :color red)
      ("v" (add-to-list '+psydev/org-view-tags "watch") (+hydra/org-view--format-tag-head "watch") :width 10 :color red)
      ("n" (add-to-list '+psydev/org-view-tags "need") (+hydra/org-view--format-tag-head "need") :width 10 :color red)

      ("q" nil)
      ("<escape>" nil)))))
#+end_src

**** Bindings

Customize bindings.
#+begin_src elisp
(after! (org-ql org-sidebar)
  ;; Leader bindings
  (map! :leader
   :prefix "n"
   :desc "Org upcoming"           "u" #'+psydev/org-view-upcoming
   :desc "Org upcoming sidebar"   "U" #'+psydev/org-sidebar-agenda-upcoming
   :desc "Org dashboard"          "d" #'+psydev/org-view-dashboard
   :desc "Org dashboard sidebar"  "D" #'+psydev/org-sidebar-dashboard
   :desc "Org planning"           "p" #'+psydev/org-view-planning
   :desc "Org planning sidebar"   "P" #'+psydev/org-sidebar-planning
   :desc "Org backlog"            "b" #'+psydev/org-view-backlog
   :desc "Org backlog sidebar"    "B" #'+psydev/org-sidebar-backlog
   :desc "Org view"               "v" #'+hydra/org-view/body))
#+end_src

*** TODO Block & Source

Configure code editing behavior.
#+begin_src elisp
(after! org
  (setq org-src-fontify-natively 't
        org-src-tab-acts-natively 't
        org-src-preserve-indentation 't
        org-src-window-setup 'current-window
        org-src-ask-before-returning-to-edit-buffer nil
        org-edit-src-persistent-message nil))
#+end_src

Fix ~evil-org-edit-src-exit~ remove evil-write to prevent error when no filename is provided.
#+begin_src elisp
(after! evil-org
  (defun evil-org-edit-src-exit ()
    "Fallback to `evil-edit-src-exit'."
    (interactive)
    (mapc #'call-interactively '(org-edit-src-exit))))
#+end_src

Fix ~evil-save-modified-and-close~ for org-mode temporary buffers.
#+begin_src elisp
(after! evil-org
  (evil-define-command evil-save-modified-and-close (file &optional bang)
    "Saves the current buffer and closes the window."
    :repeat nil
    (interactive "<f><!>")
    (if (and (local-variable-p 'org-finish-function)
             (fboundp org-finish-function))
        (funcall org-finish-function)
      (when (buffer-modified-p)
        (evil-write nil nil nil file bang))
      (evil-quit))))
#+end_src

*** TODO Chef

I *need* this in my life. It take a URL to a recipe from a common site, and
inserts an org-ified version at point. Isn't that just great.
#+begin_src elisp
;; (package! org-chef :pin "5b461ed7d458cdcbff0af5013fbdbe88cbfb13a4")
#+end_src

*** Appearance

Customize org appearance.
#+begin_src elisp
(after! org
  ;; Change the ellipsis to something prettier
  (setq org-ellipsis " ‚ñæ"))
#+end_src

Customize org-superstar.
#+begin_src elisp
(after! org-superstar
  ;; Make leading stars truly invisible, by rendering them as spaces.
  (setq org-superstar-leading-bullet ?\s
        org-superstar-leading-fallback ?\s
        org-hide-leading-stars nil
        ;; With org-indent this is also needed, otherwise the
        ;; above has no effect while indent is enabled.
        org-indent-mode-turns-on-hiding-stars nil)
  ;; Stop cycling bullets to emphasize hierarchy of headlines.
  (setq org-superstar-cycle-headline-bullets nil)
  ;; Define custom bullets.
  (setq org-superstar-headline-bullets-list
        '(?‚óâ ?‚óã ?‚óè ?‚óã ?‚óè ?‚óã ?‚óè)
        ;; '(?‚óâ ?‚óã ?‚óà ?‚ú∏ ?‚úø ?‚ú£ ?‚ñ∑)
        org-superstar-item-bullet-alist
        '((42 . ?‚Ä¢)
          (43 . ?‚û§)
          (45 . ?‚Äì)))
  ;; Disable list syntax checking for files with lots of list items.
  (defun org-superstar-auto-lightweight-mode ()
    "Start org-superstar differently depending on the number of lists items."
    (let ((list-items
           (count-matches "^[ \t]*?\\([+-]\\|[ \t]\\*\\)"
                          (point-min) (point-max))))
      (unless (< list-items 200)
        (org-superstar-toggle-lightweight-lists)))
    (org-superstar-mode))

  (remove-hook! org-mode #'org-superstar-mode)
  (add-hook! org-mode #'org-superstar-auto-lightweight-mode))
#+end_src

Customize priorities faces.
#+begin_src elisp
(after! org
  (setq org-priority-faces
        '((65 . error)
          (66 . warning)
          (67 . success)
          (68 . default) ; Keep default outline face
          (69 . shadow))))
#+end_src

*** Integration

Advise functions that jump to locations to show context around point in org-mode.
#+begin_src elisp
(after! (evil-vars undo-fu goto-chg)
  (defadvice! +psydev/org-jump-visibility (&rest _)
    :after (list evil-undo-function evil-redo-function
                 #'goto-last-change)
    (when (derived-mode-p 'org-mode)
      (org-show-set-visibility 'lineage))))
#+end_src

*** Popups

Customize popup rules for org-related buffers.
#+begin_src elisp
(after! org
  (set-popup-rules!
    '(("^\\*Org Src" :ignore t))))
#+end_src

*** Bindings

Restore original TAB behavior to cycle through current subtree recursively.
#+begin_src elisp
;; (after! evil-org
;;   (remove-hook 'org-tab-first-hook #'+org-cycle-only-current-subtree-h))
#+end_src

Customize bindings.
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        ;; Prefer smart beginning of line to digit argument? (overridden)
        :m "0"               #'evil-org-beginning-of-line
        ;; Add quick motion bindings
        :ni "C-k"     (cmds! (org-at-table-p) #'+org/table-previous-row
                             (bound-and-true-p evil-insert-state-minor-mode) #'evil-previous-line
                             #'org-backward-paragraph)
        :ni "C-j"     (cmds! (org-at-table-p) #'org-table-next-row
                             (bound-and-true-p evil-insert-state-minor-mode) #'evil-next-line
                             #'org-forward-paragraph)
        :ni "C-h"     (cmds! (org-at-table-p) #'org-table-previous-field
                             (bound-and-true-p evil-insert-state-minor-mode) #'left-char
                             #'evil-backward-word-begin)
        :ni "C-l"     (cmds! (org-at-table-p) #'org-table-next-field
                             (bound-and-true-p evil-insert-state-minor-mode) #'right-char
                             #'evil-forward-word-begin)
        ;; Prefer visible headings to same-level
        :ni "C-S-k"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'org-backward-paragraph
                             #'org-previous-visible-heading) ; org-backward-heading-same-level)
        :ni "C-S-j"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'org-forward-paragraph
                             #'org-next-visible-heading) ; org-forward-heading-same-level)
        ;; Allow subtree traversal
        :ni "C-S-h"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'evil-backward-word-begin
                             #'org-up-element)
        :ni "C-S-l"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'evil-forward-word-begin
                             #'org-down-element)

        ;; Evil replacements
        :g "C-M-k"          #'org-shiftup
        :g "C-M-j"          #'org-shiftdown
        :g "C-M-h"          #'org-shiftleft
        :g "C-M-l"          #'org-shiftright
        :g "C-M-S-k"        #'org-shiftcontrolup
        :g "C-M-S-j"        #'org-shiftcontroldown
        :g "C-M-S-h"        #'org-shiftcontrolleft
        :g "C-M-S-l"        #'org-shiftcontrolright

        ;; Bind custom implementation of prev/next fold commands for org-mode.
        ;; FIXME: +fold/next stopped working in org-mode at some point in 2021...
        :m "zj"             #'+psydev/org-next-heading
        :m "zk"             #'+psydev/org-previous-heading

        ;; Bind org-reveal to something more accessible and consistent.
        :n "z <return>"     #'org-reveal
        :n "z RET"          #'org-reveal

        ;; Move some bindings in org-mode-map so that it can be easily overridden in derived maps.
        :nv [tab]           nil
        :nv "TAB"           nil
        :nv [S-tab]         nil
        :nv [S-iso-lefttab] nil
        :nv [backtab]       nil
        :ni [return]        nil
        :ni "RET"           nil
        :i [S-return]       nil
        :i "S-RET" nil

        :map org-mode-map
        :m [tab]           #'org-cycle
        :m "TAB"           #'org-cycle
        :m [S-tab]         #'org-shifttab
        :m [S-iso-lefttab] #'org-shifttab
        :m [backtab]       #'org-shifttab
        :n [return]        #'+org/dwim-at-point
        :n "RET"           #'+org/dwim-at-point
        :i [return]        (cmd! (org-return electric-indent-mode))
        :i "RET"           (cmd! (org-return electric-indent-mode))
        ;; This looks like a fix for doom
        :ni [S-return]     #'+org/shift-return
        :ni "S-RET"        #'+org/shift-return

        ;; M-RET difficult choices
        ;; - normal-mode: org-ctrl-c-ret
        ;;   Always insert headings and not list items: straight to the point. Useful to split headings.
        ;;   More appropriate behavior in tables (or I don't understand how wrapping works)
        ;; - insert-mode: org-meta-return
        ;;   More appropriate to break an item/heading in two, supports the respect-content setting
        :gn [M-return]       #'org-ctrl-c-ret
        :gn "M-RET"          #'org-ctrl-c-ret
        :i [M-return]        #'org-meta-return
        :i "M-RET"           #'org-meta-return
        ;; This is more consistent for me
        :g [M-S-return]      #'org-insert-subheading
        :g "M-S-RET"         #'org-insert-subheading
        :g [C-M-return]      #'org-insert-todo-heading
        :g "C-M-RET"         #'org-insert-todo-heading
        :g [C-M-S-return]    #'org-insert-todo-subheading
        :g "C-M-S-RET"       #'org-insert-todo-subheading

        ;; Override +fold/close-all, it seems broken in org-mode
        :m "<backtab>"       #'org-shifttab
        :m "C-<iso-lefttab>" #'org-ctrl-c-tab

        (:localleader
         "f"                 #'+org/fix-blank-lines
         "F"                 #'org-footnote-action
         "D"                 #'org-insert-drawer
         "H"                 #'org-list-make-subtree
         "O"                 #'org-property-action
         "X"                 #'org-toggle-radio-button
         "T"                 #'org-timer-set-timer
         "e"                 #'org-edit-special
         "E"                 #'org-export-dispatch
         (:prefix ("s" . "Tree/Subtree")
          "A"                #'org-archive-to-archive-sibling
          "o"                #'org-toggle-ordered-property)))
  ;; Cancel remapping of org-set-tags-command (behavior is much more complete)
  (define-key!
    [remap org-set-tags-command] nil))
#+end_src

*** Performance

Disable flyspell by default in org-mode (laggy).
#+begin_src elisp
(remove-hook! org-mode #'flyspell-mode)
#+end_src

Remove the tangle-on-save hook and add a manual binding.
#+begin_src elisp
(remove-hook! org-mode #'+literate-enable-recompile-h)
(defun +literate-recompile ()
  "Recompile literate config to `doom-private-dir"
  (interactive)
  (+literate-recompile-maybe-h))
(map! :map org-mode-map
      :localleader
      "R" #'+literate-recompile)
#+end_src

Improve org performance by removing some candy.
See [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#why-is-emacsdoom-slow][this section of the doom FAQ]].
#+begin_src elisp
(after! org
  (setq org-fontify-whole-heading-line nil
        org-fontify-quote-and-verse-blocks nil))
#+end_src

** Org QL

Configuration and integration with doom.
#+begin_src elisp
(use-package! org-ql
  :after org
  :config
  ;; Do not consider org QL Views as popups and use the same window behavior than agenda.
  (set-popup-rule! "^\\*Org QL View:" :ignore 't)
  (setq org-ql-view-display-buffer-action '(display-buffer-same-window))

  ;; This mechanism for selecting org views is not used. Use the org-view hydra instead.
  (setq org-ql-views nil)

  ;; Override magit's default of `display-buffer-below-selected` and restore original value.
  ;; It causes `org-ql-view-dispatch` to show in a horizontal split.
  (setq transient-display-buffer-action
        '(display-buffer-in-side-window
          (side . bottom)
          (dedicated . t)
          (inhibit-same-window . t)
          (window-parameters (no-other-window . t)))))
#+end_src

Customize bindings and integrate with doom/evil.
#+begin_src elisp
(after! org-ql-view
  ;; Configure bindings to override default evil bindings
  (evil-make-overriding-map org-ql-view-map 'normal)
  (map! :map org-ql-view-map
        :g "q" #'org-agenda-quit
        :g "r" #'org-ql-view-refresh
        :g "C-r" #'org-ql-view-dispatch
        :g "C-s" #'org-ql-view-save)
  (evil-make-overriding-map org-ql-view-list-map 'normal)
  (map! :map org-ql-view-list-map
        :n [return]     #'org-ql-view-switch
        :n "RET"        #'org-ql-view-switch
        :n "c"          #'org-ql-view-customize
        :n "q"          #'bury-buffer))
#+end_src

** Org sidebar

Configuration and integration with doom.
#+begin_src elisp
(use-package! org-sidebar
  :config
  ;; Make org-ql-view windows not selectable by 'other-window'
  (setq org-ql-view-no-other-window t))
#+end_src

*** Tree

Make tree sidebar buffers hidden.
#+begin_src elisp
(after! org-sidebar
  (cl-defun org-sidebar-tree-view-buffer (&key (buffer (current-buffer)) &allow-other-keys)
    "Return a tree-view buffer for BUFFER."
    (-let* ((buffer-name (format " *Tree: %s*" (buffer-name buffer))) ; NOTE: EDIT
            ((min max) (with-current-buffer buffer
                         (list (point-min) (point-max))))
            (existing-buffer (get-buffer buffer-name))
            tree-buffer)
      (when existing-buffer
        ;; Buffer with name already exists.
        (if (buffer-base-buffer existing-buffer)
            ;; Buffer is indirect: kill it so we can remake it.
            (kill-buffer existing-buffer)
          ;; Buffer is not indirect: something is probably wrong, so warn.
          (warn "Existing tree buffer that is not indirect: %s" existing-buffer)))
      (setf tree-buffer (clone-indirect-buffer buffer-name nil 'norecord))
      (with-current-buffer tree-buffer
        (use-local-map org-sidebar-tree-map)
        (setf mode-line-format nil
              header-line-format (concat "Tree: " (buffer-name buffer)))
        (toggle-truncate-lines 1)
        (centaur-tabs-local-mode 1) ; NOTE: EDIT
        (save-excursion
          (goto-char min)
          (if (org-before-first-heading-p)
              (progn
                ;; Narrow buffer to exclude pre-heading content.
                (outline-next-heading)
                (setf min (point)))
            ;; Tree view only shows one subtree: expand its branches.
            (outline-show-branches)))
        (narrow-to-region min max)
        (save-excursion
          ;; Hide visible entry bodies.
          (goto-char (point-min))
          (when (org-before-first-heading-p)
            (outline-next-visible-heading 1))
          (cl-loop do (outline-hide-body)
                   while (outline-next-visible-heading 1)))
        (unless (org-before-first-heading-p)
          (outline-back-to-heading)))
      tree-buffer)))
#+end_src

Custom toggle function to autofocus the tree sidebar.
#+begin_src elisp
(after! org-sidebar
  ;;
  (defun +psydev/org-sidebar-tree-toggle ()
    (interactive)
    (org-sidebar-tree-toggle)
    (let* ((tree-window (--first (window-parameter it 'org-sidebar-tree-window)
                                 (window-at-side-list nil org-sidebar-tree-side))))
      (when tree-window (select-window tree-window)))))
#+end_src

*** Sidebar

Make sure truncate line is enabled instead of toggled.
#+begin_src elisp
(after! org-sidebar
  (remove-hook 'org-ql-sidebar-buffer-setup-hook #'toggle-truncate-lines)
  (add-hook! 'org-ql-sidebar-buffer-setup-hook
    (defun psydev/org-sidebar-buffer-setup ()
      (toggle-truncate-lines 1))))
#+end_src

Workaround issue displaying sidebar buffers.
#+begin_src elisp
;; (after! org-sidebar
;;   ;; NOTE: This was NOT happening when I started using sidebar, and suddenly started to happen
;;   ;; while I was working on other emacs stuff. Need to identify the cause for  this.
;;   (add-hook! 'org-sidebar-window-after-display-hook
;;     (defun psydev/org-sidebar-fix-display ()
;;       (force-window-update (selected-window))
;;       (redisplay))))
#+end_src

Allow regular org-agenda buffers to be present in sidebar.
#+begin_src elisp
(after! org-sidebar
  (defun org-sidebar-refresh ()
    "Refresh sidebar buffers.
  Refreshes the current sidebar buffer and other associated sidebar
  buffers."
    (interactive)
    (save-window-excursion
      (let ((source-buffer org-sidebar-source-buffer)
            (display-buffers (buffer-local-value 'org-sidebar-sidebar-buffers org-sidebar-source-buffer)))
        (--each display-buffers
          (when (buffer-live-p it)
            (with-current-buffer it
              (let ((old-buffer-name (buffer-name)))
                (cond (org-ql-view-buffers-files (org-ql-view-refresh)) ; NOTE: EDIT
                      (t (org-agenda-redo)))
                ;; Restore buffer name (because `org-ql-view-refresh' changes it).
                (rename-buffer old-buffer-name)
                (setf org-sidebar-source-buffer source-buffer) ; NOTE: EDIT
                (org-sidebar--prepare-buffer))))))))

  (defun org-sidebar--prepare-buffer ()
    "Prepare current buffer as a sidebar buffer.
  This is not used for `org-sidebar-tree' buffers."
    (let ((inhibit-read-only t))
      (when org-ql-view-title ; NOTE: EDIT
        (setf header-line-format (org-ql-view--header-line-format :title org-ql-view-title)))
      (use-local-map org-sidebar-map)
      ;; (goto-char (point-min)) ; TODO Gives initial focus but resets during refresh also...
      (run-hook-with-args 'org-ql-sidebar-buffer-setup-hook))))
#+end_src

Improve sidebar window behavior: dedicated, fixed-size, ...
#+begin_src elisp
(after! org-sidebar
  (cl-defun org-sidebar--display-buffers (buffers &key window-parameters)
    "Display BUFFERS in the sidebar.
  WINDOW-PARAMETERS are applied to each window that is displayed."
    (declare (indent defun))
    (when-let* ((side-windows (window-at-side-list nil org-sidebar-side))
                (sidebar-buffers (--select (buffer-local-value 'org-sidebar-source-buffer it)
                                           (mapcar #'window-buffer side-windows)))
                (sidebar-windows (mapcar #'get-buffer-window sidebar-buffers)))
      ;; Delete existing org-sidebar windows on our side.
      (mapc #'delete-window sidebar-windows))
    (let ((slot 0)
          (window-parameters (append (list (cons 'no-delete-other-windows nil))
                                     window-parameters)))
      (--each buffers
        (when-let* ((window (+popup-display-buffer-stacked-side-window-fn ; NOTE: EDIT
                             it
                             (list (cons 'side org-sidebar-side)
                                   (cons 'slot slot)
                                   (cons 'dedicated t) ; NOTE: EDIT
                                   (cons 'window-width .20) ; NOTE: EDIT
                                   (cons 'preserve-size (cons t nil)) ; NOTE: EDIT
                                   (cons 'window-parameters window-parameters)))))
          (with-selected-window window
            (run-hooks 'org-sidebar-window-after-display-hook))
          (if (eq slot 0)
              (select-window window)) ; NOTE: EDIT (goto-char call no longer focuses window for some reason)
          (cl-incf slot))))))
#+end_src

Improve toggling behavior:
- Do not toggle off if the given list of function differs from the current sidebar
- Allow changing view from the sidebar buffer
- Allow toggling off from the sidebar buffer
#+begin_src elisp
(after! org-sidebar
  (defvar-local org-sidebar-source-fns nil
    "Org sidebar functions that this sidebar buffer was generated from.")

  (defun org-sidebar (fns)
    "Display the Org Sidebar.
Interactively, display the sidebars configured in
`org-sidebar-default-fns'.
FNS should be one or a list of functions which return a buffer to
be displayed in the sidebar.  Each one is called with the current
buffer as its argument."
    (interactive (list org-sidebar-default-fns))
    (when org-sidebar-sidebar-buffers
      ;; Kill existing sidebar buffers for the source buffer.
      (mapc #'kill-buffer org-sidebar-sidebar-buffers)
      (setf org-sidebar-sidebar-buffers nil))
    (let* ((source-buffer (current-buffer))
           (fns (cl-etypecase fns
                  (list fns)
                  (atom (list fns))))
           (display-buffers (cl-loop for fn in fns
                                     collect (funcall fn source-buffer))))
      (when display-buffers
        (setf org-sidebar-sidebar-buffers display-buffers)
        (--each display-buffers
          (with-current-buffer it
            (org-sidebar--prepare-buffer)
            (setf org-sidebar-source-fns fns) ; NOTE: EDIT
            (setf org-sidebar-source-buffer source-buffer)))
        (org-sidebar--display-buffers display-buffers
          :window-parameters (list (cons 'org-sidebar-window t)
                                   (cons 'org-sidebar-source-buffer-point-min (point-min)))))))

  (defun org-sidebar-toggle (&optional fns)
    "Toggle default sidebar window.
If it is open and shows the view for the current buffer, delete
it.  Otherwise, show it for current buffer."
    (interactive)
    (let* ((fns (or fns org-sidebar-default-fns)) ; NOTE: EDIT
           (source-buffer (current-buffer))
           (point-min (point-min))
           (sidebar-window (--first (window-parameter it 'org-sidebar-window)
                                    (window-at-side-list nil org-sidebar-side))))
      ;; NOTE: EDIT: if the sidebar window is selected, use the sidebar source-buffer instead.
      (if (eq sidebar-window (selected-window))
          (setq source-buffer
                (buffer-local-value 'org-sidebar-source-buffer (window-buffer sidebar-window))
                point-min (with-current-buffer source-buffer (point-min))))
      ;; We only compare the first sidebar window, but that should be good enough.
      (if (and sidebar-window
               (with-current-buffer (window-buffer sidebar-window)
                 ;; NOTE: EDIT: Compare source functions to avoid toggling off when requesting another view.
                 (and (eq fns (buffer-local-value 'org-sidebar-source-fns (current-buffer)))
                      (eq org-sidebar-source-buffer source-buffer)
                      ;; Compare point-min to detect narrowed buffers.
                      (eq (window-parameter sidebar-window 'org-sidebar-source-buffer-point-min)
                          point-min))))
          ;; Sidebar is for current buffer: delete sidebar windows.
          (mapc #'delete-window (--select (window-parameter it 'org-sidebar-window)
                                          (window-at-side-list nil org-sidebar-side)))
        ;; Sidebar is for a different buffer: show sidebar for current buffer.
        (with-current-buffer source-buffer ; NOTE: EDIT
          (org-sidebar fns))))))
#+end_src

*** Bindings

Integrate with doom/evil bindings.
#+begin_src elisp
(after! org-sidebar
  ;; Leader bindings
  (map! :leader :prefix "n"
    :desc "Org task sidebar"  "t" #'org-sidebar-toggle
    :desc "Org tree sidebar"  "T" #'+psydev/org-sidebar-tree-toggle)

  ;; Configure bindings to override default org/evil bindings
  (evil-make-overriding-map org-sidebar-tree-map 'normal)
  (map! :map org-sidebar-tree-map
        :n [return]        #'org-sidebar-tree-jump
        :n "RET"           #'org-sidebar-tree-jump
        :n [tab]           #'org-sidebar-tree-cycle
        :n "TAB"           #'org-sidebar-tree-cycle
        :n [S-tab]         #'org-sidebar-tree-cycle-global
        :n [S-iso-lefttab] #'org-sidebar-tree-cycle-global
        :n [backtab]       #'org-sidebar-tree-cycle-global

        :m "q"             #'org-sidebar-tree-toggle)
  (add-hook! 'org-sidebar-window-after-display-hook #'evil-normalize-keymaps))
#+end_src

** Org super agenda

Configuration and integration with doom.
#+begin_src elisp
(use-package! org-super-agenda
  :config
  (org-super-agenda-mode)
  (setq org-super-agenda-header-prefix "‚óã " ; Needed for outline mode to recognize headings
        org-super-agenda-hide-empty-groups 't
        org-super-agenda-keep-order nil) ; Perf-hungry, enable if noticing sort issues

  ;; Default super-groups.
  (setq org-super-agenda-groups
        '((:auto-outline-path t :order 99))))
#+end_src

Add selector to org-super-agenda.
TODO: Contribute this. Now unused though.
#+begin_src elisp
(after! org-super-agenda
  (org-super-agenda--defgroup outline-path-regexp
    "Group items whose outline path match any of the given regular expressions.
  Argument may be a string or list of strings, each of which should
  be a regular expression.  You'll probably want to override the
  section name for this group."
    :section-name (concat "Outline paths matching regexps: "
                          (s-join " OR "
                                  (--map (s-wrap it "\"")
                                         args)))
    :let* ((case-fold-search t))
    :test (org-super-agenda--when-with-marker-buffer (org-super-agenda--get-marker item)
            (let ((outline-path (s-join "/" (org-get-outline-path))))
              (cl-loop for regexp in args
                       thereis (string-match-p regexp outline-path))))))
#+end_src

Integrate with outline-minor-mode to allow folding agenda days and groups.
#+begin_src elisp
(after! org-super-agenda
  (defvar org-super-agenda-auto-fold-groups '())

  ;; Function borrowed from new fork of origami.el https://github.com/emacs-origami/origami.el/blob/master/origami.el#L1024
  (defun outline-auto-agenda (pattern-or-patterns function)
    "Search buffer and apply the FUNCTION on each line.
PATTERN-OR-PATTERNS is a string or a list of strings to search"
    (interactive)
    (let ((patterns (if (listp pattern-or-patterns) pattern-or-patterns (list pattern-or-patterns))))
      (save-excursion
        (dolist (pattern patterns)
          (goto-char (point-min))
          (while (re-search-forward pattern nil t 1)
            (unless (outline-invisible-p)
              (funcall function)))))))

  (defun outline-agenda-setup ()
    (setq-local outline-regexp "\\([A-Za-z]+\\|‚ãØ\\|‚óã \\)")
    (setq-local outline-level #'outline-level)
    (setq-local outline-blank-line t)
    (setq-local outline-heading-alist
                `(("Monday" . 2)
                  ("Tuesday" . 2)
                  ("Wednesday" . 2)
                  ("Thursday" . 2)
                  ("Friday" . 2)
                  ("Saturday" . 2)
                  ("Sunday" . 2)
                  ("‚ãØ" . 2)
                  (,org-super-agenda-header-prefix . 3)))
    (outline-auto-agenda org-super-agenda-auto-fold-groups #'outline-hide-subtree))

  (add-hook! 'org-agenda-mode-hook #'outline-minor-mode)
  (add-hook! 'org-agenda-finalize-hook #'outline-agenda-setup))
#+end_src

Make outline ellipsis the same than org ellipsis.
#+begin_src elisp
(after! org-super-agenda
  (defvar outline-display-table (make-display-table))
  (set-display-table-slot outline-display-table 'selective-display
                          (vector " " (make-glyph-code ?‚ñæ 'shadow)))
  (defun set-outline-display-table ()
    (setf buffer-display-table outline-display-table))

  (add-hook 'outline-mode-hook 'set-outline-display-table)
  (add-hook 'outline-minor-mode-hook 'set-outline-display-table))
#+end_src

Remap all bindings from org-agenda-mode-map which are not overridden by evil.
- https://github.com/alphapapa/org-super-agenda/issues/50
- https://github.com/noctuid/evil-guide#prevent-text-property-maps-from-overriding-evil
#+begin_src elisp
(after! org-super-agenda
  (setq org-super-agenda-header-map (make-sparse-keymap))
  (map! :map org-super-agenda-header-map
        "q"             #'org-agenda-quit
        "r"             #'org-agenda-redo))

(after! evil-org-agenda
  (map! :map evil-org-agenda-mode-map
        :m "TAB"           #'outline-toggle-children
        :m "<tab>"         #'outline-toggle-children
        :m "<backtab>"     #'outline-hide-body))
#+end_src

** Projectile

Customize general projectile options.
#+begin_src elisp
(after! projectile
  :config
  (setq projectile-track-known-projects-automatically nil
        ;; Open dired when switching projects
        projectile-switch-project-action #'projectile-dired
        ;; Make compilation buffers project-specific
        compilation-buffer-name-function #'projectile-compilation-buffer-name
        compilation-save-buffers-predicate #'projectile-current-project-buffer-p))
#+end_src

Add project name and type in the modeline.
#+begin_src elisp
(defcustom projectile-mode-line-info nil
  "Format for displaying the project in the mode line."
  :type 'sexp)
;; Ensure we can display text properties on this value in the mode line.
;; See (info "(elisp) Mode Line Data") or (info "(elisp) Properties in Mode").
(put 'projectile-mode-line-info 'risky-local-variable t)

(after! projectile
  :config
  ;; Custom projectile modeline format.
  (defun projectile-custom-mode-line ()
    "Report project name and type in the modeline."
    (let ((project-name (projectile-project-name))
          (project-type (projectile-project-type)))
      (format "%s%s"
              (if (not (equal project-name "-"))
                  project-name
                "")
              (if project-type
                  (format ":%s" project-type)
                ""))))
  (setq-default projectile--mode-line nil)
  (setq projectile-mode-line-function 'projectile-custom-mode-line)
  (setq projectile-dynamic-mode-line t)

  ;; Propertize projectile modeline.
  (defun projectile-mode-line-info ()
    "Return the mode line construct for variable `projectile--mode-line'."
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "<mode-line> <down-mouse-1>")
        `(menu-item "" nil
                    :filter ,(lambda (_cmd) (projectile-commander))))
      `(projectile--mode-line
        ("" (:eval (propertize projectile--mode-line
                               'face 'doom-modeline-persp-name
                               'mouse-face 'mode-line-highlight
                               'keymap ',map
                               'help-echo "Projectile project:type, mouse-1: Run projectile-commander"))
         ))))
  (setq projectile-mode-line-info (projectile-mode-line-info))
  (nconc mode-line-misc-info '((projectile-mode ("" projectile-mode-line-info " ")))))
#+end_src

Customize bindings.
#+begin_src elisp
(after! (projectile which-key)
  ;; Remove previous which-key descriptions.
  ;; TODO: Encapsulate in a function and use a regex.
  (cl-delete-if
   (lambda (x)
     (member (car x)
             '(("\\`M-SPC p t\\'")
               ("\\`SPC p t\\'")
               ("\\`M-SPC p g\\'")
               ("\\`SPC p g\\'")
               ("\\`M-SPC p D\\'")
               ("\\`SPC p D\\'")
               ("\\`M-SPC p C\\'")
               ("\\`SPC p C\\'"))))
   which-key-replacement-alist)
  (map! :leader :prefix "p"
        ;; Adapt default bindings
        :desc "List project todos"           "l"   #'magit-todos-list
        :desc "Find test file"               "t"   #'projectile-find-test-file
        :desc "Search project with git grep" "g"   #'counsel-projectile-git-grep
        :desc "Discover projects in folder"  "A"   #'+default/discover-projects
        :desc "Compile in project"           "B"   #'+ivy/project-compile
        :desc "Configure project"            "C"   #'projectile-configure-project
        :desc "Install project"              "I"   #'projectile-install-project
        :desc "Run GDB in project"           "D"   #'projectile-run-gdb
        :desc "Repeat last command"          ";"   #'projectile-repeat-last-command
        ;; Bind additional commands.
        :desc "Find impl/test"               "O"   #'projectile-find-implementation-or-test
        :desc "Replace in project"           "%"   #'projectile-replace
        :desc "Replace regexp in project"    "M-%" #'projectile-replace-regexp
        :desc "Open dired"                   "-"   #'projectile-dired))
#+end_src

** Rainbow identifiers

#+begin_src elisp
(use-package! rainbow-identifiers
  :config
  (setq rainbow-identifiers-choose-face-function 'rainbow-identifiers-cie-l*a*b*-choose-face
        rainbow-identifiers-cie-l*a*b*-lightness 87
        rainbow-identifiers-cie-l*a*b*-saturation 17))
#+end_src

** Scroll on jump

Define a global mode for scroll-on-jump and bind to relevant commands.
Disabled for now, scrolling does not work nicely in org-mode (or when there is folded content in general)
#+begin_src elisp
;; (use-package! scroll-on-jump
;;   :after evil
;;   :hook (doom-first-file . scroll-on-jump-mode)
;;   :config
;;   (setq scroll-on-jump-duration 0.4)

;;   ;; XXX: For some really obscure reason, the order in which these functions
;;   ;; are declared defines which one will actually work. Currently turning off
;;   ;; doesn't work, unless this code is re-evaluated from the emacs instance.
;;   ;; If the turn-off function is declared after the turn-on, then turning on
;;   ;; will similarly not work. Someone help me understand this plz.
;;   (defun scroll-on-jump--turn-off ()
;;     (scroll-on-jump-advice-remove set-mark-command)
;;     (scroll-on-jump-advice-remove goto-last-change)
;;     (scroll-on-jump-advice-remove goto-last-change-reverse)
;;     ;; (scroll-on-jump-advice-remove evil-undo)
;;     ;; (scroll-on-jump-advice-remove evil-redo)
;;     ;; (scroll-on-jump-advice-remove evil-goto-mark)
;;     (scroll-on-jump-advice-remove evil-goto-mark-line)
;;     (scroll-on-jump-advice-remove evil-ex-search-next)
;;     (scroll-on-jump-advice-remove evil-ex-search-previous)
;;     (scroll-on-jump-advice-remove evil-ex-search-forward)
;;     (scroll-on-jump-advice-remove evil-ex-search-backward))
;;   (defun scroll-on-jump--turn-on ()
;;     (scroll-on-jump-advice-add set-mark-command)
;;     (scroll-on-jump-advice-add goto-last-change)
;;     (scroll-on-jump-advice-add goto-last-change-reverse)
;;     ;; (scroll-on-jump-advice-add evil-undo)
;;     ;; (scroll-on-jump-advice-add evil-redo)
;;     ;; (scroll-on-jump-advice-add evil-goto-mark) ; Also triggers on paste - undesired
;;     (scroll-on-jump-advice-add evil-goto-mark-line)
;;     (scroll-on-jump-advice-add evil-ex-search-next)
;;     (scroll-on-jump-advice-add evil-ex-search-previous)
;;     (scroll-on-jump-advice-add evil-ex-search-forward)
;;     (scroll-on-jump-advice-add evil-ex-search-backward))

;;   (define-minor-mode scroll-on-jump-mode
;;     "Minor-mode to animate scroll and recenter when the point jumps."
;;     :group 'scroll-on-jump
;;     :global t
;;     (if scroll-on-jump-mode
;;         (scroll-on-jump--turn-on)
;;       (scroll-on-jump--turn-off))))
#+end_src

** TLDR

Disable font-lock mode in tldr-mode buffers.
#+begin_src elisp
(use-package! tldr
  :config
  (add-hook! tldr-mode '(lambda () (font-lock-mode 0)))
  (map! :leader :prefix "h"
        "h" #'tldr))
#+end_src

** Treemacs

Configure treemacs appearance and behavior.
#+begin_src elisp
(use-package! treemacs
  :init
  (setq doom-themes-treemacs-theme "all-the-icons"
        +treemacs-git-mode 'deferred)
  :config
  (setq treemacs-recenter-after-file-follow 'always)
  (custom-set-faces!
    '(treemacs-root-face :inherit (variable-pitch font-lock-builtin-face))
    '(treemacs-all-the-icons-root-face :inherit font-lock-builtin-face)
    '(treemacs-fringe-indicator-face :inherit cursor)))
#+end_src

Customize bindings.
#+begin_src elisp
(after! treemacs-evil
  (defun treemacs-toggle-node-nested ()
    (interactive)
    (treemacs-toggle-node "0"))
  (defun treemacs-visit-node-nofocus ()
    (interactive)
    (treemacs-visit-node-default "0"))
  (evil-define-key* 'treemacs treemacs-mode-map
    (kbd "h")          #'treemacs-goto-parent-node
    (kbd "l")          #'treemacs-toggle-node
    (kbd "<")          #'treemacs-root-up
    (kbd ">")          #'treemacs-root-down
    (kbd "L")          #'treemacs-toggle-node-nested
    (kbd "C")          #'treemacs-copy-file
    (kbd "M")          #'treemacs-move-file
    (kbd "x")          #'treemacs-delete
    (kbd "<S-return>") #'treemacs-visit-node-nofocus
    (kbd "<M-return>") #'treemacs-peek)
  (map! :map treemacs-mode-map "d" nil "m" nil))
#+end_src

** Undo tree

Customize undo-tree visualizer.
Disabled since I've fallback to undo-fu as undo-tree is too unstable (and slow).
See https://github.com/hlissner/doom-emacs/issues/1407
#+begin_src elisp
;; (use-package! undo-tree
;;   :config
;;   (setq undo-tree-visualizer-diff nil)
;;   :bind (:map evil-normal-state-map
;;          ("U" . undo-tree-visualize)))
#+end_src

** Vterm

Configure vterm buffer naming scheme.
#+begin_src elisp
(use-package! vterm
  :config
  (setq vterm-buffer-name-string "vterm %s"))
#+end_src

** Which-key

Reduce the delay before the which-key buffer is displayed.
#+begin_src elisp
(after! which-key
  (setq which-key-idle-delay 0.5))
#+end_src

Replace =evil-= like prefixes by a unicode symbol to reduce verbosity.
#+begin_src elisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-/:]?\\(?:a-\\)?\\(.*\\)") . (nil . "‚Äπ\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "¬´\\1"))
   ))
#+end_src

** Xclip

#+begin_src elisp
(add-hook! 'tty-setup-hook
  (defun doom-init-clipboard-in-tty-emacs-h ()
    ;; Fix the clipboard in tty Emacs by piping clipboard I/O through xclip,
    ;; xsel, pb{copy,paste}, wl-copy, termux-clipboard-get, or getclip (cygwin);
    ;; depending on what is available.
    (and (require 'xclip nil t)
         (with-demoted-errors "%s" (xclip-mode +1)))))
#+end_src

** YASnippet

Nested snippets are good, enable that.
#+begin_src elisp
(use-package! yasnippet
  :config
  (setq yas-triggers-in-field t))
#+end_src

Rebind auto-yasnippet commands.
#+begin_src elisp
(use-package! auto-yasnippet
  :config
  (map!
   :nvi [C-tab] nil
   (:leader :prefix "c"
    :desc "Expand auto-snippet" "y" #'aya-expand
    :desc "Create auto-snippet" "Y" #'aya-create)))
#+end_src

* Additional packages
:PROPERTIES:
:header-args:elisp: :tangle "packages.el" :comments no
:END:

See the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#package-management][package management instructions]] from the doom documentation.

This file shouldn't be byte compiled.
#+begin_src elisp
;;; packages.el -*- no-byte-compile: t; -*-
#+end_src

** Beacon

[[https://github.com/Malabarba/beacon][This package]] provides a light that follows the cursor so that I don't lose it.
#+begin_src elisp
(package! beacon)
#+end_src

** Centaur tabs

#+begin_src elisp
(package! centaur-tabs :pin "cde3469d77")
#+end_src

** Command logging

[[https://github.com/lewang/command-log-mode][This package]] allows logging of the commands executed by emacs for some or all buffers.
#+begin_src elisp
(package! command-log-mode)
#+end_src

** Elfeed dashboard

[[https://github.com/Manoj321/elfeed-dashboard][This package]] is a frontend for elfeed, similar to mu4e landing page.
#+begin_src elisp
(package! elfeed-dashboard
  :recipe (:host github :repo "Manoj321/elfeed-dashboard"))
#+end_src

** Elfeed goodies

[[https://github.com/algernon/elfeed-goodies][This package]] enhances the elfeed experience.
#+begin_src elisp
(package! ov) ; Required in elfeed for date-separators and entry previews
(package! elfeed-goodies)
#+end_src

** Evil visual mark

[[https://github.com/roman/evil-visual-mark-mode][This package]] displays all the evil markers in the current buffer.
FIXME: Does not support ~evil-delete-marks~.
#+begin_src elisp
(package! evil-visual-mark-mode)
#+end_src

** Evil terminal cursor

[[https://github.com/amosbird/evil-terminal-cursor-changer][This package]] changes the cursor shape based on the current evil mode in terminal.
#+begin_src elisp
(package! evil-terminal-cursor-changer
  ;; HACK Original package is abandoned. This fork greatly simplifies
  ;; and optimizes the implementation by relying on evil-set-cursor.
  :recipe (:host github :repo "amosbird/evil-terminal-cursor-changer"))
#+end_src

** Fasd

[[https://framagit.org/steckerhalter/emacs-fasd][This package]] provides integration with [[https://github.com/clvv/fasd][fasd]].
#+begin_src elisp
(package! fasd)
#+end_src

** Fast scroll

[[https://github.com/ahungry/fast-scroll][This package]] temporarily disables font-lock and switches to a bare-bones
modeline during intense scrolling operations.
#+begin_src elisp
(package! fast-scroll)
#+end_src

** Hydra major mode

[[https://github.com/jerrypnz/major-mode-hydra.el][This package]] allows to create major-mode specific hydras which are bound to the same key.
It also provides pretty-hydra which allows to create hydras with automatically formatted columns.
#+begin_src elisp
(package! major-mode-hydra)
#+end_src

** Hydra posframe

[[https://github.com/Ladicle/hydra-posframe][This package]] is a hydra extension which shows hydra hints on posframe.
#+begin_src elisp
(package! hydra-posframe
  :recipe (:host github :repo "Ladicle/hydra-posframe"))
#+end_src

** Info colors

[[https://github.com/ubolonton/info-colors][This package]] makes info pages nicer to look at with variable pitch fontification + coloring.
#+begin_src elisp
(package! info-colors :pin "47ee73cc19")
#+end_src

** TODO Large files

The [[https://github.com/m00natic/vlfi][/very large files/ mode]] loads large files in chunks, allowing one to open
ridiculously large files.
#+begin_src elisp
;; (package! vlf
;;   :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
;;   :pin "cc02f25337" :disable t)
#+end_src

To make VLF available without delaying startup, just load it in quiet moments.
#+begin_src elisp :tangle yes
;; (use-package! vlf-setup
;;   :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

** Magit delta

[[https://github.com/dandavison/delta/][Delta]] is a git diff syntax highlighter written in rust. The author also wrote a
package to hook this into the magit diff view. This requires the ~delta~ binary.
FIXME: Breaks log view for a particular file with patch (^L characters on commit line)
#+begin_src elisp
(package! magit-delta)
#+end_src

** Org fancy priorities

Disable for now. I find it less clear than the default letters, and it also creates tag alignment issues.
#+begin_src elisp
(package! org-fancy-priorities :disable t)
#+end_src

#+begin_src elisp :tangle yes
;; (after! org-fancy-priorities
;;   (setq org-fancy-priorities-list '("‚Äº" "‚¨Ü" "‚¨á" "‚îÅ")  ; ü†µü†∑ ‚£ø‚£∂‚£§‚£Ä
#+end_src

** Org QL

[[https://github.com/alphapapa/org-ql][This package]] provides a query language for Org files.
#+begin_src elisp
(package! org-ql
  :recipe (:host github :repo "sgleizes/org-ql"))
#+end_src

** Org super agenda

[[https://github.com/alphapapa/org-super-agenda][This package]] groups agenda items into sections, rather than having them all in one big list.
#+begin_src elisp
(package! org-super-agenda)
#+end_src

** Org sidebar

[[https://github.com/alphapapa/org-sidebar][This package]] provides a helpful sidebar for Org mode.
#+begin_src elisp
(package! org-sidebar)
#+end_src

** Rainbow identifiers

[[https://github.com/Fanael/rainbow-identifiers][This package]] provides highlighting of identifiers based on their names.
#+begin_src elisp
(package! rainbow-identifiers)
#+end_src

** Scroll on jump

[[https://gitlab.com/ideasman42/emacs-scroll-on-jump][This package]] allows to control the scrolling on any operation that jumps to a new location.
#+begin_src elisp
(package! scroll-on-jump :recipe
  (:host gitlab
   :repo "ideasman42/emacs-scroll-on-jump"))
#+end_src

** Systemd

[[https://github.com/holomorph/systemd-mode][This package]] provides a major mode for editing systemd unit files.
#+begin_src elisp
(package! systemd :pin "51c148e09a")
#+end_src

** TLDR

[[https://github.com/kuanyui/tldr.el][This package]] provides a [[https://github.com/tldr-pages/tldr][tldr-pages]] client.
#+begin_src elisp
(package! tldr)
#+end_src

** Treemacs icons

[[https://github.com/Alexander-Miller/treemacs/tree/c8f70f119f0deb1100b0d91a0e3c488ffd9cd63b#treemacs-all-the-icons][This package]] provides a treemacs theme using all-the-icons.
#+begin_src elisp
(package! treemacs-all-the-icons)
#+end_src

#+begin_src elisp :tangle yes
(use-package! treemacs-all-the-icons
  :after treemacs)
#+end_src

** Window layouts

[[https://github.com/daichirata/emacs-rotate][This package]] allows rotating between window layouts.
#+begin_src elisp
(package! rotate :pin "091b5ac4fc")
#+end_src

** Xclip

[[https://elpa.gnu.org/packages/xclip.html][This package]] enables clipboard integration in terminal emacs.
#+begin_src elisp
(package! xclip :pin "ef2ad92f31")
#+end_src
