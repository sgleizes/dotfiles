#+title: Doom Emacs Configuration
#+author: St√©phane Gleizes
#+startup: overview
#+property: header-args:elisp :tangle yes :cache yes :results silent :comments link
#+property: header-args :tangle no :results silent

-----

* System setup
** Systemd daemons

To avoid the loads of issues arising when using a single ~emacs~ daemon for both
terminal and graphical frames, I decided to use dedicated daemons for each type
of frame.

To that purpose, I created a systemd /template unit file/, derived from the default
one that ships with ~emacs~:
#+begin_src systemd :tangle ~/.config/systemd/user/emacs@.service :mkdirp yes
[Unit]
Description=Emacs text editor (%i)
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/
PartOf=emacs.target

# This is required to make sure emacs starts after the DE is started.
# Otherwise the server has no XAUTHORITY and clients fail to start (on wayland).
After=plasma-plasmashell.service

[Service]
Type=notify
ExecStart=/usr/bin/emacs --fg-daemon=%i
Nice=-10

# Emacs will exit with status 15 after having received SIGTERM, which
# is the default "KillSignal" value systemd uses to stop services.
SuccessExitStatus=15

# The location of the SSH auth socket varies by distribution, and some
# set it from PAM, so don't override by default.
# Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=graphical-session.target
#+end_src

This unit file is extended by the following /drop-in snippet/ that sets-up the
right environment for ~emacs~ daemons:
#+begin_src systemd :tangle ~/.config/systemd/user/emacs@.service.d/env.conf :mkdirp yes
[Service]
Environment=DOOMDIR=%E/doom
Environment=DOOMLOCALDIR=%h/.local/share/emacs
#+end_src

To define and manage all instances, I use a systemd /target file/:
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.target :mkdirp yes
[Unit]
Description=Emacs text editor daemons
Wants=emacs@terminal.service emacs@graphical.service

[Install]
WantedBy=graphical-session.target
#+end_src

Which is then enabled and started with:
#+begin_src sh
systemctl --user enable --now emacs.target
#+end_src

** Desktop launcher

Since I don't want a new graphical frame to be created every time a file is
opened, I wrote this launcher script to wrap ~emacsclient~:
#+begin_src sh :tangle ~/.local/bin/my/emacs-xclient :tangle-mode (identity #o755)
#!/usr/bin/env bash
# Wrap the emacsclient command to open a new graphical frame if none exist or if
# no files are specified, else open the given files in the most-recent graphical
# frame.

# The command to use to contact the emacs server.
EMACSCLIENT="emacsclient --socket-name graphical"

# Elisp query to find the most recently opened graphical non-child frame.
FRAME_QUERY="car (filtered-frame-list #'(lambda (f) \
  (and (eq (framep f) 'pgtk) \
  (not (frame-parent f)))))"

if [[ ! $* || "$($EMACSCLIENT --eval "($FRAME_QUERY)")" == 'nil' ]]; then
  $EMACSCLIENT --create-frame --no-wait
else
  DISPLAY=$($EMACSCLIENT --eval "(frame-parameter ($FRAME_QUERY) 'display)")
  $EMACSCLIENT --display "${DISPLAY//\"/}" --no-wait "$@"
fi
#+end_src

Let's add a new desktop icon that represents well what ~emacs~ truly is: a black
hole for the mind:
#+attr_html: :class img :alt The doom emacs desktop icon
[[file:./icon/black-hole.png]]

Install the icon:
#+begin_src sh
for size in 16 24 32 48 64 96 128 192 256; do
  orig="./icon/black-hole.png"
  icon="./icon/black-hole-$size.png"
  convert "$orig" -resize "${size}x${size}" "$icon"
  xdg-icon-resource install --size "$size" "$icon" doom-emacs
  rm -f "$icon"
done
#+end_src

The desktop entry must now be modified to use the above script and icon:
#+begin_src conf :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs (Client)
GenericName=Text Editor
Comment=Edit text
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacs-xclient %F
Icon=doom-emacs
Type=Application
Terminal=false
Categories=Development;TextEditor;
StartupNotify=true
StartupWMClass=Emacs
Keywords=emacsclient;
#+end_src

* Doom Modules
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

Doom has this lovely /modular configuration base/ that takes a lot of work out
of configuring Emacs. Each module (when enabled) can provide a list of packages
to install (on ~doom sync~) and configuration to be applied. The modules can
also have flags applied to tweak their behavior.

See the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#modules][doom documentation]] and the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/modules.org][modules appendix]].

** Structure

#+name: init.el
#+begin_src elisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

** Configuration

#+name: doom-config
#+begin_src elisp
literate
(default +bindings +smartparens)
#+end_src

#+name: doom-input
#+begin_src elisp
;;chinese
;;japanese
;;layout                      ; auie,ctsrnm is the superior home row
#+end_src

** Completion

#+name: doom-completion
#+begin_src elisp
;;(company +childframe)              ; the ultimate code completion backend
(corfu +icons +orderless)           ; complete with cap(f), cape and a flying feather!
;;helm                               ; the *other* search engine for love and life
;;ido                                ; the other *other* search engine...
;;(ivy +prescient +icons +childframe)  ; a search engine for love and life
(vertico +icons)        ; the search engine of the future
#+end_src

** Interface

#+name: doom-ui
#+begin_src elisp
;;deft                            ; notational velocity for Emacs
doom                              ; what makes DOOM look the way it does
doom-dashboard                    ; a nifty splash screen for Emacs
;;doom-quit                       ; DOOM quit-message prompts when you quit Emacs
;;(emoji +ascii +github +unicode) ; adds emoji support to Emacs
hl-todo                           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;indent-guides                   ; highlighted indent columns
;;(ligatures +fira)               ; ligatures and symbols to make your code pretty again
;;minimap                         ; show a map of the code on the side
modeline                          ; snazzy, Atom-inspired modeline, plus API
;;nav-flash                       ; blink cursor line after big motions
;;neotree                         ; a project drawer, like NERDTree for vim
ophints                           ; highlight the region an operation acts on
(popup +all +defaults)            ; tame sudden yet inevitable temporary windows
tabs                              ; a tab bar for Emacs
treemacs                          ; a project drawer, like neotree but cooler
unicode                           ; extended unicode support for various languages
vc-gutter                         ; vcs diff in the fringe
vi-tilde-fringe                   ; fringe tildes to mark beyond EOB
window-select                     ; visually switch windows
workspaces                        ; tab emulation, persistence & separate workspaces
;;zen                             ; distraction-free coding or writing
#+end_src

** Editor

#+name: doom-editor
#+begin_src elisp
(evil +everywhere)            ; come to the dark side, we have cookies
file-templates                ; auto-snippets for empty files
fold                          ; (nigh) universal code folding
(format +onsave)              ; automated prettiness
;;god                         ; run Emacs commands without modifier keys
;;lispy                       ; vim for lisp, for people who don't like vim
multiple-cursors              ; editing in many places at once
;;objed                       ; text object editing for the innocent
;;parinfer                    ; turn lisp into python, sort of
rotate-text                   ; cycle region at point between text candidates
snippets                      ; my elves. They type so I don't have to
;;word-wrap                   ; soft wrapping with language-aware indent
#+end_src

** Builtins

#+name: doom-emacs
#+begin_src elisp
(dired +icons)                ; making dired pretty [functional]
electric                      ; smarter, keyword-based electric-indent
(ibuffer +icons)              ; interactive buffer management
undo                          ; persistent, smarter undo for your inevitable mistakes
vc                            ; version-control and Emacs, sitting in a tree
#+end_src

** Terminal

#+name: doom-term
#+begin_src elisp
;;eshell                      ; the elisp shell that works everywhere
;;shell                       ; simple shell REPL for Emacs
;;term                        ; basic terminal emulator for Emacs
vterm                         ; the best terminal emulation in Emacs
#+end_src

** Checkers

#+name: doom-checkers
#+begin_src elisp
syntax                        ; tasing you for every semicolon you forget
(spell +flyspell +enchant)    ; tasing you for misspelling mispelling
;;grammar                     ; tasing grammar mistake every you make
#+end_src

** Tools

#+name: doom-tools
#+begin_src elisp
;;ansible                     ; a crucible for infrastructure as code
;;debugger                    ; FIXME stepping through code, to help you add bugs
;;direnv                      ; be direct about your environment
docker                        ; port everything to containers
editorconfig                  ; let someone else argue about tabs vs spaces
;;ein                         ; tame Jupyter notebooks with emacs
(eval +overlay)               ; run code, run (also, repls)
;;gist                        ; interacting with github gists
lookup                        ; navigate your code and its documentation
lsp                           ; language server protocol
(magit +forge)                ; a git porcelain for Emacs
;;make                        ; run make tasks from Emacs
;;pass                        ; password manager for nerds
pdf                           ; pdf enhancements
;;prodigy                     ; FIXME managing external services & code builders
rgb                           ; creating color strings
taskrunner                    ; taskrunner for all your projects
;;terraform                   ; infrastructure as code
;;tmux                        ; an API for interacting with tmux
;;upload                      ; map local to remote projects via ssh/ftp
#+end_src

** System

#+name: doom-os
#+begin_src elisp
(:if IS-MAC macos)            ; improve compatibility with macOS
;;tty                         ; improve the terminal Emacs experience
#+end_src

** Language support

We can be rather liberal with enabling support for languages as the associated
packages/configuration are (usually) only loaded when first opening an
associated file.

#+name: doom-lang
#+begin_src elisp
;;ada                         ; in strong typing we (blindly) trust
;;agda                        ; types of types of types of types...
;;beancount                   ; mind the GAAP
(cc +lsp)                     ; C/C++/Obj-C madness
;;clojure                     ; java with a lisp
;;common-lisp                 ; if you've seen one lisp, you've seen them all
;;coq                         ; proofs-as-programs
;;crystal                     ; ruby at the speed of c
;;csharp                      ; unity, .NET, and mono shenanigans
data                          ; config/data formats
;;(dart +flutter)             ; paint ui and not much else
;;dhall
;;(dart +flutter)             ; paint ui and not much else
;;elixir                      ; erlang done right
;;elm                         ; care for a cup of TEA?
emacs-lisp                    ; drown in parentheses
;;erlang                      ; an elegant language for a more civilized age
;;ess                         ; emacs speaks statistics
;;factor                      ; for when scripts are stacked against you
;;faust                       ; dsp, but you get to keep your soul
;;fortran                     ; in FORTRAN, GOD is REAL (unless declared INTEGER)
;;fsharp                      ; ML stands for Microsoft's Language
;;fstar                       ; (dependent) types and (monadic) effects and Z3
;;gdscript                    ; the language you waited for
(go +lsp)                     ; the hipster dialect
;;(graphql +lsp)              ; Give queries a REST
;;(haskell +dante)            ; a language that's lazier than I am
;;hy                          ; readability of scheme w/ speed of python
;;idris                       ; a language you can depend on
json                          ; At least it ain't XML
;;janet                       ; Fun fact: Janet is me!
;;(java +meghanada)           ; the poster child for carpal tunnel syndrome
;;javascript                  ; all(hope(abandon(ye(who(enter(here))))))
;;julia                       ; a better, faster MATLAB
;;kotlin                      ; a better, slicker Java(Script)
;;latex                       ; writing papers in Emacs has never been so fun
;;lean                        ; proof that mathematicians need help
;;ledger                      ; an accounting system in Emacs
;;lua                         ; one-based indices? one-based indices
markdown                      ; writing docs for people to ignore
;;nim                         ; python + lisp at the speed of c
;;nix                         ; I hereby declare "nix geht mehr!"
;;ocaml                       ; an objective camel
(org +pretty)                 ; organize your plain life in plain text
;;php                         ; perl's insecure younger brother
;;plantuml                    ; diagrams for confusing people more
;;graphviz                    ; diagrams for confusing yourself even more
;;purescript                  ; javascript, but functional
;;python                      ; beautiful is better than ugly
;;qt                          ; the 'cutest' gui framework ever
;;racket                      ; a DSL for DSLs
;;raku                        ; the artist formerly known as perl6
;;rest                        ; Emacs as a REST client
;;rst                         ; ReST in peace
;;(ruby +rails)               ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;(rust +lsp)                 ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala                       ; java, but good
;;scheme                      ; a fully conniving family of lisps
(sh +lsp)                     ; she sells {ba,z,fi}sh shells on the C xor
;;sml                         ; no, the /other/ ML
;;solidity                    ; do you need a blockchain? No.
;;swift                       ; who asked for emoji variables?
;;terra                       ; Earth and Moon in alignment for performance.
;;web                         ; the tubes
yaml                          ; JSON, but readable
;;zig                         ; C, but simpler
#+end_src

** Applications

#+name: doom-email
#+begin_src elisp
;;(mu4e +org +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src elisp
;;calendar                   ; calendar integration
;;emms                       ; music player
;;everywhere                 ; *leave* Emacs!? You must be joking
;;irc                        ; how neckbeards socialize
;;(rss +org)                 ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src

* Additional packages
:PROPERTIES:
:header-args:elisp: :tangle "packages.el" :comments no
:END:

See the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#package-management][package management instructions]] from the doom documentation.

This file shouldn't be byte compiled.
#+begin_src elisp
;;; packages.el -*- no-byte-compile: t; -*-
#+end_src

** Beacon

[[https://github.com/Malabarba/beacon][This package]] provides a light that follows the cursor so that I don't lose it.
#+begin_src elisp
(package! beacon)
#+end_src

** Command logging

[[https://github.com/lewang/command-log-mode][This package]] allows logging of the commands executed by emacs for some or all buffers.
#+begin_src elisp
(package! command-log-mode)
#+end_src

** Doct

[[https://github.com/progfolio/doct][This package]] provides an alternative, declarative syntax for describing Org capture templates.
#+begin_src elisp
(package! doct)
#+end_src

** Drag-stuff

This package was removed from doom in [[https://github.com/doomemacs/doomemacs/commit/816db4a62addf7ac5e658123ba081069d224d310][this commit]], but I disagree with the reason: I use evil and I need it.
#+begin_src elisp
(package! drag-stuff :pin "6d06d846cd37c052d79acd0f372c13006aa7e7c8")
#+end_src

** Evil terminal cursor

[[https://github.com/amosbird/evil-terminal-cursor-changer][This package]] changes the cursor shape based on the current evil mode in terminal.
#+begin_src elisp
(package! evil-terminal-cursor-changer
  ;; HACK Original package is abandoned. This fork greatly simplifies
  ;; and optimizes the implementation by relying on evil-set-cursor.
  :recipe (:host github :repo "amosbird/evil-terminal-cursor-changer"))
#+end_src

** Evil visual mark

[[https://github.com/roman/evil-visual-mark-mode][This package]] displays all the evil markers in the current buffer.
#+begin_src elisp
(package! evil-visual-mark-mode)
#+end_src

** Fasd

[[https://framagit.org/steckerhalter/emacs-fasd][This package]] provides integration with [[https://github.com/clvv/fasd][fasd]].
#+begin_src elisp
(package! fasd)
#+end_src

** Hydra major mode

[[https://github.com/jerrypnz/major-mode-hydra.el][This package]] allows to create major-mode specific hydras which are bound to the same key.
It also provides pretty-hydra which allows to create hydras with automatically formatted columns.
#+begin_src elisp
(package! major-mode-hydra)
#+end_src

** Hydra posframe

[[https://github.com/Ladicle/hydra-posframe][This package]] is a hydra extension which shows hydra hints on posframe.
#+begin_src elisp
(package! hydra-posframe
  :recipe (:host github :repo "Ladicle/hydra-posframe"))
#+end_src

** Info colors

[[https://github.com/ubolonton/info-colors][This package]] makes info pages nicer to look at with variable pitch fontification + coloring.
#+begin_src elisp
(package! info-colors :pin "47ee73cc19")
#+end_src

** Kaolin themes

#+begin_src elisp
;; (package! kaolin-themes)
#+end_src

#+begin_src elisp :tangle yes
;; (use-package kaolin-themes
;;   :config
;;   (load-theme 'kaolin-valley-dark t)
;;   (kaolin-treemacs-theme))
#+end_src

** TODO Large files

The [[https://github.com/m00natic/vlfi][/very large files/ mode]] loads large files in chunks, allowing one to open
ridiculously large files.
#+begin_src elisp
;; (package! vlf
;;   :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
;;   :pin "cc02f25337" :disable t)
#+end_src

To make VLF available without delaying startup, just load it in quiet moments.
#+begin_src elisp :tangle yes
;; (use-package! vlf-setup
;;   :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

** Magit delta

[[https://github.com/dandavison/delta/][Delta]] is a git diff syntax highlighter written in rust. The author also wrote a
package to hook this into the magit diff view. This requires the ~delta~ binary.
FIXME: Breaks log view for a particular file with patch (^L characters on commit line)
FIXME: Too slow.
#+begin_src elisp
;; (package! magit-delta)
#+end_src

** Org QL

[[https://github.com/alphapapa/org-ql][This package]] provides a query language for Org files.
#+begin_src elisp
(package! org-ql)
#+end_src

** Org super agenda

[[https://github.com/alphapapa/org-super-agenda][This package]] groups agenda items into sections, rather than having them all in one big list.
#+begin_src elisp
(package! org-super-agenda)
#+end_src

** Org sidebar

[[https://github.com/alphapapa/org-sidebar][This package]] provides a helpful sidebar for Org mode.
#+begin_src elisp
(package! org-sidebar)
#+end_src

** Rainbow identifiers

[[https://github.com/Fanael/rainbow-identifiers][This package]] provides highlighting of identifiers based on their names.
#+begin_src elisp
(package! rainbow-identifiers)
#+end_src

** Scroll on jump

[[https://gitlab.com/ideasman42/emacs-scroll-on-jump][This package]] allows to control the scrolling on any operation that jumps to a new location.
#+begin_src elisp
;; (package! scroll-on-jump :recipe
;;  (:host gitlab
;;   :repo "ideasman42/emacs-scroll-on-jump"))
#+end_src

** Systemd

[[https://github.com/holomorph/systemd-mode][This package]] provides a major mode for editing systemd unit files.
#+begin_src elisp
(package! systemd :pin "51c148e09a")
#+end_src

** TLDR

[[https://github.com/kuanyui/tldr.el][This package]] provides a [[https://github.com/tldr-pages/tldr][tldr-pages]] client.
#+begin_src elisp
(package! tldr)
#+end_src

** Treemacs icons

[[https://github.com/Alexander-Miller/treemacs/tree/c8f70f119f0deb1100b0d91a0e3c488ffd9cd63b#treemacs-all-the-icons][This package]] provides a treemacs theme using all-the-icons.
#+begin_src elisp
(package! treemacs-all-the-icons)
#+end_src

#+begin_src elisp :tangle yes
(use-package! treemacs-all-the-icons
  :after treemacs)
#+end_src

** Visual fill column

[[https://codeberg.org/joostkremers/visual-fill-column][This package]] allows for wrapping visual-line-mode buffers at fill-column.
#+begin_src elisp
(package! visual-fill-column)
#+end_src

** Window layouts

[[https://github.com/daichirata/emacs-rotate][This package]] allows rotating between window layouts.
#+begin_src elisp
(package! rotate :pin "091b5ac4fc")
#+end_src

** Xclip

[[https://elpa.gnu.org/packages/xclip.html][This package]] enables clipboard integration in terminal emacs.
#+begin_src elisp
(package! xclip :pin "9ab22517f3f2044e1c8c19be263da9803fbca26a")
#+end_src

* General configuration

Make this file run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).
#+begin_src elisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

** Personal information

Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.
#+begin_src elisp
(setq user-full-name "St√©phane Gleizes"
      user-mail-address "stephane.gleizes@gmail.com")
#+end_src

** Appearance
*** Fonts

Doom exposes five (optional) variables for controlling fonts in Doom, they are:
+ doom-font
+ doom-variable-pitch-font
+ doom-serif-font
+ doom-unicode-font (the fallback font for unicode symbols that your default font doesn‚Äôt support)
+ doom-big-font (used for doom-big-font-mode)
They all accept either a font-spec, font string (=‚ÄùInput Mono-12‚Äù=), or [[https://wiki.archlinux.org/index.php/X_Logical_Font_Description][xlfd font string]].

#+begin_src elisp
(if (and (member "Fira Code" (font-family-list)) 
         (member "Fira Sans" (font-family-list)))
    (setq doom-font (font-spec :family "Fira Code" :size 12)
          doom-variable-pitch-font (font-spec :family "Fira Sans")
          doom-unicode-font (font-spec :family "Iosevka")
          doom-big-font (font-spec :family "Fira Code" :size 18))
  ;; Fallback to DejaVu if Fira fonts are not installed
  (progn (setq doom-font (font-spec :family "DejaVu Sans Mono" :size 12)
               doom-variable-pitch-font (font-spec :family "DejaVu Sans")
               doom-unicode-font (font-spec :family "Iosevka")
               doom-big-font (font-spec :family "DejaVu Sans Mono" :size 18))
         (setq-default line-spacing 0.1)))
#+end_src

Set preferred order for all-the-icons fonts, since some unicode characters override each other.
#+begin_src elisp
(defun maker/font-settings ()
  "Specific overrides for some icons"
  (set-fontset-font t ?ÔÅë "Weather Icons" nil 'prepend)
  (set-fontset-font t ?ÔÅí "Weather Icons" nil 'prepend))
(add-hook 'after-setting-font-hook #'maker/font-settings)
#+end_src

Add a global hydra to change the font-size interactively.
#+begin_src elisp
(after! pretty-hydra
  (setq doom-font-increment 1)

  (pretty-hydra-define +hydra/font-size
    (:separator "‚ïê")
    ("Font size"
     (("+" doom/increase-font-size "increase")
      ("-" doom/decrease-font-size "decrease")
      ("0" doom/reset-font-size "reset"))))

  (map! :leader
        :desc "Adjust font size"
        "-"   #'+hydra/font-size/body))
#+end_src

*** Theme and modeline

#+begin_src elisp
(setq doom-theme 'doom-tomorrow-night)
(delq! t custom-theme-load-path) ; Remove default emacs theme from search path
#+end_src

Make graphical frames slightly transparent. Or not.
#+begin_src elisp
;; (add-to-list 'default-frame-alist
;;              '(alpha . (95 . 95)))
#+end_src

Do not show encoding in the modeline if the value is the default =LF UTF-8=.
#+begin_src elisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (or (eq buffer-file-coding-system 'utf-8-unix)
                          (eq buffer-file-coding-system 'utf-8)))))
(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

*** Dashboard

Customize the splash image of the doom dashboard.
#+begin_src elisp
(setq fancy-splash-image nil
      +doom-dashboard-banner-dir (concat doom-private-dir "banner/")
      +doom-dashboard-banner-file "black-hole.png")
#+end_src

*** Faces

Customize some general faces.
#+begin_src elisp
(defun +maker/graphical-frame-tweaks (frame)
  "Tweak some faces for graphical frames."
  (interactive)
  (when (display-graphic-p frame)
    (custom-set-faces!
      ;; Use hl-line faces that are lighter instead of darker (in dark theme).
      '(hl-line :background "#242628")
      '(solaire-hl-line-face :background "#1d1f21"))))
(add-hook! 'after-make-frame-functions '+maker/graphical-frame-tweaks)
#+end_src

** General settings

Tweak various general settings to more opinionated values.
#+begin_src elisp
(setq-default delete-by-moving-to-trash t  ; Delete files to trash
              x-stretch-cursor t)          ; Stretch cursor to the glyph width

(setq undo-limit 80000000                  ; Raise undo-limit to 80Mb
      mark-ring-max 32                     ; Set mark ring size
      global-mark-ring-max 32              ; Set global mark ring size
      set-mark-command-repeat-pop t        ; Repeat jump to last mark with just C-SPC
      max-mini-window-height 0.25          ; Increase max-height of mini-windows
      auto-save-default t                  ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "‚Ä¶"         ; Unicode ellispis are nicer than "...", and also save precious space
      uniquify-buffer-name-style 'forward  ; Use path to uniquify buffer names
      bookmark-save-flag 1)                ; Save bookmarks every time they are modified

(global-subword-mode 1)                    ; Iterate through CamelCase words

;; Re-enable S-SPC in emacs-pgtk.
;; See https://www.reddit.com/r/emacs/comments/osscfd/pgtk_emacswaylandgnome_no_shiftspace/
(when 'pgtk-initialized
  (setq pgtk-use-im-context-on-new-connection nil))
#+end_src

** General bindings

Customize various general bindings.
#+begin_src elisp
(map! :leader
      (:prefix "h"
               "I" #'Info-goto-emacs-key-command-node
               "K" #'describe-keymap)
      (:prefix "f"
               "n" #'+default/find-in-notes))
#+end_src

** Indentation

Set default values for the various indentation settings.
Even though ~dtrt-indent~ will properly update these by analyzing existing
files, it is still necessary to set the desired value for new files.
#+begin_src elisp
(setq-default tab-width 2
              ;; List of language-specific variables from dtrt-indent
              c-basic-offset          tab-width  ; C/C++/D/PHP/Java/...
              js-indent-level         tab-width  ; JavaScript/JSON
              js2-basic-offset        tab-width  ; JavaScript-IDE
              js3-indent-level        tab-width  ; JavaScript-IDE
              lua-indent-level        tab-width  ; Lua
              perl-indent-level       tab-width  ; Perl
              cperl-indent-level      tab-width  ; Perl
              raku-indent-offset      tab-width  ; Perl6/Raku
              erlang-indent-level     tab-width  ; Erlang
              ada-indent              tab-width  ; Ada
              sgml-basic-offset       tab-width  ; SGML
              nxml-child-indent       tab-width  ; XML
              pascal-indent-level     tab-width  ; Pascal
              typescript-indent-level tab-width  ; Typescript
              ;; Languages that use SMIE-based indent
              sh-basic-offset         tab-width  ; Shell Script
              ruby-indent-level       tab-width  ; Ruby
              enh-ruby-indent-level   tab-width  ; Ruby
              crystal-indent-level    tab-width  ; Crystal (Ruby)
              css-indent-offset       tab-width  ; CSS
              rust-indent-offset      tab-width  ; Rust
              rustic-indent-offset    tab-width  ; Rust
              scala-indent:step       tab-width  ; Scala
              ;; Default fallback
              standard-indent         tab-width
              smie-indent-basic       tab-width)

;; Apply the same indentation setting in helpful buffers than in elisp mode.
(setq-hook! 'helpful-mode-hook
  ;; Emacs' built-in elisp files use a hybrid tab->space indentation scheme
  ;; with a tab width of 8. Any smaller and the indentation will be
  ;; unreadable. Since Emacs' lisp indenter doesn't respect this variable it's
  ;; safe to ignore this setting otherwise.
  tab-width 8
  ;; Fixed indenter that intends plists sensibly.
  lisp-indent-function #'+emacs-lisp-indent-function)
#+end_src

** Terminal

Improve terminal integration. Taken from the ~tty~ module.
#+begin_src elisp
;; Some terminals offer two different cursors: a "visible" static cursor and a
;; "very visible" blinking one. By default, Emacs uses the very visible cursor
;; and will switch back to it when Emacs is started or resumed. A nil
;; `visible-cursor' prevents this.
(setq visible-cursor nil)
#+end_src

Disable minor modes that are undesired in terminal frames.
#+begin_src elisp
(defun +maker/disable-graphical-modes (frame)
  "Disable undesired minor-modes in FRAME (default: selected frame)
if in terminal."
  (interactive)
  (unless (display-graphic-p frame)
    (remove-hook! server-after-make-frame #'centaur-tabs-mode)
    (remove-hook! doom-first-file #'centaur-tabs-mode)
    (remove-hook! doom-first-file #'beacon-mode)
    (remove-hook! doom-first-input #'evil-goggles-mode)
    ;; Since upgrading, the first-file hook seems to trigger before this hook, so I disable the hook manually...
    (centaur-tabs-mode -1)
    (beacon-mode -1)
    (evil-goggles-mode -1)
    (hydra-posframe-mode -1)
    ;; Disable flyspell hooks
    (remove-hook! '(org-mode-hook
                    markdown-mode-hook
                    TeX-mode-hook
                    rst-mode-hook
                    mu4e-compose-mode-hook
                    message-mode-hook
                    git-commit-mode-hook)
      #'flyspell-mode)
    (setq +ligatures-in-modes nil)))
(add-hook! 'after-make-frame-functions '+maker/disable-graphical-modes)
#+end_src

** Frames

Automatically maximize and focus new graphical frames.
#+begin_src elisp
;; Avoid white screen on initial open
;; See https://github.com/doomemacs/doomemacs/issues/2828
(add-to-list 'window-system-default-frame-alist '(x . ((background-color . "#17191a"))))
;; Maximize new frames
(add-to-list 'default-frame-alist '(fullscreen . maximized))

(defun raise-frame-and-give-focus (&optional frame)
  (when (display-graphic-p frame)
    (raise-frame frame)
    (x-focus-frame frame)))
(add-hook 'after-make-frame-functions 'raise-frame-and-give-focus)
#+end_src

** Workspaces

Add an API to create default workspace names for specific applications.
#+begin_src elisp
(defun +workspace--generate-named-id (&optional prefix)
  (or (cl-loop for name in (+workspace-list-names)
               when (string-match-p (format "^%s#[0-9]+$" prefix) name)
               maximize (string-to-number (substring name (+ (length prefix) 1))) into max
               finally return (if max (1+ max)))
      1))
(cl-defun +workspace/rename-frame (name &optional (frame (selected-frame)))
  "Create a blank, new perspective and associate it with FRAME."
  (when persp-mode
    (+workspace/rename (format "%s#%s" name (+workspace--generate-named-id name)))
    (set-frame-parameter frame 'workspace (+workspace-current-name))))
#+end_src

** Windows
*** Settings

Focus the new window on vertical/horizontal splits.
#+begin_src elisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

*** Popups

Customize general popup rules.
#+begin_src elisp
(after! popup
  (set-popup-rules!
    ;; Do not quit buffers in `help-mode', `helpful-mode' from other windows (with ESC).
    '(("^\\*\\([Hh]elp\\|Apropos\\)"
       :slot 2 :vslot -8 :size 0.42 :select t :quit 'current))))
#+end_src

Fix restore of last popup after pressing 'q' from popup buffer.
In +popup/quit-window, popup is not pushed to remember list since it only invokes quit-window (most of the time).
#+begin_src elisp
;; https://github.com/doomemacs/doomemacs/issues/8650
(defun +popup/force-close ()
  "The regular `quit-window' sometimes kills the popup buffer and switches to a
buffer that shouldn't be in a popup. We prevent that by remapping `quit-window'
to this commmand."
  (interactive)
  (+popup/close nil 'force))

;; The regular `quit-window' sometimes kills the popup buffer and switches to a
;; buffer that shouldn't be in a popup; this is prevented by remapping the
;; command in popups:
(define-key +popup-buffer-mode-map [remap quit-window] #'+popup/force-close)
#+end_src

*** Hydra

Add a global hydra for window management.
#+begin_src elisp
(after! pretty-hydra
  (pretty-hydra-define +hydra/window-management
    (:separator "‚ïê" :title (+hydra/title-generator "Window Management" "windows" 53))
    ("Switch"
     (("h" evil-window-left "left")
      ("j" evil-window-down "down")
      ("k" evil-window-up "up")
      ("l" evil-window-right "right"))
     "Swap"
     (("H" +evil/window-move-left "left")
      ("J" +evil/window-move-down "down")
      ("K" +evil/window-move-up "up")
      ("L" +evil/window-move-right "right"))
     "Arrange"
     (("n" evil-window-new "new")
      ("d" +workspace/close-window-or-workspace "delete")
      ("s" evil-window-split "split horiz.")
      ("v" evil-window-vsplit "split vert."))
     "Focus"
     (("o" doom/window-enlargen "enlargen")
      ("mm" doom/window-maximize-buffer "maximize")
      ("ms" doom/window-maximize-horizontally "maximize horiz.")
      ("mv" doom/window-maximize-vertically "maximize vert."))
     "Layout"
     (("r" evil-window-rotate-downwards "rotate down")
      ("R" evil-window-rotate-upwards "rotate up")
      ("\\" rotate-layout "rotate layout")
      ("u" winner-undo "undo")
      ("C-r" winner-redo "redo"))
     "Popup"
     (("p" +popup/other "next")
      ("P" +popup/toggle "toggle")
      ("f" +popup/raise "raise")
      ("F" +popup/buffer "buffer"))
     "Resize"
     (("<" evil-window-decrease-width "-width")
      (">" evil-window-increase-width "+width")
      ("-" evil-window-decrease-height "-height")
      ("+" evil-window-increase-height "+height")
      ("=" balance-windows "balance"))
     "Buffer"
     (("[" previous-buffer "prev")
      ("]" next-buffer "next")
      ("," +vertico/switch-workspace-buffer "switch")
      ("." find-file "find file")))))
#+end_src

*** Bindings

Customize window management bindings.
#+begin_src elisp
(map!
 :nv "]w"          #'evil-window-next
 :nv "[w"          #'evil-window-prev

 :map evil-window-map
 :desc "Window management"
 "SPC"                #'+hydra/window-management/body
 ;; Splitting
 "s"                  nil
 "v"                  nil
 "'"                  #'evil-window-vsplit
 "\""                 #'evil-window-split
 ;; Navigation
 "a"                  #'ace-window
 "]"                  #'evil-window-next
 "["                  #'evil-window-prev
 "<left>"             #'evil-window-left
 "<down>"             #'evil-window-down
 "<up>"               #'evil-window-up
 "<right>"            #'evil-window-right
 ;; Moving windows
 "S-<left>"           #'+evil/window-move-left
 "S-<down>"           #'+evil/window-move-down
 "S-<up>"             #'+evil/window-move-up
 "S-<right>"          #'+evil/window-move-right
 ;; Popups
 "p"                  #'+popup/other        ; Better than C-x p
 "P"                  #'+popup/toggle       ; Alternative to C-`
 "f"                  #'+popup/raise        ; Alternative to C-~
 "F"                  #'+popup/buffer
 ;; Miscellaneous
 "`"                  #'evil-window-mru     ; Consistent with SPC `
 "\\"                 #'rotate-layout       ; From rotate pkg
 "c"                  nil                   ; Confusing, use 'd'
 ;; Remove duplicate window bindings
 "C-_"                nil
 "C-h"                nil
 "C-l"                nil
 "C-j"                nil
 "C-k"                nil
 "C-n"                nil
 "C-p"                nil
 "C-b"                nil
 "C-t"                nil
 "C-s"                nil
 "C-v"                nil
 "C-u"                nil
 "C-S-r"              nil
 "C-S-s"              nil)
#+end_src

** Buffers
*** Commands

Add a command to switch to the window's MRU unreal buffer (i.e. hidden buffer in doom).
#+begin_src elisp
(defun +maker/last-persp-buffer (&optional window count)
  "Get window's last COUNT-th perspective buffer."
  (let* ((buffer (window-buffer window))
         (prev-buffers
          (if persp-mode
              (cl-remove-if-not (lambda (b) (and (persp-contain-buffer-p b)
                                                 (not (eq buffer b))))
                                (window-prev-buffers window)
                                :key #'car)
            (window-prev-buffers))))
    (car (nthcdr (or (- count 1) 0) prev-buffers))))

(defun +maker/switch-to-windows-last-persp-buffer (count)
  "Switch to current window's last COUNT-th perspective buffer."
  (interactive "p")
  (let ((previous-place (+maker/last-persp-buffer nil count)))
    (when previous-place
      (switch-to-buffer (car previous-place))
      (goto-char (car (last previous-place))))))

(defun +maker/last-unreal-buffer (&optional window count)
  "Get window's last COUNT-th unreal buffer."
  (let* ((buffer (window-buffer window))
         (prev-buffers
          (cl-remove-if-not (lambda (b) (and (or (doom-special-buffer-p b)
                                                 (doom-non-file-visiting-buffer-p b))
                                             (not (+doom-dashboard-p b))
                                             (not (buffer-base-buffer b))
                                             (not (eq buffer b))))
                            (window-prev-buffers window)
                            :key #'car)))
    (car (nthcdr (or (- count 1) 0) prev-buffers))))

(defun +maker/switch-to-windows-last-unreal-buffer (count)
  "Switch to current window's last COUNT-th unrealbuffer."
  (interactive "p")
  (let ((previous-place (+maker/last-unreal-buffer nil count)))
    (when previous-place
      (switch-to-buffer (car previous-place))
      (goto-char (car (last previous-place))))))
#+end_src

*** Hydra

Add a global hydra for buffer management.
#+begin_src elisp
(after! pretty-hydra
  (pretty-hydra-define +hydra/buffer-management
    (:hint nil :separator "‚ïê" :title (+hydra/title-generator "Buffer Management" "files-o" 36))
    ("Tabs"
     (("h" +tabs:previous-or-goto "prev")
      ("l" +tabs:next-or-goto "next")
      ("H" centaur-tabs-move-current-tab-to-left "move left")
      ("L" centaur-tabs-move-current-tab-to-right "move right")
      ("j" centaur-tabs-forward-group "next group")
      ("k" centaur-tabs-backward-group "prev group")
      ("g" centaur-tabs-consult-switch-group "switch group"))
     "Switch"
     (("b" +vertico/switch-workspace-buffer "switch")
      ("B" consult-buffer "switch all")
      ("n" evil-buffer-new "new")
      ("x" doom/open-scratch-buffer "scratch")
      ("f" find-file "find file"))
     "Narrowing"
     (("-" doom/toggle-narrow-buffer "toggle" :toggle (buffer-narrowed-p))
      ("w" doom/widen-indirectly-narrowed-buffer "widen indirect" :toggle doom--narrowed-base-buffer))
     "Save"
     (("s" basic-save-buffer "save")
      ("S" evil-write-all "save all")
      ("u" doom/sudo-save-buffer "sudo save")
      ("r" revert-buffer "revert"))
     "Kill"
     (("z" bury-buffer "bury")
      ("d" doom/kill-this-buffer-in-all-windows "kill")
      ("D" doom/kill-other-buffers "kill other")
      ("C-d" doom/kill-all-buffers "kill all")))))
#+end_src

*** Bindings

#+begin_src elisp
(after! pretty-hydra
  ;; Rebind buffer kill to ensure buffer is killed in all windows.
  (map! :g [remap kill-current-buffer] #'doom/kill-this-buffer-in-all-windows)
  ;; New buffer bindings
  ;; TODO: Override which-key descriptions...
  (map! :leader
        :desc "Switch to last buffer"
        "`"   #'+maker/switch-to-windows-last-persp-buffer
        :desc "Switch to last unreal buffer"
        "~"   #'+maker/switch-to-windows-last-unreal-buffer

        :prefix "b"
        :desc "Buffer management"
        "SPC" #'+hydra/buffer-management/body
        :desc "Widen buffer"
        "w"   #'doom/widen-indirectly-narrowed-buffer
        :desc "Switch to last buffer"
        "`"   #'+maker/switch-to-windows-last-persp-buffer
        :desc "Switch to last unreal buffer"
        "~"   #'+maker/switch-to-windows-last-unreal-buffer))
#+end_src

See [[*Centaur tabs][Centaur Tabs]].

** Line numbers

Relative line numbers are fantastic for knowing how far away line numbers are,
then =12 <UP>= gets you exactly where you think.
Sadly, due to the (very) significant performance hit (mainly on scrolling),
they are disabled by default.
#+begin_src elisp
(setq display-line-numbers-type nil)
;; (setq display-line-numbers-type 'relative)
#+end_src

* Package configuration

See the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#configuring-doom][configuration instructions]] from the doom documentation.

** Beacon

#+begin_src elisp
(use-package! beacon
  :config
  ;; Configure appearance and duration settings
  (setq beacon-color 0.7
        beacon-size 24
        beacon-blink-delay 0.2
        beacon-blink-duration 0.2)
  ;; Configure when the beacon should blink
  (setq beacon-blink-when-buffer-changes t
        beacon-blink-when-window-changes t
        beacon-blink-when-focused nil
        beacon-blink-when-window-scrolls nil
        beacon-blink-when-point-moves-horizontally nil
        beacon-blink-when-point-moves-vertically nil)
  (nconc beacon-dont-blink-commands
         '(evil-ex-search-next
           evil-ex-search-previous
           evil-ex-search-forward
           evil-ex-search-backward
           evil-ex-search-word-forward
           evil-ex-search-word-backward))
  ;; Prevent "stuck" beacon on doom dashboard.
  (nconc beacon-dont-blink-major-modes
         '(+doom-dashboard-mode))
  ;; FIXME: Persp-mode must be doing something after the hook that cancels the blink.
  ;; (add-hook! 'persp-activated-functions
  ;;   (defun beacon--on-persp-activate (_target)
  ;;     (beacon-blink-automated)))
  (add-hook! doom-first-file #'beacon-mode))
#+end_src

** Better jumper

Add post-jump hook to show context around point in org-mode.
#+begin_src elisp
(after! better-jumper
  (add-hook! 'better-jumper-post-jump-hook
    (defun +maker/org-better-jumper-visibility ()
      (when (derived-mode-p 'org-mode)
        (org-show-set-visibility 'lineage)))))
#+end_src

Bind better-jumper functions to a doom-like alternative.
#+begin_src elisp
(after! better-jumper
  (map!
   :n "g[" #'better-jumper-jump-backward
   :n "g]" #'better-jumper-jump-forward))
#+end_src

** Calendar

Configure localization settings.
#+begin_src elisp
(after! calendar
  (setq calendar-date-style 'european
        calendar-time-display-form
        '(24-hours ":" minutes
                   (if time-zone " (") time-zone (if time-zone ")"))
        calendar-latitude 44.81537
        calendar-longitude 4.48834
        calendar-location-name "Saint-Pierreville"))
#+end_src

*** Diary

Make holidays, diaries and today's date visible in calendar by default.
#+begin_src elisp
(after! calendar
  (setq calendar-mark-holidays-flag 't
        calendar-mark-diary-entries-flag 't)
  (add-hook! 'calendar-today-visible-hook #'calendar-mark-today))
#+end_src

Adapt sunrise/sunset diary sexp.
#+begin_src elisp
(require 'solar)

;; Sunrise (edits by Eph Zero)
;; Brady Trainor
;; http://stackoverflow.com/questions/22889036/custom-diary-sunrise-function-not-working-autoload-diary-emacs
(defun solar-sunrise-string (date &optional nolocation)
  "String of *local* time of sunrise and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "%s %s (%s de jour)"
     (all-the-icons-wicon "sunrise" :height 1.0 :v-adjust 0)
     (if (car l)
         (concat "Lever du Soleil " (apply 'solar-time-string (car l)))
       "Aucun Lever du Soleil")
     (nth 2 l))))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunrise ()
  "Local time of sunrise as a diary entry.
Accurate to a few seconds."
  (with-no-warnings (defvar date))
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunrise-string date))

;; Sunset
(defun solar-sunset-string (date &optional nolocation)
  "String of *local* time of sunset and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "%s %s"
     (all-the-icons-wicon "sunset" :height 1.0 :v-adjust 0)
     (if (cadr l)
         (concat "Coucher du Soleil " (apply 'solar-time-string (cadr l)))
       "Aucun Coucher du Soleil"))))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunset ()
  "Local time of sunset as a diary entry.
Accurate to a few seconds."
  (with-no-warnings (defvar date))
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunset-string date))
#+end_src

Adapt solar holidays to diary-compatible expressions.
#+begin_src elisp
;;;###diary-autoload
(defun diary-equinoxes-solstices ()
  "Equinoxes/Solstices diary entry."
  (with-no-warnings (defvar displayed-month)
                    (defvar displayed-year))
  (let* ((displayed-month (calendar-extract-month date))
         (displayed-year  (calendar-extract-year  date))
         (event (solar-equinoxes-solstices)))
    (when (calendar-date-equal date (car (car event)))
      (car (cdr (car event))))))
(defun diary-daylight-saving-time ()
  "Daylight Saving Time diary entry."
  (let ((start (calendar-dst-starts (calendar-extract-year date)))
        (end (calendar-dst-ends (calendar-extract-year date))))
    (cond ((calendar-date-equal date start)
           (format "Heure d'√©t√© %s"
                   (solar-time-string
                    (/ calendar-daylight-savings-starts-time (float 60))
                    calendar-standard-time-zone-name)))
          ((calendar-date-equal date end)
           (format "Heure d'Hiver %s"
                   (solar-time-string
                    (/ calendar-daylight-savings-ends-time (float 60))
                    calendar-daylight-time-zone-name))))))
#+end_src

Add support for included diary files.
#+begin_src elisp
(after! calendar
  (setq diary-file "~/.local/share/emacs/etc/diary")
  (add-hook 'diary-list-entries-hook #'diary-include-other-diary-files)
  (add-hook 'diary-list-entries-hook #'diary-sort-entries t)
  (add-hook 'diary-mark-entries-hook #'diary-mark-included-diary-files))
#+end_src

Add a default diary file since I will be using org mode for appointments and other diary entries.
This is a way to keep solar/lunar information available in the calendar.
#+begin_src diary :tangle ~/.local/share/emacs/etc/diary
&%%(diary-sunrise-sunset)
%%(diary-lunar-phases)
%%(diary-equinoxes-solstices)
%%(diary-daylight-saving-time)
#+end_src

*** Holidays

Customize solar/lunar phase names.
#+begin_src elisp
(after! calendar
  (setq lunar-phase-names
        '("üåë Nouvelle Lune"
          "üåì Premier Quartier de Lune"
          "üåï Pleine Lune"
          "üåó Dernier Quartier de Lune")
        solar-n-hemi-seasons
        '("Equinoxe de Printemps"
          "Solstice d'√ât√©"
          "Equinoxe d'Automne"
          "Solstice d'Hiver")))
#+end_src

Customize [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Holiday-Customizing.html][holidays]].
#+begin_src elisp
(after! calendar
  (setq holiday-general-holidays
        ;; Replace most US holidays by french/european holidays
        '((holiday-fixed  1  1    "Nouvel An")
          (holiday-fixed  5  1    "F√™te du Travail")
          (holiday-fixed  5  8    "F√™te de la Victoire")
          (holiday-fixed  5  9    "Jour de l'Europe")
          (holiday-fixed  7 14    "F√™te Nationale")
          (holiday-float  5  0  2 "F√™te Nationale de Jeanne d'Arc et du Patriotisme")
          (holiday-fixed 11 11    "Jour de l'Armistice")
          ;; Selected holidays from other countries
          (holiday-fixed  6 23    "F√™te Nationale (Luxembourg)")
          (holiday-float  1  1  3 "Martin Luther King Day (US)")
          (holiday-float  2  1  3 "President's Day (US)")
          (holiday-fixed  7  4    "Independence Day (US)")
          (holiday-float 11  4  4 "Thanksgiving (US)"))
        ;; Other national/international holidays
        holiday-other-holidays
        '((holiday-fixed  2 14    "F√™te de la Saint-Valentin")
          (holiday-fixed  3  8    "Journ√©e Internationale des Femmes")
          (holiday-fixed  3 17    "F√™te de la Saint-Patrick")
          (holiday-fixed  4  1    "Jour du Poisson d'Avril")
          (holiday-fixed  4 22    "Jour de la Terre")
          (holiday-fixed  5 22    "Journ√©e Internationale de la Biodiversit√©")
          (holiday-float  5  5 -1 "F√™te des Voisins")
          (holiday-sexp  '(if (equal (holiday-easter-etc 49) (holiday-float 5 0 -1 nil))
                              (calendar-nth-named-day 1 0 6 year)
                            (calendar-nth-named-day -1 0 5 year))
                         "F√™te des M√®res")
          (holiday-float  6  0  3 "F√™te des P√®res")
          (holiday-fixed  6 21    "F√™te de la Musique")
          (holiday-float  9  6  4 "F√™te de la Gastronomie") ; Fourth week-end of september
          (holiday-fixed 11 20    "Journ√©e Internationale des droits de l'Enfant"))
        ;; Astral events are converted to diary entries.
        holiday-solar-holidays nil
        ;; Christian holidays
        holiday-christian-holidays
        '((holiday-float  1  0  1 "√âpiphanie")
          (holiday-fixed  2  2    "Chandeleur")
          (holiday-fixed  8 15    "Assomption de Marie")
          (holiday-fixed 11  1    "Toussaint")
          (holiday-fixed 11  2    "Jour des Morts")
          (holiday-advent 0       "Premier dimanche de l'Avent")
          (holiday-fixed 12  6    "Saint-Nicolas")
          (holiday-fixed 12 25    "No√´l")
          (holiday-fixed 12 26    "Saint-√âtienne")
          ;; Easter-related holidays
          (apply 'append
                 (mapcar (lambda (e) (apply 'holiday-easter-etc e))
                         '((-47 "Mardi Gras")
                           (-46 "Mercredi des Cendres")
                           (-14 "Dimanche de la Passion")
                           (-7  "Dimanche des Palmes")
                           (-4  "Mercredi Saint")
                           (-3  "Jeudi Saint")
                           (-2  "Vendredi Saint")
                           (-1  "Samedi Saint")
                           (0   "Dimanche de P√¢ques")
                           (1   "Lundi de P√¢ques")
                           (39  "Ascension")
                           (49  "Pentec√¥te")
                           (50  "Lundi de Pentec√¥te")
                           (56  "F√™te de la Sainte Trinit√©")
                           (60  "Corpus Christi")
                           (68  "F√™te du Sacr√©-C≈ìur")))))
        ;; Other cultures
        holiday-islamic-holidays
        '((holiday-islamic-new-year)
          (holiday-islamic  9  1 "Ramadan Begins")
          (holiday-islamic 10 -1 "Ramadan Ends"))
        holiday-oriental-holidays
        '((holiday-chinese-new-year))
        holiday-hebrew-holidays nil
        holiday-bahai-holidays nil))
#+end_src

*** Bindings

Disable evil-snipe.
#+begin_src elisp
(after! evil-snipe
  (add-to-list 'evil-snipe-disabled-modes 'calendar-mode))
#+end_src

Configure bindings.
#+begin_src elisp
(map! :after calendar
      :map calendar-mode-map
      :n "C-k"    #'calendar-beginning-of-month
      :n "C-j"    #'calendar-end-of-month
      :n "C-h"    #'calendar-beginning-of-week
      :n "C-l"    #'calendar-end-of-week
      :n "C-S-k"  #'calendar-backward-year
      :n "C-S-j"  #'calendar-forward-year
      :n "C-S-h"  #'calendar-backward-month
      :n "C-S-l"  #'calendar-forward-month
      :n "M-k"    #'calendar-beginning-of-month
      :n "M-j"    #'calendar-end-of-month
      :n "M-h"    #'calendar-beginning-of-week
      :n "M-l"    #'calendar-end-of-week
      :n "M-S-k"  #'calendar-backward-year
      :n "M-S-j"  #'calendar-forward-year
      :n "M-S-h"  #'calendar-backward-month
      :n "M-S-l"  #'calendar-forward-month
      :n "C-u"    #'calendar-scroll-right
      :n "C-d"    #'calendar-scroll-left

      :n "r"      #'calendar-redraw
      :n "S"      #'calendar-sunrise-sunset
      :n "M"      #'calendar-lunar-phases
      :n "H"      #'calendar-cursor-holidays
      :n "s"      nil
      :n "ss"     #'calendar-sunrise-sunset
      :n "sm"     #'calendar-lunar-phases
      :n "sh"     #'calendar-cursor-holidays
      :n "sH"     #'calendar-list-holidays

      :n "i"      nil
      :n "id"     #'diary-insert-entry
      :n "iw"     #'diary-insert-weekly-entry
      :n "im"     #'diary-insert-monthly-entry
      :n "iy"     #'diary-insert-yearly-entry
      :n "ia"     #'diary-insert-anniversary-entry
      :n "ib"     #'diary-insert-block-entry
      :n "ic"     #'diary-insert-cyclic-entry
      :n "a"      #'diary-show-all-entries

      :n [return] #'org-calendar-goto-agenda
      :n "RET"    #'org-calendar-goto-agenda

      :leader
      (:prefix-map ("o" . "open")
       :desc "Calendar" "c" #'org-goto-calendar))
#+end_src

** Centaur tabs

Configure centaur-tabs appearance and behavior. Define rules for buffer groups
and restrict buffer list to workspace buffers.
#+begin_src elisp
(use-package! centaur-tabs
  :config
  (setq centaur-tabs-style "bar"
        centaur-tabs-set-bar 'under
        centaur-tabs-height 32
        centaur-tabs-set-icons t
        centaur-tabs-gray-out-icons nil
        centaur-tabs-show-new-tab-button t
        centaur-tabs-cycle-scope 'default
        x-underline-at-descent-line t)
  (centaur-tabs-headline-match)

  ;; Magit buffers now start with a star, so centaur-tabs displays tabs in some buffers without this.
  (add-to-list 'centaur-tabs-excluded-prefixes "*magit")

  ;; Override rules for grouping buffers.
  (defun maker/centaur-tabs-buffer-groups ()
    "`centaur-tabs-buffer-groups' control buffers' group rules.

Group centaur-tabs with mode if buffer is derived from `vterm-mode'
`dired-mode' `org-mode' `magit-mode'.
All buffer name start with * will group to \"Emacs\".
Other buffer group by `centaur-tabs-get-group-name' with project name."
    (list
     (cond
      ((when-let* ((project-name (centaur-tabs-project-name)))
         project-name))
      ((memq major-mode '(magit-process-mode
                          magit-status-mode
                          magit-log-mode
                          magit-file-mode
                          magit-blob-mode
                          magit-blame-mode
                          magit-diff-mode
                          magit-revision-mode
                          magit-stash-mode))
       "Magit")
      ((derived-mode-p 'term-mode 'vterm-mode)
       "Term")
      ((derived-mode-p 'dired-mode)
       "Dired")
      ((memq major-mode '(org-mode 
                          org-src-mode 
                          org-agenda-mode 
                          org-agenda-log-mode 
                          ;; diary-mode
                          ))
       "Org")
      ((and centaur-tabs-custom-buffer-groups
          (funcall centaur-tabs-custom-buffer-groups)))
      ((derived-mode-p 'emacs-lisp-mode) 
       "Elisp")
      ((string-equal "*" (substring (buffer-name) 0 1))
       "Emacs")
      (t
       (centaur-tabs-get-group-name (current-buffer))))))
  (advice-add #'centaur-tabs-buffer-groups :override #'maker/centaur-tabs-buffer-groups))
#+end_src

Add a consult integration for switching tab groups.
#+begin_src elisp
(defun centaur-tabs-consult-switch-group ()
  "Display a list of current buffer groups using consult."
  (interactive)
  (when (featurep 'consult)
    (require 'consult)
    (centaur-tabs-switch-group (consult--read
     (centaur-tabs-get-groups)
     :prompt "Centaur Tabs Groups:"
     :sort nil))))
#+end_src

Provide additional bindings for centaur-tabs functions.
#+begin_src elisp
(after! centaur-tabs
  ;; Remove previous which-key descriptions.
  ;; TODO: Encapsulate in a function and use a regex.
  ;; TODO Move these bindings in a more appropriate, doom-related section
  ;; XXX: Breaks emacs...
  ;; (cl-delete-if
  ;;  (lambda (x)
  ;;    (member (car x)
  ;;            '(("\\`M-SPC b k\\'")
  ;;              ("\\`SPC b k\\'")
  ;;              ("\\`M-SPC b K\\'")
  ;;              ("\\`SPC b K\\'")
  ;;              ("\\`M-SPC b l\\'")
  ;;              ("\\`SPC b l\\'")
  ;;              ("\\`M-SPC b O\\'")
  ;;              ("\\`SPC b O\\'")
  ;;              ("\\`M-SPC b n\\'")
  ;;              ("\\`SPC b n\\'")
  ;;              ("\\`M-SPC b N\\'")
  ;;              ("\\`SPC b N\\'")
  ;;              ("\\`M-SPC b p\\'")
  ;;              ("\\`SPC b p\\'"))))
  ;;  which-key-replacement-alist)

  (map!
   ;; Rebind buffer switching to tab switching commands.
   :g [remap previous-buffer] #'+tabs:previous-or-goto
   :g [remap next-buffer]     #'+tabs:next-or-goto
   ;; Tab manipulation
   :g "C-<next>"    #'+tabs:next-or-goto
   :g "C-<prior>"   #'+tabs:previous-or-goto
   :g "C-M-<next>"  #'centaur-tabs-forward-group
   :g "C-M-<prior>" #'centaur-tabs-backward-group
   :n "gt"          #'+tabs:next-or-goto
   :n "gb"          #'+tabs:previous-or-goto
   :n "gT"          #'centaur-tabs-forward-group
   :n "gB"          #'centaur-tabs-backward-group
   :n "]B"          #'centaur-tabs-forward-group
   :n "[B"          #'centaur-tabs-backward-group
   :g "C-S-<prior>" #'centaur-tabs-move-current-tab-to-left
   :g "C-S-<next>"  #'centaur-tabs-move-current-tab-to-right

   ;; Bind most frequent cycling command to a convenient binding.
   :g "M-[" #'+tabs:previous-or-goto
   :g "M-]" #'+tabs:next-or-goto
   :g "M-{" #'centaur-tabs-move-current-tab-to-left
   :g "M-}" #'centaur-tabs-move-current-tab-to-right

   :leader :prefix "b"
   ;; Buffer group navigation
   :desc "Switch buffer group"   "g" #'centaur-tabs-consult-switch-group
   :desc "Next buffer group"     "j" #'centaur-tabs-forward-group
   :desc "Previous buffer group" "k" #'centaur-tabs-backward-group
   ;; Tab movement
   :desc "Next tab"              "l" #'+tabs:next-or-goto
   :desc "Previous tab"          "h" #'+tabs:previous-or-goto
   :desc "Move tab right"        "L" #'centaur-tabs-move-current-tab-to-right
   :desc "Move tab left"         "H" #'centaur-tabs-move-current-tab-to-left
   ;; Other stuff
   :desc "Kill other buffers"    "D" #'doom/kill-other-buffers
   :desc "Kill all buffers"      "C-d" #'doom/kill-all-buffers
   :desc ""                      "O" nil
   :desc "New empty buffer"      "n" #'evil-buffer-new
   :desc "New empty buffer"      "N" nil
   :desc ""                      "p" nil
   ;; Numbered buffer navigation
   :desc "Select tab 1"          "1" #'centaur-tabs-select-visible-tab
   :desc "Select tab 2"          "2" #'centaur-tabs-select-visible-tab
   :desc "Select tab 3"          "3" #'centaur-tabs-select-visible-tab
   :desc "Select tab 4"          "4" #'centaur-tabs-select-visible-tab
   :desc "Select tab 5"          "5" #'centaur-tabs-select-visible-tab
   :desc "Select tab 6"          "6" #'centaur-tabs-select-visible-tab
   :desc "Select tab 7"          "7" #'centaur-tabs-select-visible-tab
   :desc "Select tab 8"          "8" #'centaur-tabs-select-visible-tab
   :desc "Select tab 9"          "9" #'centaur-tabs-select-visible-tab
   :desc "Select last tab"       "0" #'centaur-tabs-select-end-tab))
#+end_src

** Company

Make aborting completions less annoying.
The ~evil-normal-state-entry-hook~ is triggered when the child frame opens to
describe the selected element (with ~+childframe~), so it can't be used here.
#+begin_src elisp
(after! company
  (add-hook 'evil-insert-state-exit-hook #'company-abort))
#+end_src

** Dired
*** Appearance

Customize general dired appearance.
#+begin_src elisp
(use-package! dired
  :config
  (setq dired-listing-switches "--group-directories-first -lhFG -v -a")
  ;; FIXME: dired--unhide removes text properties! Use revert-buffer to restore them
  (add-hook! (dired-mode dired-hide-details-mode)
    (defun dired-hide-dir-information ()
      (unless dired-hide-details-mode
        (add-to-invisibility-spec 'dired-hide-details-information))))
  ;; Disable evil-snipe as it shadows bindings for some reason.
  (add-hook! dired-mode #'turn-off-evil-snipe-override-mode))
#+end_src

Omit some more files from being listed.
#+begin_src elisp
(use-package! dired-x
  :config
  (setq dired-omit-files (concat dired-omit-files "\\|\\.zwc\\'")))
#+end_src

Fix issues with all-the-icons:
- Use a consistent icon height.
- Disable icons on big folders (too slow).
- Use file-local-name for remote folders.
- Fix refresh issues on some dired operations.
#+begin_src elisp
(after! all-the-icons-dired
  ;; Patch the refesh function with a :height property to fix inconsistent line height.
  (defun all-the-icons-dired--refresh ()
    "Display the icons of files in a dired buffer."
    (all-the-icons-dired--remove-all-overlays)
    ;; Don't display icons in remote folders or if the folder has too many items.
    (if (<= (count-lines (point-min) (point-max)) 150)
        (save-excursion
          (goto-char (point-min))
          (while (not (eobp))
            (when (dired-move-to-filename nil)
              (let ((file (file-local-name (dired-get-filename 'relative 'noerror))))
                (when file
                  (let ((icon (if (file-directory-p file)
                                  (all-the-icons-icon-for-dir file
                                                              :face 'all-the-icons-dired-dir-face
                                                              :height 0.9 :v-adjust all-the-icons-dired-v-adjust)
                                (all-the-icons-icon-for-file file :height 0.9 :v-adjust all-the-icons-dired-v-adjust))))
                    (if (member file '("." ".."))
                        (all-the-icons-dired--add-overlay (point) "  \t")
                      (all-the-icons-dired--add-overlay (point) (concat icon "\t")))))))
            (forward-line 1)))))
  ;; Refresh the icons after some dired operations.
  (advice-add 'dired-add-entry :around #'all-the-icons-dired--refresh-advice)
  (advice-add 'dired-remove-entry :around #'all-the-icons-dired--refresh-advice)
  (advice-add 'dired-unsubdir :around #'all-the-icons-dired--refresh-advice)
  (advice-add 'dired-undo :around #'all-the-icons-dired--refresh-advice))
#+end_src

*** Commands

Add facilities to quickly toggle hidden files and recursive listing.
#+begin_src elisp
(defun dired-switches-all-p (switches)
  "Return non-nil if the string SWITCHES contains -a or --all."
  (dired-check-switches switches "a" "all"))

(defun +dired-toggle-hidden-files ()
  "Toggle hidden files in dired."
  (interactive)
  (dired-sort-other
   (if (dired-switches-all-p dired-actual-switches)
       (replace-regexp-in-string " \\(-a\\|--all\\)" "" dired-actual-switches)
     (concat dired-actual-switches " -a"))))

(defun +dired-toggle-recursive ()
  "Toggle recursive subdirectory listing in dired."
  (interactive)
  (dired-sort-other
   (if (dired-switches-recursive-p dired-actual-switches)
       (replace-regexp-in-string " \\(-R\\|--recursive\\)" "" dired-actual-switches)
     (concat dired-actual-switches " -R"))))
#+end_src

Open marked files in external applications.
#+begin_src elisp
(defun dired-do-open ()
  "Open file(s) in external applications."
  (interactive)
  (let* ((files (dired-get-marked-files)))
    (xdg-open-files files)))

(defun xdg-open-files (files)
  "Open a list of files with xdg-open."
  (dolist (file files)
    (xdg-open file)))

(defun xdg-open (file)
  "Open a file with xdg-open."
  (let ((command (format "nohup xdg-open </dev/null >/dev/null 2>&1 '%s'" file)))
    (shell-command command)))
#+end_src

Subroutine to jump to a standard directory. Totally stolen from ranger.
#+begin_src elisp
(defun +dired-go (path)
  "Go subroutine"
  (interactive
   (list
    (read-char-choice
     "e   : /etc
u   : /usr
d   : /dev
l   : follow directory link
L   : follow selected file
o   : /opt
v   : /var
h   : ~/
m   : /media
M   : /mnt
s   : /srv
r,/ : /
> "
     '(?q ?e ?u ?d ?l ?L ?o ?v ?h ?m ?M ?s ?r ?/))))
  (message nil)
  (let* ((c (char-to-string path))
         (new-path
          (cl-case (intern c)
            (e "/etc")
            (u "/usr")
            (d "/dev")
            (l (file-truename default-directory))
            (L (file-truename (dired-get-filename)))
            (o "/opt")
            (v "/var")
            (h  "~/")
            (m "/media")
            (M "/mnt")
            (s "/srv")
            (r "/")
            (/ "/"))))
    (when (string-equal c "q")
      (keyboard-quit))
    (when (and new-path (file-directory-p new-path))
      (dired new-path))))
#+end_src

Run ediff from marked files in dired.
#+begin_src elisp
(after! dired
  ;; From https://oremacs.com/2017/03/18/dired-ediff/
  (defun +dired-ediff-files ()
    (interactive)
    (let ((files (dired-get-marked-files))
          (wnd (current-window-configuration)))
      (if (<= (length files) 2)
          (let ((file1 (car files))
                (file2 (if (cdr files)
                           (cadr files)
                         (read-file-name
                          "ediff with: "
                          (dired-dwim-target-directory)))))
            (if (file-newer-than-file-p file1 file2)
                (ediff-files file2 file1)
              (ediff-files file1 file2))
            (add-hook 'ediff-after-quit-hook-internal
                      (lambda ()
                        (setq ediff-after-quit-hook-internal nil)
                        (set-window-configuration wnd))))
        (error "no more than 2 files should be marked")))))
#+end_src

*** Hydra

Define a major-mode-hydra.
#+begin_src elisp
(after! dired
  (major-mode-hydra-define dired-mode
    (:color pink :title (+hydra/major-mode-title-generator 'dired-mode 58))
    ("Open"
     (("S-RET" dired-display-file "view other")
      ("M-RET" dired-view-file "view" :color blue)
      ("C-RET" dired-find-file-other-window "open other" :color blue)
      ("F" dired-do-find-marked-files "open marked" :color blue)
      ("o" dired-do-open "open ext")
      ("g" +dired-go "goto"))
     "Display"
     (("u" dired-undo "undo")
      ("r" dired-do-redisplay "redisplay")
      ("M-r" dired-do-redisplay "refresh")
      ("I" dired-maybe-insert-subdir "insert subdir")
      ("K" dired-kill-subdir "kill subdir"))
     "Toggle"
     (("s" dired-sort-toggle-or-edit "sort")
      ("M-i" dired-hide-details-mode "details" :toggle dired-hide-details-mode)
      ("M-v" dired-git-info-mode "git" :toggle dired-git-info-mode)
      ("M-h" +dired-toggle-hidden-files "hidden" :toggle (dired-switches-all-p dired-actual-switches))
      ("M-H" dired-omit-mode "omit-mode" :toggle dired-omit-mode)
      ("M-R" +dired-toggle-recursive "recursive" :toggle (dired-switches-recursive-p dired-actual-switches)))
     "Mark"
     (("m" dired-mark "mark")
      ("U" dired-unmark "unmark")
      ("M-u" dired-unmark-all-marks "unmark all")
      ("t" dired-toggle-marks "toggle"))
     "Basic"
     (("+" dired-create-directory "make dir")
      ("f" dired-create-file "make file")
      ("Y" dired-copy-filename-as-kill "yank")
      ("O" dired-do-chown "chown")
      ("M-g" dired-do-chggrp "chgrp")
      ("M" dired-do-chgmode "chmod"))
     "Organize"
     (("C" dired-do-copy "copy")
      ("R" dired-do-rename "rename")
      ("D" dired-do-delete "delete")
      ("S" dired-do-symlink "symlink")
      ("Z" dired-do-compress "archive")
      ("M-z" dired-do-compress-to "archive to"))
     "Avanced"
     (("i" dired-toggle-read-only "wdired" :color blue)
      ("A" dired-do-find-regexp "find regexp" :color blue)
      ("Q" dired-do-find-regexp-and-replace "replace regexp" :color blue)
      ("e" +dired-ediff-files "ediff" :color blue)
      ("=" dired-diff "diff" :color blue)
      ("!" dired-do-shell-command "shell cmd" :color blue)

      ("q" nil :color blue)
      ("<escape>" nil :color blue)))))
#+end_src

*** Bindings

Customize default bindings.
#+begin_src elisp
(map! :after dired
      :map dired-mode-map
      ;; Prefer to navigate directories horizontally rather than the buffer.
      :n "h"          #'dired-up-directory
      :n "l"          #'dired-find-file
      ;; Rebind variants for opening the current file.
      :n "<C-return>" #'dired-find-file-other-window
      :n "<S-return>" #'dired-display-file
      :n "M-RET"      #'dired-view-file
      ;; Use TAB to fold/unfold as in other modes.
      :n "TAB"        #'dired-hide-subdir
      :n "<tab>"      #'dired-hide-subdir
      :n "<backtab>"  #'dired-hide-all
      ;; Miscellaneous
      :n "u"          #'dired-undo
      :nv "U"         #'dired-unmark
      :m "M-u"        #'dired-unmark-all-marks
      :n "K"          #'dired-kill-subdir
      :n "M-j"        #'dired-goto-subdir
      :n "s"          #'dired-sort-toggle-or-edit
      :n "o"          #'dired-do-open
      :n "f"          #'dired-create-empty-file
      :n "F"          #'dired-do-find-marked-files
      :n "M-g"        #'dired-do-chgrp
      :n "M-c"        #'dired-rsync
      :n "M-z"        #'dired-do-compress-to
      :n "M-r"        #'revert-buffer

      :n "e"          #'+dired-ediff-files
      :n "M-G"        #'+dired-go
      :n "M-i"        #'dired-hide-details-mode
      :n "M-v"        #'dired-git-info-mode
      :n "M-R"        #'+dired-toggle-recursive
      :n "M-h"        #'+dired-toggle-hidden-files
      :n "M-H"        #'dired-omit-mode

      :localleader
      "g"             #'+dired-go
      "d"             #'dired-hide-details-mode
      "i"             #'dired-git-info-mode
      "r"             #'+dired-toggle-recursive
      "h"             #'+dired-toggle-hidden-files
      "H"             #'dired-omit-mode)
#+end_src

** Ediff
*** Settings

Configure general settings.
#+begin_src elisp
(after! ediff
  (setq ediff-autostore-merges 'group-jobs-only
        ediff-make-buffers-readonly-at-startup nil))
#+end_src

Automatically kill unmodified buffers at the end of an ~ediff~ session.
In merge jobs, buffer C is never deleted. However, the side effect of using this
function is that you may not be able to compare the same buffer in two separate
~ediff~ sessions: quitting one of them will delete this buffer in another session
as well.
#+begin_src elisp
(after! ediff
  (setq-default ediff-keep-variants nil)
  (add-hook! 'ediff-cleanup-hook
    (defun ediff-kill-variants ()
      (ediff-janitor nil ediff-keep-variants))))
#+end_src

*** Integration

Disable evil-snipe that overrides some bindings.
#+begin_src elisp
(after! ediff
  (add-hook! ediff-mode #'turn-off-evil-snipe-override-mode))
#+end_src

Disable tabs in ediff buffers.
#+begin_src elisp
(after! ediff
  (add-hook! 'ediff-prepare-buffer-hook
    (defun +maker/ediff-no-tabs ()
      (centaur-tabs-local-mode 1))))
#+end_src

Focus the registry frame when opening the registry.
#+begin_src elisp
(after! ediff
  (add-hook! 'ediff-show-registry-hook
    (defun +maker/focus-ediff-registry ()
      (x-focus-frame (window-frame
		      (ediff-get-visible-buffer-window ediff-registry-buffer))))))
#+end_src

Automatically delete dedicated frames when quitting ~ediff~.
#+begin_src elisp
(after! ediff
  ;; Figure out if the session has a meta buffer during cleanup.
  ;; ediff-cleanup-mess seems to remove all possibilities of figuring that out.
  (defvar ediff--meta-session nil)
  (add-hook! 'ediff-cleanup-hook
    (defun ediff-mark-dedicated-frame-for-deletion ()
      (setq ediff--meta-session ediff-meta-buffer)))
  ;; Delete the current frame if it was dedicated to a simple ediff session.
  ;; This should be done after ediff-cleanup-mess.
  (add-hook! 'ediff-quit-hook :append
    (defun ediff-delete-dedicated-frame ()
      (unless ediff--meta-session
        (ediff-group-delete-dedicated-frame))))
  ;; Delete the current frame when quitting the last session group.
  (add-hook! 'ediff-quit-session-group-hook :append
    (defun ediff-group-delete-dedicated-frame ()
      (unless ediff-meta-session-number
        (when (string-match-p "^ediff#[0-9]+$" (frame-parameter nil 'workspace))
          (delete-frame))))))
#+end_src

Make ediff reveal/hide org-mode elements.
From https://emacs.stackexchange.com/a/21460.
#+begin_src elisp
(after! ediff
  ;; Check for org mode and existence of buffer
  (defun f-ediff-org-showhide (buf command &rest cmdargs)
    "If buffer exists and is orgmode then execute command"
    (when buf
      (when (eq (buffer-local-value 'major-mode (get-buffer buf)) 'org-mode)
        (save-excursion (set-buffer buf) (apply command cmdargs)))))

  (defun f-ediff-org-unfold-tree-element ()
    "Unfold tree at diff location"
    (f-ediff-org-showhide ediff-buffer-A 'org-reveal)
    (f-ediff-org-showhide ediff-buffer-B 'org-reveal)
    (f-ediff-org-showhide ediff-buffer-C 'org-reveal))

  (defun f-ediff-org-fold-tree ()
    "Fold tree back to top level"
    (f-ediff-org-showhide ediff-buffer-A 'hide-sublevels 1)
    (f-ediff-org-showhide ediff-buffer-B 'hide-sublevels 1)
    (f-ediff-org-showhide ediff-buffer-C 'hide-sublevels 1))

  (add-hook 'ediff-select-hook 'f-ediff-org-unfold-tree-element)
  (add-hook 'ediff-unselect-hook 'f-ediff-org-fold-tree))
#+end_src

*** Appearance

Customize default doom-theme faces for ~ediff~.
#+begin_src elisp
(custom-set-faces!
  `(ediff-even-diff-A           :inherit hl-line)
  ;; `(ediff-current-diff-A        :background ,(doom-color 'base3))
  `(ediff-current-diff-A        :inherit region :background "#313233")
  ;; Faces for ancestor buffer
  '(ediff-even-diff-Ancestor    :inherit ediff-even-diff-A)
  '(ediff-odd-diff-Ancestor     :inherit ediff-odd-diff-A)
  '(ediff-current-diff-Ancestor :inherit ediff-current-diff-A)
  ;; Faces for fine differences in current diff region
  ;; FIXME: For some reason, magit faces do not render properly anymore
  ;; NOTE: Green face was made slightly greener to standout more
  '(ediff-fine-diff-A           :inherit magit-diff-our-highlight :background "#493636" :foreground "#cc6666" :weight bold)
  '(ediff-fine-diff-B           :inherit magit-diff-their-highlight :background "#3b422f" :foreground "#b5bd68" :weight bold)
  ;; '(ediff-fine-diff-A           :inherit magit-diff-our-highlight :background unspecified :weight unspecified)
  ;; '(ediff-fine-diff-B           :inherit magit-diff-their-highlight)
  '(ediff-fine-diff-C           :inherit magit-diff-base-highlight)
  `(ediff-fine-diff-Ancestor    :foreground ,(doom-color 'blue) :background ,(doom-blend 'blue 'bg 0.2) :weight bold :extend t))
#+end_src

*** External command

Add a script to start an ~ediff~ session in a new graphical frame.

Note that it depends on a ~+workspace/rename-frame~ function that automatically
generates a unique name for the new perspective (workspace).
#+begin_src sh :tangle ~/.local/bin/my/ediff :tangle-mode (identity #o755)
#!/usr/bin/env bash
# Start an ediff session in a new emacs frame. Inspired by:
# https://gist.github.com/ptrv/0b460291e14a4a3c6372
#
# This script can be used as a `git mergetool` and `git difftool`.
# It automatically detects whether to run a diff/merge session
# and also supports directories.

# Abort if arguments are not provided.
if [ ! ${#} -ge 2 ]; then
  echo >&2 "Usage: ediff <local> <remote> [merged] [base]"
  exit 1
fi

# Process arguments.
LOCAL="$1"
REMOTE="$2"
[[ $3 ]] && MERGED="$3" || MERGED="$REMOTE"
[[ -d $LOCAL && -d $REMOTE ]] && MODE='directories' || MODE='files'

# Determine the emacs command to evaluate.
if [[ $4 && -r $4 ]]; then
  BASE="$4"
  EVAL="ediff-merge-$MODE-with-ancestor \"$LOCAL\" \"$REMOTE\" \"$BASE\" nil \"$MERGED\""
elif [[ $REMOTE != "$MERGED" ]]; then
  EVAL="ediff-merge-$MODE \"$LOCAL\" \"$REMOTE\" nil \"$MERGED\""
else
  EVAL="ediff-$MODE \"$LOCAL\" \"$REMOTE\" nil"
fi

# Use a graphical frame except in the console.
if [[ $TERM == 'linux' ]]; then
  EMACSCLIENT_OPTS="--socket-name terminal --tty"
else
  EMACSCLIENT_OPTS="--socket-name graphical --create-frame"
fi

# Run emacsclient.
emacsclient $EMACSCLIENT_OPTS --eval "
  (progn
    (+workspace/rename-frame \"ediff\")
    ($EVAL))"

# Check modified file for unresolved conflicts.
if [[ $MODE == 'files' && $(grep -Ec '^(<<<<<<<|=======|>>>>>>>|####### Ancestor)' "$MERGED") != 0 ]]; then
  MERGEDSAVE=$(mktemp --tmpdir "$(basename "$MERGED").XXXXXXXX")
  cp "$MERGED" "$MERGEDSAVE"
  echo >&2 "Oops! Conflict markers detected in $MERGED"
  echo >&2 "Saved your changes to $MERGEDSAVE"
  exit 1
fi
#+end_src

*** Bindings

Add evil bindings for ~ediff-meta-mode~:
#+begin_src elisp
(defvar evil-collection-ediff-registry-bindings
  '(("j" . ediff-next-meta-item)
    ("n" . ediff-next-meta-item)
    ("k" . ediff-previous-meta-item)
    ("p" . ediff-previous-meta-item)
    ("v" . ediff-registry-action)
    ("q" . ediff-quit-meta-buffer))
  "A list of bindings changed/added in evil-ediff-meta-buffer.")

(defun evil-collection-ediff-meta-buffer-startup-hook ()
  "Place evil-ediff-meta bindings in `ediff-meta-buffer-map'."
  (evil-make-overriding-map ediff-meta-buffer-map 'normal)
  (dolist (entry evil-collection-ediff-registry-bindings)
    (define-key ediff-meta-buffer-map (car entry) (cdr entry)))
  (evil-normalize-keymaps)
  nil)

(defun evil-collection-ediff-meta-buffer-setup ()
  "Initialize evil-ediff-meta-buffer."
  (interactive)
  (evil-set-initial-state 'ediff-meta-mode 'normal)
  (add-hook 'ediff-meta-buffer-keymap-setup-hook 'evil-collection-ediff-meta-buffer-startup-hook))
(evil-collection-ediff-meta-buffer-setup)
#+end_src

** Evil
*** Settings

Customize general evil options.
#+begin_src elisp
(setq evil-want-fine-undo t          ; By default while in insert all changes are one big blob. Be more granular
      evil-move-cursor-back nil      ; Leave cursor in place when exiting insert-mode
      evil-cross-lines t             ; Allow horizontal ops to move to the next line (or not)
      evil-move-beyond-eol t         ; Allow cusor to move one character past the end of the line
      evil-kill-on-visual-paste nil) ; Do not kill replaced text in visual mode
#+end_src

Use drag-stuff.
#+begin_src elisp
  (use-package! drag-stuff
    :defer t)
#+end_src

Enable evil-mode in the minibuffer. Or not.
#+begin_src elisp
;; (use-package! evil-collection
;;   :custom (evil-collection-setup-minibuffer t))
#+end_src

Add a delete operator that does not add to kill-ring.
#+begin_src elisp
(after! evil
  (evil-define-operator evil-black-hole-delete (beg end type)
    (interactive "<R>")
    (evil-delete beg end type ?_)))
#+end_src

*** Extensions

Customize options for evil extensions.
#+begin_src elisp
(after! evil-snipe
  (setq evil-snipe-scope 'line
        evil-snipe-repeat-scope 'visible
        evil-snipe-spillover-scope 'visible
        evil-snipe-smart-case t
        evil-snipe-auto-scroll nil))

(after! evil-embrace
  ;; In case I ever need help again, set this to t.
  (setq evil-embrace-show-help-p nil))

(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src

Fix incompatibility between evil-mc and evil-move-cursor-back.
TODO: Contribute this.
#+begin_src elisp
(after! evil-mc
  (defun evil-mc-execute-evil-change ()
    "Execute an `evil-change' command."
    (let ((point (point)))
      (evil-with-state normal
        (unless (or (not evil-move-cursor-back) ; NOTE: EDIT
                    (and region (< (evil-mc-get-region-mark region)
                                   (evil-mc-get-region-point region)))
                    (eq point (point-at-bol)))
          (evil-forward-char 1 nil t))
        (evil-mc-execute-with-region-or-macro 'evil-change)
        (evil-maybe-remove-spaces nil)))))
#+end_src

*** Commands

Add a command to duplicate the current line or region.
Implementation is greatly inspired by drag-stuff.
#+begin_src elisp
(defun duplicate-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (let (beg end (origin (point)))
    (let* ((markp mark-active)
           (evilp (when markp (and (bound-and-true-p evil-mode) (evil-visual-state-p))))
           (vtype (when markp (if evilp (evil-visual-type) nil)))
           (mark-line (when markp (line-number-at-pos (if evilp evil-visual-mark (mark)))))
           (point-line (when markp (line-number-at-pos (if evilp evil-visual-point (point)))))
           (mark-col (when markp (if evilp
                                     (save-mark-and-excursion (goto-char evil-visual-mark) (current-column))
                                   (save-mark-and-excursion (exchange-point-and-mark) (current-column)))))
           (point-col (when markp (if evilp
                                      (save-mark-and-excursion (goto-char evil-visual-point) (current-column))
                                    (current-column))))
           (bounds (when markp
                     (let (beg end)
                       (cond (evilp
                              (setq beg (save-mark-and-excursion (goto-char (region-beginning)) (line-beginning-position)))
                              (setq end (save-mark-and-excursion (evil-visual-goto-end) (line-end-position))))
                             (t
                              (if (> (point) (mark))
                                  (exchange-point-and-mark))
                              (setq beg (line-beginning-position))
                              (if mark-active
                                  (exchange-point-and-mark))
                              (setq end (line-end-position))))
                       (list beg end))))
           (beg (if markp (car bounds) (line-beginning-position)))
           (end (if markp (car (cdr bounds)) (line-end-position)))
           (region (buffer-substring-no-properties beg end))
           (deactivate-mark nil))

      ;; Duplicate line/region
      (dotimes (i arg)
        (goto-char end)
        (newline)
        (insert region)
        (setq end (point)))

      ;; Restore region
      (if markp
          (progn
            (goto-line mark-line)
            (move-to-column mark-col)
            (exchange-point-and-mark)
            (goto-line point-line)
            (move-to-column point-col)
            (when evilp
              (evil-visual-make-selection (mark) (point))
              (when (eq vtype 'line) (evil-visual-line (mark) (point)))))
        (goto-char origin)))))
#+end_src

Rework narrow operator.
#+begin_src elisp
(after! evil
;;   (defun doom/narrow-buffer-indirectly (beg end)
;;     "Restrict editing in this buffer to the current region, indirectly.

;; This recursively creates indirect clones of the current buffer so that the
;; narrowing doesn't affect other windows displaying the same buffer. Call
;; `doom/widen-indirectly-narrowed-buffer' to undo it (incrementally).

;; Inspired from http://demonastery.org/2013/04/emacs-evil-narrow-region/"
;;     (interactive
;;      (list (when (region-active-p) (or (bound-and-true-p evil-visual-beginning) (region-beginning)))
;;            (when (region-active-p) (or (bound-and-true-p evil-visual-end)       (region-end)))))
;;     (message "%s/%s" beg end)
;;     (unless (and beg end)
;;       (setq beg (line-beginning-position)
;;             end (line-end-position)))
;;     (deactivate-mark)
;;     (let ((orig-buffer (current-buffer)))
;;       (with-current-buffer (switch-to-buffer (clone-indirect-buffer nil nil))
;;         (narrow-to-region beg end)
;;         (setq-local doom--narrowed-base-buffer orig-buffer))))

  (defun narrow-to-region-indirect (beg end)
    "Restrict editing in this buffer to the current region, indirectly."
    (interactive "r")
    (deactivate-mark)
    (let ((orig-buffer (current-buffer))
          (buf (clone-indirect-buffer nil nil)))
      (with-current-buffer buf
        (narrow-to-region beg end))
      (switch-to-buffer buf)
      (setq-local doom--narrowed-base-buffer orig-buffer)))

  (evil-define-operator +evil:narrow-buffer (beg end)
    "Narrow the buffer to region between BEG and END."
    :move-point nil
    (interactive "<r>")
    (narrow-to-region beg end))

  ;; FIXME: When called with region and prefix, the face for the region stays stuck even though region is deactivated.
  ;; This does not happen when calling 'doom/narrow-buffer-indirectly' directly
  (evil-define-operator +evil:narrow-buffer-indirect (beg end)
    "Narrow the buffer to region between BEG and END, indirectly."
    :move-point nil
    (interactive "<r>")
    (narrow-to-region-indirect beg end)))
#+end_src

Smarter behavior for yank-pop.
Inspired from https://karthinks.com/software/a-better-yank-pop-binding/
#+begin_src elisp
(defun maker/kill-ring-or-yank-pop (&optional arg)
  "Call `+default/yank-pop'. If called after a yank, call `yank-pop' instead."
  (interactive "*p")
  (cond ((eq last-command 'yank)
         (yank-pop arg))
        ((memq last-command '(evil-paste-after
                              evil-paste-before
                              evil-visual-paste))
         (evil-paste-pop arg))
        (t (+default/yank-pop))))
#+end_src

*** Hydra

Replace evil-mc bindings by a convenient hydra.
#+begin_src elisp
(after! pretty-hydra
  (defhydra evil-mc-hydra
    (:color pink
     :hint nil
     :pre (evil-mc-pause-cursors)
     :post (evil-mc-resume-cursors))
    "

                       ü§Ø Multiple Cursors

 ^Match^            ^Line-wise^                 ^Manual^
‚ïê^‚ïê^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^‚ïê^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê^‚ïê^‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 _a_: match all     _J_: make & go down         _z_: toggle here
 _m_: make & next   _K_: make & go up           _r_: remove last/region
 _M_: make & prev   _I_: make in region (beg)   _R_: remove all
 _n_: skip & next   _A_: make in region (end)   _p_: pause/resume
 _N_: skip & prev

Current pattern: %`evil-mc-pattern
"
    ("a" #'evil-mc-make-all-cursors)
    ("m" #'evil-mc-make-and-goto-next-match)
    ("M" #'evil-mc-make-and-goto-prev-match)
    ("n" #'evil-mc-skip-and-goto-next-match)
    ("N" #'evil-mc-skip-and-goto-prev-match)
    ("J" #'evil-mc-make-cursor-move-next-line)
    ("K" #'evil-mc-make-cursor-move-prev-line)
    ("I" #'evil-mc-make-cursor-in-visual-selection-beg :color blue)
    ("A" #'evil-mc-make-cursor-in-visual-selection-end :color blue)
    ("z" #'+multiple-cursors/evil-mc-toggle-cursor-here)
    ("r" #'+multiple-cursors/evil-mc-undo-cursor)
    ("R" #'evil-mc-undo-all-cursors)
    ("p" #'+multiple-cursors/evil-mc-toggle-cursors)
    ("q" nil :color blue)
    ("<escape>" nil :color blue)))
#+end_src

*** Bindings

Provide more consistent navigation bindings and add missing evil bindings.
Add the missing arrow-key variants of the window navigation commands.
#+begin_src elisp
(map!
 ;; Bind missing evil bindings
 :m "<backspace>"     #'evil-black-hole-delete
 :nv "gX"             #'evil-exchange-cancel
 :nv "god"            #'evil-quick-diff
 :nv "goD"            #'evil-quick-diff-cancel
 :textobj "b"         #'evil-textobj-anyblock-inner-block #'evil-textobj-anyblock-a-block
 :textobj "B"         nil nil
 ;; Bind undo in visual mode (undo in region)
 :v "u"               #'evil-undo
 ;; Customize RET behavior for normal/insert modes
 :i "S-<return>"      #'newline-and-indent ;; NOTE: Difference with default-indent-new-line is not clear
 :n "S-<return>"      #'newline-and-indent
 ;; Rebind fold commands
 :m "TAB"             #'+fold/toggle
 :m "<tab>"           #'+fold/toggle
 :m "<backtab>"       #'+fold/close-all
 :m "C-<iso-lefttab>" #'+fold/open-all
 ;; Rebind macro command, q is for quitting.
 :n "q"               nil
 :n "zq"              #'evil-record-macro
 ;; Use M-/ to toggle comments (M-; for comment-dwim), rebind dabbrev-expand
 :nv "M-/"            #'evilnc-comment-or-uncomment-lines
 :g  "C-/"            #'dabbrev-expand
 ;; Rebind evil-lion to ga (align) to avoids gl conflicts with org-mode
 :nv "ga"             #'evil-lion-left
 :nv "gA"             #'evil-lion-right
 :nv "gl"             nil
 :nv "gL"             nil
 ;; Rebind the most useful, and my only, avy command
 :nv "M-s"            #'evil-avy-goto-char-timer
 ;; Rearrange some narrow/indirect buffer commands
 :nv "zn"             #'+evil:narrow-buffer
 :nv "zN"             #'+evil:narrow-buffer-indirect
 :nv "zw"             #'doom/widen-indirectly-narrowed-buffer
 ;; Rearrange some yank/paste commands
 :n "M-p"             #'maker/kill-ring-or-yank-pop
 :n "C-p"             #'+default/yank-pop
 :n "M-y"             #'duplicate-line-or-region
 (:map evil-mc-key-map
  :nv "C-p" nil
  :nv "C-n" nil)
 ;; Fix inconsistent bindings in eval minibuffer
 (:map read--expression-map
  :g "C-j" #'next-history-element
  :g "C-k" #'previous-history-element
  :g "M-j" #'next-history-element
  :g "M-k" #'previous-history-element)
 ;; Rebind multiple-cursors hydra
 (:when (modulep! :editor multiple-cursors)
  :nv "M-z"             #'evil-mc-hydra/body)
 ;; Use more consistent bindings for workspaces/window navigation
 :m "] TAB"           #'+workspace/switch-right
 :m "[ TAB"           #'+workspace/switch-left
 ;; Bind more motion/editing commands to hjkl
 :i "C-k"             #'evil-previous-line
 :i "C-j"             #'evil-next-line
 :i "C-h"             #'left-char
 :i "C-l"             #'right-char
 :m "C-k"             #'evil-backward-paragraph
 :m "C-j"             #'evil-forward-paragraph
 :m "C-h"             #'evil-backward-word-begin
 :m "C-l"             #'evil-forward-word-begin
 :i "C-S-k"           #'evil-backward-paragraph
 :i "C-S-j"           #'evil-forward-paragraph
 :i "C-S-h"           #'evil-backward-word-begin
 :i "C-S-l"           #'evil-forward-word-begin
 :m "C-S-k"           #'evil-backward-section-end
 :m "C-S-j"           #'evil-forward-section-end
 :m "C-S-h"           #'evil-backward-WORD-begin
 :m "C-S-l"           #'evil-forward-WORD-end
 :g "M-k"             #'drag-stuff-up
 :g "M-j"             #'drag-stuff-down
 :g "M-h"             #'evil-shift-left
 :g "M-l"             #'evil-shift-right
 :g "M-K"             #'drag-stuff-up
 :g "M-J"             #'drag-stuff-down
 :g "M-H"             #'drag-stuff-left
 :g "M-L"             #'drag-stuff-right)
#+end_src

** Evil goggles

Customize evil-goggles visual hints.
#+begin_src elisp
(use-package! evil-goggles
  :config
  (custom-set-faces!
    ;; Just inherit from region, do not override background
    '(evil-goggles-default-face  :background nil)
    ;; Specialize faces
    '(evil-goggles-yank-face  :inherit evil-goggles-default-face)
    '(evil-goggles-paste-face  :inherit custom-state)
    '(evil-goggles-indent-face :inherit custom-modified)
    '(evil-goggles-surround-face :inherit custom-modified)
    '(evil-goggles-change-face :inherit custom-invalid)
    '(evil-goggles-delete-face :inherit custom-invalid))
  ;; Might be annoying for change/delete, keept this here for easy turnoff.
  (setq evil-goggles-enable-delete 't
        evil-goggles-enable-change 't
        evil-goggles-duration 0.15)

  ;; Add custom delete command to the list of commands
  (pushnew! evil-goggles--commands
            '(evil-black-hole-delete
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)))
#+end_src

** Evil terminal cursor

#+begin_src elisp
(add-hook! 'tty-setup-hook #'evil-terminal-cursor-changer-activate)
#+end_src

Override tmux check function as it doesn't seem to work with tmux escape sequences.
#+begin_src elisp
(add-hook! 'after-make-frame-functions
  (defun +maker/fix-etcc-tmux-escape (frame)
    (unless (display-graphic-p frame)
      (defun etcc--in-tmux? () nil))))
#+end_src

** Evil visual mark

Customize, disabled by default for now as I often mistype and set marks unwillingly. Enable as needed.
#+begin_src elisp
;; (use-package! evil-visual-mark-mode
;;   :config
;;   (custom-set-faces!
;;     '(evil-visual-mark-face :weight bold :foreground "#0d0d0d" :background "#de935f"))
;;   (evil-visual-mark-mode)
;; )
#+end_src

** Fasd

#+begin_src elisp
(use-package! fasd
  :config
  (map! :leader
        :desc "Find frecent file" ">" #'fasd-find-file)
  (global-fasd-mode))
#+end_src

** Flyspell

Provide language cycling.
#+begin_src elisp
(defvar-local lang-ring nil
  "The list of available ispell languages.")

(let ((langs '("fr_FR" "en_US")))
  (let ((ring (make-ring (length langs))))
    (dolist (elem langs) (ring-insert ring elem))
    (setq-default lang-ring ring)))

(defun +spell/cycle-languages ()
  "Cycle between ispell languages for the current buffer."
  (interactive)
  (setq-local lang-ring (ring-copy lang-ring))
  (let ((lang (ring-ref lang-ring -1)))
    (ring-insert lang-ring lang)
    (ispell-change-dictionary lang)))

(map! :leader :prefix "n"
      :desc "Cycle ispell languages" "L" #'+spell/cycle-languages)
#+end_src

** Flycheck

Customize flycheck bindings.
#+begin_src elisp
(after! flycheck
  (map! (:leader
         :prefix "c"
         (:prefix ("v" . "Flycheck")
          "v" #'flycheck-verify-setup
          "d" #'flycheck-describe-checker
          "c" #'flycheck-clear
          "h" #'flycheck-display-error-at-point
          "e" #'flycheck-explain-error-at-point
          "s" #'flycheck-select-checker
          "y" #'flycheck-copy-errors-as-kill))

        (:map flycheck-error-list-mode-map
         :n "r" #'flycheck-error-list-check-source
         :n "f" #'flycheck-error-list-set-filter
         :n "F" #'flycheck-error-list-reset-filter))

  ;; Fix golangci-lint not working...
  (setq flycheck-golangci-lint-executable "golangci-lint"))
#+end_src

** Format

Override format-on-save default enabled modes to add emacs-lisp-mode.
#+begin_src elisp
(setq +format-on-save-enabled-modes
      '(not sql-mode         ; sqlformat is currently broken
            tex-mode         ; latexindent is broken
            latex-mode))
#+end_src

*** Go

Disable LSP formatting as it does not currently work well:
- Sometimes deletes text or words at random
- Does not support region formatting
- Overrides format-all configuration
NOTE: Seems to work better now that LSP is properly configured. This is kept in case things go south again.
#+begin_src elisp
;; (after! go-mode
;;   (setq-hook! 'go-mode-hook
;;     +format-with-lsp nil))
#+end_src

Configure ~gofmt~ command to use ~gofumpt~.
#+begin_src elisp
(after! go-mode
  (setq gofmt-command "gofumpt"))
  ;; (setq gofmt-command "gofmt")
  ;;       gofmt-args '("-s")))
#+end_src

*** Shell

Disable ~shfmt~ formatting for zsh buffers (not supported).
#+begin_src elisp
(add-hook! 'sh-set-shell-hook
  (defun +sh-shell-zsh-no-format ()
    (if (string= sh-shell "zsh")
        (setq +format-with :none)
      (setq +format-with nil))))
#+end_src

Redefine the ~shfmt~ formatter with custom flags.
#+begin_src elisp
(after! sh-script
  (set-formatter! 'shfmt
    '("shfmt"
      "-s"   ; simplify the code
      "-bn"  ; binary ops like && and | may start a line
      "-ci"  ; switch cases will be indented
      (unless indent-tabs-mode
        (list "-i" (number-to-string tab-width))))
    :modes '(sh-mode)))
#+end_src

*** Bindings

Map format all global toogle binding and remap flycheck toggle.
#+begin_src elisp
(map! :leader :prefix "t"
      :desc "Format"
      "f" #'apheleia-global-mode
      :desc "Flycheck"
      "v" #'flycheck-mode)
#+end_src

** Go
*** Flycheck

Chain flycheck ~lsp~ checker with ~golangci-lint~ checker.
#+begin_src elisp
(after! flycheck
  (set-next-checker! 'go-mode 'lsp 'golangci-lint))
#+end_src

*** Bindings

Customize go-mode specific bindings.
#+begin_src elisp
(after! go-mode
  (map! :map go-mode-map
        :localleader
        ;; Remove import modification bindings, use goimports/lsp-organize-imports instead
        "r" nil
        ;; Move playground upload to a mnemonic binding
        "e" nil
        "u" #'+go/play-buffer-or-region
        ;; Move tag bindings to a dedicated prefix
        "a" nil
        "d" nil
        (:prefix ("T" . "tag")
         "a" #'go-tag-add
         "d" #'go-tag-remove)
        ;; Move goto bindings to a dedicated prefix
        "i" nil
        (:prefix ("g" . "goto")
         "i" #'go-goto-imports
         "a" #'go-goto-arguments
         "f" #'go-goto-function
         "F" #'go-goto-function-name
         "r" #'go-goto-return-values
         "d" #'go-goto-docstring
         "m" #'go-goto-method-receiver)
        ;; Reorganize guru commands
        (:prefix ("h" . "help")
         "." nil                     ; godoc-at-point is inferior to +lookup/documentation
         "w" nil                     ; go-guru-what command is no longer interactive
         "C" nil
         "P" nil
         "v" nil
         "d" #'go-guru-describe      ; Describe this
         "f" #'go-guru-freevars      ; List free variables
         "i" #'go-guru-implements    ; Implements relations for package types
         "c" #'go-guru-peers         ; List peers for channel
         "r" #'go-guru-referrers     ; List references to object
         "j" #'go-guru-definition    ; Jump to definition
         "p" #'go-guru-pointsto      ; What does this point to
         "s" #'go-guru-callstack     ; Show arbitrary path from program root to this function
         "e" #'go-guru-whicherrs     ; Which errors
         "<" #'go-guru-callers       ; Show callers of this function
         ">" #'go-guru-callees)      ; Show callees of this function
        ;; Bind gofumpt command
        :desc "gofumpt"
        "f" #'gofmt
        ;; Reorganize test commands
        (:prefix ("t" . "test")
         "G" nil
         "e" nil
         (:prefix ("g" . "gen")
          "g" #'go-gen-test-dwim
          "a" #'go-gen-test-all
          "e" #'go-gen-test-exported))
        ;; Reorganize quick go commands
        :desc "go run ." "r" (cmd! (compile "go run ."))
        :desc "go build" "b" (cmd! (compile "go build"))
        :desc "go clean" "c" (cmd! (compile "go clean"))))
#+end_src

** Go Gen Test

Configure ~go-gen-test~ integration.
#+begin_src elisp
(after! go-gen-test
  (setq go-gen-test-open-function 'find-file
        go-gen-test-default-functions "-exported"))
#+end_src

** Hydra major mode

#+begin_src elisp
(use-package! major-mode-hydra
  :after hydra
  :config
  (setq major-mode-hydra-separator "‚ïê"
        major-mode-hydra-title-generator #'+hydra/major-mode-title-generator)

  ;; Title generator for pretty hydras.
  (defun +hydra/title-generator--generic (title &optional icon offset)
    (let ((prefix (when offset (s-repeat offset " ")))
          (icon (when icon (concat icon " "))))
      (s-concat prefix icon title)))

  (defun +hydra/title-generator (title &optional icon offset)
    (+hydra/title-generator--generic
     title
     (all-the-icons-faicon icon :v-adjust 0.05)
     offset))

  (defun +hydra/major-mode-title-generator (mode &optional offset)
    (+hydra/title-generator--generic
     (s-concat (s-capitalized-words (s-chop-suffix "-mode" (symbol-name mode))) " commands")
     (all-the-icons-icon-for-mode mode :v-adjust 0.05)
     offset))

  (map! :map global-map
        :localleader
        :g "SPC" #'major-mode-hydra))
#+end_src

** Hydra posframe

#+begin_src elisp
(use-package! hydra-posframe
  :after hydra
  :config
  (hydra-posframe-mode)
  (setq hydra-posframe-border-width 1
        hydra-posframe-poshandler #'posframe-poshandler-frame-bottom-center
        hydra-posframe-parameters `((left-fringe . 15)
                                    (right-fringe . 15)))

  (custom-set-faces!
    '(hydra-posframe-face :inherit unspecified)
    '(hydra-posframe-border-face :background "gray30")))
#+end_src

** Info colors

#+begin_src elisp
(use-package! info-colors
  :after info
  :hook (Info-selection . info-colors-fontify-node))
#+end_src

** Ligatures

Remove annoying programming ligatures.
#+begin_src elisp
;; (cl-delete-if
;;  (lambda (x)
;;    (member (car x)
;;            '("[]"
;;              "##"
;;              "###"
;;              "####")))
;;  +ligatures-fira-font-alist)
#+end_src

** LSP
*** Settings

Ignore prompts to restart server to avoid hangs on server-restart.
#+begin_src elisp
(after! lsp-mode
  (setq-default lsp-restart 'auto-restart)
  (lsp-enable-which-key-integration t)

  (setq lsp-warn-no-matched-clients nil
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-hover nil
        lsp-ui-sideline-show-code-actions t
        lsp-ui-doc-show-with-cursor nil
        lsp-ui-doc-show-with-mouse t
        lsp-ui-doc-alignment 'window
        lsp-ui-doc-position 'top
        lsp-ui-doc-delay 0.5
        lsp-ui-doc-max-width 80))
#+end_src

*** Go

Configure gopls settings.
#+begin_src elisp
(after! lsp-mode
  (setq lsp-go-symbol-matcher "Fuzzy"
        lsp-go-goimports-local "github.com/sgleizes"
        lsp-go-use-gofumpt t
        lsp-go-analyses
        '((nilness . t))))
#+end_src

Automatically organize imports on save (like goimports but using gopls, much more efficient).
If ~+format-with-lsp~ is disabled and goimports is used, this is not needed.
#+begin_src elisp
(after! lsp-mode
  (add-hook 'go-mode-hook
            (defun +maker/lsp-go-organize-imports-on-save ()
              (add-hook 'before-save-hook #'lsp-organize-imports t t))))
#+end_src

Enable LSP in go.mod files.
#+begin_src elisp
(after! lsp-mode
  (add-hook 'go-dot-mod-mode-hook #'lsp-deferred))
#+end_src

*** Bindings

#+begin_src elisp
(after! lsp-mode
  (map! :leader
        :prefix "c"
        :desc "LSP Codelens"
        "L" #'lsp-avy-lens))
#+end_src

** Magit
*** Settings

Enable gravatars when viewing commits. The service used by default is [[https://www.libravatar.org/][Libravatar]].
#+begin_src elisp
(after! magit
  :config
  (setq git-commit-summary-max-length 72)
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src

*** Commands

Add a magit command for ~push --all~.
#+begin_src elisp
(after! magit
  (defun maker/magit-push-all ()
    "Push all branches."
    (interactive)
    (magit-run-git-async "push" "-v"
                         (magit-read-remote "Remote")
                         "--all"))

  (transient-append-suffix 'magit-push '(2 0 -1)
    '("a" "all branches" maker/magit-push-all)))
#+end_src

*** Yadm

Configure ~yadm~ integration.
#+begin_src elisp
(after! tramp
  (add-to-list 'tramp-methods
               '("yadm"
                 (tramp-login-program "yadm")
                 (tramp-login-args (("enter")))
                 (tramp-login-env (("SHELL") ("/bin/sh")))
                 (tramp-remote-shell "/bin/sh")
                 (tramp-remote-shell-args ("-c")))))

(defun yadm ()
  (interactive)
  ;; HACK: Remove flyspell hook locally as it seems to recurse infinitely here.
  (remove-hook 'hack-local-variables-hook #'flyspell-hack-local-variables-hook t)
  (magit-status "/yadm::"))
#+end_src

Add interactive commands for yadm helper functions.
#+begin_src elisp
(defun yadm-refresh ()
  "Refresh the status of dotfiles having git filters."
  (interactive)
    (shell-command "yadm-refresh"))

(defun yadm-sync ()
  "Synchronize dotfiles master worktree with local changes in HOME."
  (interactive)
    (shell-command "yadm-sync"))

(defun yadm-merge ()
  "Merge dotfiles changes committed on the master worktree."
  (interactive)
    (shell-command "yadm-merge"))
#+end_src

*** Bindings

Customize bindings.
#+begin_src elisp
(map! :leader :prefix "g"
      "m" nil ; unbind smerge hydra - use ediff instad.
      "h" #'yadm)
#+end_src

** Magit delta

Disabled, too slow.
#+begin_src elisp
;; (use-package! magit-delta
;;   :after magit
;;   :config
;;   (setq magit-delta-delta-args
;;         '("--features" "truecolor"
;;           "--max-line-distance" "0.6"
;;           "--24-bit-color" "always"
;;           "--color-only"))
;;   (magit-delta-mode))
#+end_src

** Man/Woman

Configure man/woman and add global bindings.
#+begin_src elisp
(setq woman-fill-column fill-column)
(map! :leader :prefix "h"
      "h" #'woman
      "H" #'man
      "W" nil)
#+end_src

** Org
*** General Settings

Change the default org directory.
#+begin_src elisp
(setq org-directory "~/Notes/")
#+end_src

Configure region behavior for org commands.
#+begin_src elisp
(after! org
  (setq org-loop-over-headlines-in-active-region 'start-level
        org-agenda-loop-over-headlines-in-active-region 't
        org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

Configure the context shown when revealing an org heading.
#+begin_src elisp
(setq org-show-context-detail
      '((agenda . ancestors)
        (bookmark-jump . lineage)
        (isearch . lineage)
        (default . ancestors)))
#+end_src

Enable auto-revert in org mode buffers to avoid too many syncthing conflicts.
#+begin_src elisp
(after! org
  (add-hook! org-mode #'auto-revert-mode))
#+end_src

Remove the org-encrypt-entries hook that sometimes freezes emacs on save.
https://github.com/kaushalmodi/ox-hugo/issues/487
#+begin_src elisp
(after! org
  (add-hook! 'org-mode-hook :append
    (remove-hook 'before-save-hook 'org-encrypt-entries t)))
#+end_src

*** Document Structure

Configure the behavior of M-RET and friends, and ensure that headings are terminated by blank lines.
#+begin_src elisp
(after! org
  (setq org-insert-heading-respect-content nil
        org-M-RET-may-split-line '((default . t))
        org-blank-before-new-entry
        '((heading . always)
          (plain-list-item . nil))))
#+end_src

Patch doom's org-insert-item variant to better respect blank settings.
#+begin_src elisp
(after! org
  (defun maker/+org--insert-item (direction)
    (let ((context (org-element-lineage
                    (org-element-context)
                    '(table table-row headline inlinetask item plain-list)
                    t)))
      (pcase (org-element-type context)
        ;; Add a new list item (carrying over checkboxes if necessary)
        ((or `item `plain-list)
         (let ((orig-point (point)))
           ;; Position determines where org-insert-todo-heading and `org-insert-item'
           ;; insert the new list item.
           (if (eq direction 'above)
               (org-beginning-of-item)
             (end-of-line))
           (let* ((ctx-item? (eq 'item (org-element-type context)))
                  (ctx-cb (org-element-property :contents-begin context))
                  ;; Hack to handle edge case where the point is at the
                  ;; beginning of the first item
                  (beginning-of-list? (and (not ctx-item?)
                                           (= ctx-cb orig-point)))
                  (item-context (if beginning-of-list?
                                    (org-element-context)
                                  context))
                  ;; Horrible hack to handle edge case where the
                  ;; line of the bullet is empty
                  (ictx-cb (org-element-property :contents-begin item-context))
                  (empty? (and (eq direction 'below)
                               ;; in case contents-begin is nil, or contents-begin
                               ;; equals the position end of the line, the item is
                               ;; empty
                               (or (not ictx-cb)
                                   (= ictx-cb
                                      (1+ (point))))))
                  (pre-insert-point (point)))
             ;; Insert dummy content, so that `org-insert-item'
             ;; inserts content below this item
             (when empty?
               (insert " "))
             (org-insert-item (org-element-property :checkbox context))
             ;; Remove dummy content
             (when empty?
               (delete-region pre-insert-point (1+ pre-insert-point))))))
        ;; Add a new table row
        ((or `table `table-row)
         (pcase direction
           ('below (save-excursion (org-table-insert-row t))
                   (org-table-next-row))
           ('above (save-excursion (org-shiftmetadown))
                   (+org/table-previous-row))))

        ;; Otherwise, add a new heading, carrying over any todo state, if
        ;; necessary.
        (_
         (let ((level (or (org-current-level) 1)))
           ;; I intentionally avoid `org-insert-heading' and the like because they
           ;; impose unpredictable whitespace rules depending on the cursor
           ;; position. It's simpler to express this command's responsibility at a
           ;; lower level than work around all the quirks in org's API.
           (pcase direction
             (`below
              (let (org-insert-heading-respect-content
                    (blank? (org--blank-before-heading-p))) ; NOTE: EDIT
                (goto-char (line-end-position))
                (org-end-of-subtree)
                ;; NOTE: BEGIN: Respect blank settings, at least when inserting headlines below.
                (when (and blank? (org-next-line-empty-p))
                  (forward-line))
                (insert "\n" (make-string level ?*) " ")))
             ;; NOTE: END
             (`above
              (org-back-to-heading)
              (insert (make-string level ?*) " ")
              (save-excursion (insert "\n"))))
           (when-let* ((todo-keyword (org-element-property :todo-keyword context))
                       (todo-type    (org-element-property :todo-type context)))
             (org-todo
              (cond ((eq todo-type 'done)
                     ;; Doesn't make sense to create more "DONE" headings
                     (car (+org-get-todo-keywords-for todo-keyword)))
                    ;; NOTE: Do not carry over the current todo state.
                    ;; (todo-keyword)
                    ('todo)))))))

      (when (org-invisible-p2) ; NOTE: EDIT: Use org-invisible-p2 instead of org-invisible
        (org-fold-show-hidden-entry))
      (when (and (bound-and-true-p evil-local-mode)
                 (not (evil-emacs-state-p)))
        (evil-insert 1))))
  (advice-add #'+org--insert-item :override #'maker/+org--insert-item))
#+end_src

Add functions to move to prev/next (potentially invisible) heading
#+begin_src elisp
(after! org
  (defun +maker/org-previous-heading (arg)
    "Move to the previous (potentially invisible) heading.
With ARG, repeats or can move forward if negative."
    (interactive "p")
    (outline-previous-heading)
    (org-show-set-visibility 'minimal))
  (defun +maker/org-next-heading (arg)
    "Move to the next (potentially invisible) heading.
With ARG, repeats or can move forward if negative."
    (interactive "p")
    (outline-next-heading)
    (org-show-set-visibility 'minimal)))
#+end_src

Advise org heading insert commands to enter evil insert mode.
#+begin_src elisp
(after! org
  (defadvice! +maker/evil-insert-mode (&rest _)
    :after (list #'org-ctrl-c-ret
                 #'org-insert-heading
                 #'org-insert-subheading
                 #'org-insert-todo-heading
                 #'org-insert-todo-subheading)
    (when (and (bound-and-true-p evil-local-mode)
               (not (evil-emacs-state-p)))
      (evil-insert 1))))
#+end_src

Add helper function to help with blank line consistency.
#+begin_src elisp
(defun +org/fix-blank-lines (&optional arg)
  "Ensure that blank lines exist between headings and between headings and their contents.
With prefix, operate on whole buffer. Ensures that blank lines
exist after each headings's drawers."
  (interactive "P")
  (org-map-entries (lambda ()
                     (org-with-wide-buffer
                      ;; `org-map-entries' narrows the buffer, which prevents us from seeing
                      ;; newlines before the current heading, so we do this part widened.
                      (when (and (forward-line -1) (not (org-at-heading-p)) (forward-line))
                        (while (not (looking-back "\n\n" nil))
                          ;; Insert blank lines before heading.
                          (insert "\n"))))
                     (let ((end (org-entry-end-position)))
                       ;; Insert blank lines before entry content
                       (forward-line)
                       (while (and (org-at-planning-p)
                                   (not (looking-at-p "\n"))
                                   (< (point) (point-max)))
                         ;; Skip planning lines
                         (forward-line))
                       (while (re-search-forward org-drawer-regexp end t)
                         ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
                         ;; for some reason it doesn't work correctly when operating on hidden text.
                         ;; This works, taken from `org-agenda-get-some-entry-text'.
                         (re-search-forward "^[ \t]*:END:.*\n?" end t)
                         (goto-char (match-end 0)))
                       (unless (or (= (point) (point-max))
                                   (org-at-heading-p)
                                   (looking-at-p "\n"))
                         (insert "\n"))))
                   t (unless arg 'tree)))
#+end_src

*** TODO-items & Checkboxes

Define todo workflows and associated faces.
Use ~#+TODO~ (or ~#+SEQ_TODO~ / ~#+TYP_TODO~) to define per-file keywords
#+begin_src elisp
(after! org
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"          ; A task that needs doing & is ready to do
           "ACTV(a!)"         ; A task that is active/in progress
           "WAIT(w@/!)"       ; A task that is waiting on something external
           "HOLD(h@/!)"       ; A task that is paused/on hold because of me
           "|"
           "DONE(d!/!)")      ; Task successfully completed
          (sequence
           "IDEA(i)"          ; A captured task or project that must be processed and is not yet ready to do
           "SMDY(s)"          ; A task or project that could be done someday, but should not appear in dashboards
           "PROJ(p)"          ; A project, which usually contains other tasks/subprojects
           "|"
           "DONEPROJ(d)")
          (sequence
           "|"
           "CANCELED(c@/!)")) ; Task was aborted or is no longer applicable
        org-todo-keyword-faces
        '(("ACTV" . +org-todo-active)
          ("WAIT" . +org-todo-onhold)
          ("HOLD" . +org-todo-onhold)
          ("SMDY" . +org-todo-onhold)
          ("IDEA" . +org-todo-idea)
          ("PROJ" . +org-todo-project)))
  (custom-declare-face '+org-todo-idea '((t (:inherit (bold org-drawer org-todo)))) "")
  (custom-set-faces!
    '(+org-todo-active :inherit (bold font-lock-constant-face org-todo))
    '(+org-todo-onhold :inherit (bold warning org-todo))
    '(+org-todo-idea :inherit (bold org-formula org-todo))
    '(+org-todo-project :inherit (bold org-priority org-todo))))
#+end_src

Prefer using the ~LOGBOOK~ drawer rather than a CLOSED: entry (~org-log-done~).
#+begin_src elisp
(after! org
  (setq org-log-done nil
        org-log-repeat 'time        ; Ensure that a timestamp is logged when repeating
        org-log-redeadline 'note    ; Ask to record a note when rescheduling a deadline
        org-todo-repeat-to-state 't ; Repeat tasks to the previous state
        org-log-into-drawer "LOGBOOK"))
#+end_src

Block headings from changing to DONE if they have TODO headings that are not DONE.
#+begin_src elisp
(after! org
  (setq org-enforce-todo-dependencies 't
        org-enforce-todo-checkbox-dependencies nil))
#+end_src

Set statistics cookies to be recursive by default.
Set the ~COOKIE_DATA~ property to ~todo~ or ~checkbox~ to resolve conflicts, and
add ~recursive~ to keep the recursive behavior.
#+begin_src elisp
(after! org
  (setq org-hierarchical-todo-statistics nil
        org-checkbox-hierarchical-statistics nil))
#+end_src

Automatically change TODO item with a stats cookie to DONE when children are done.
Unfortunately it does not appear to work with checkboxes.
It also inconveniently switches headlines with no subtasks to DONE.
Kept for reference, but is probably a bad idea.
#+begin_src elisp
;; (after! org
;;   (defun org-todo-done-when-stats-full (n-done n-not-done)
;;     "Switch entry to DONE when all subentries are done."
;;     (let (org-log-done
;;           org-log-states  ; turn off logging
;;           (state (org-get-todo-state)))
;;       (when (= n-not-done 0)
;;         (cond ((equal state "PROJ")
;;                (org-todo "DONEPROJ"))
;;               ((not (equal state "DONEPROJ"))
;;                (org-todo "DONE"))
;;               ))))
;;   (add-hook! 'org-after-todo-statistics-hook #'org-todo-done-when-stats-full))
#+end_src

Heavily inspired from:
https://emacs.stackexchange.com/questions/9433/how-to-make-org-prompt-for-a-timestamp-when-changing-state-of-a-todo/9451#9451
#+begin_src elisp
(after! org
  (defun +maker/org-todo-with-date (&optional arg)
    "Like `org-todo' but the time of change will be prompted."
    (interactive "P")
    (cl-letf* ((org-read-date-prefer-future nil)
               (my-current-time (org-read-date t t nil "when:" nil nil nil))
               ((symbol-function 'current-time)
                #'(lambda () my-current-time))
               ((symbol-function 'org-today)
                #'(lambda () (time-to-days my-current-time)))
               ((symbol-function 'org-current-effective-time)
                #'(lambda () my-current-time))
               (super (symbol-function 'format-time-string))
               ((symbol-function 'format-time-string)
                #'(lambda (fmt &optional time time-zone)
                    (funcall super fmt my-current-time time-zone))))
      (if (eq major-mode 'org-agenda-mode)
          (org-agenda-todo arg)
        (org-todo arg)))))
#+end_src

*** Tags

Configure default tags behavior and appearance.
#+begin_src elisp
(after! org
  ;; Default list of toplevel tags.
  ;; My org files redefine these tags for explicitness and might add their own specific tags.
  (setq org-tag-alist
        '((:startgrouptag . nil)
          ("date"         . ?1)
          (:grouptags     . nil)
          ("event"        . ?e)
          ("appointment"  . ?t)
          (:endgrouptag   . nil)
          (:startgrouptag . nil)
          ("activity"     . ?2)
          (:grouptags     . nil)
          ("read"         . ?r)
          ("listen"       . ?a)
          ("watch"        . ?v)
          (:endgrouptag   . nil)
          (:startgrouptag . nil)
          ("task"         . ?3)
          (:grouptags     . nil)
          ("bug"          . ?b)
          ("improvement"  . ?m)
          ("feature"      . ?f)
          (:endgrouptag   . nil)
          (:startgrouptag . nil)
          ("context"      . ?4)
          (:grouptags     . nil)
          ("@self"        . ?s)
          ("@home"        . ?h)
          ("@work"        . ?w)
          ("@people"      . ?l)
          ("{@.+}"        . ?@)
          (:endgrouptag . nil))
        org-tag-faces
        ;; Teal/Blue version, matches org-formula
        '(("date"        . (:foreground "LightSkyBlue" :weight bold))
          ("activity"    . (:foreground "#b5bd68" :weight bold))
          ("task"        . (:foreground "#cc6666" :weight bold))
          ("context"     . (:foreground "#8abeb7" :weight bold))
          ;; Date tags
          ("event"       . (:foreground "LightSkyBlue" :weight bold))
          ("appointment" . (:foreground "#f0c674" :weight bold))
          ;; Activity tags
          ("read"        . (:foreground "#b5bd68" :weight bold))
          ("listen"      . (:foreground "#b5bd68" :weight bold))
          ("watch"       . (:foreground "#b5bd68" :weight bold))
          ;; Task tags
          ("need"        . (:foreground "#de935f" :weight bold))
          ("issue"       . (:foreground "#cc6666" :weight bold))
          ("bug"         . (:foreground "#cc6666" :weight bold))
          ("improvement" . (:foreground "#de935f" :weight bold))
          ("feature"     . (:foreground "#b5bd68" :weight bold))
          ;; Context tags
          ("@self"       . (:foreground "#8abeb7" :weight bold))
          ("@home"       . (:foreground "#8abeb7" :weight bold))
          ("@work"       . (:foreground "#8abeb7" :weight bold))
          ("@people"     . (:foreground "#8abeb7" :weight bold)))
        org-fast-tag-selection-single-key 't)
  (custom-set-faces!
    ;; '(org-tag :foreground "#717171" :weight normal)
    ;; '(org-tag :foreground "#de935f" :weight normal)
    '(org-tag :foreground "#8abeb7" :weight normal)
    '(org-tag-group :foreground unspecified :weight unspecified)))
#+end_src

*** Dates & Times

Configure org-habit.
#+begin_src elisp
(after! org
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-completed-glyph ?‚úî
        org-habit-today-glyph ?!))
#+end_src

Configure org-clock.
#+begin_src elisp
(after! org
  (setq org-clock-report-include-clocking-task t
        org-clock-display-default-range 'untilnow
        org-clock-auto-clock-resolution 'when-no-clock-is-running
        org-clock-idle-time nil
        ;; History & Persistence settings
        org-clock-history-length 20
        org-clock-persist 'history) ; TODO: Maybe t? Or maybe nil if bothering on startup
  (org-clock-persistence-insinuate)

  (defun +org-clock-goto-select ()
    (interactive)
    (org-clock-goto 'select)))
#+end_src

*** Refiling & Archiving
**** Settings

Configure org-refile.
#+begin_src elisp
(after! org
  (setq org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil
        org-refile-allow-creating-parent-nodes nil
        org-refile-targets
        '((nil :maxlevel . 4)
          (org-agenda-files :maxlevel . 4))
        org-refile-target-verify-function #'+maker/org-refile-target-verify))
#+end_src

Configure archiving behavior.
#+begin_src elisp
(after! org
  (setq org-archive-location "archive/%s_archive::datetree/"
        org-archive-mark-done t
        org-export-with-archived-trees nil)

  ;; Do not keep archive buffers alive.
  (add-hook! 'org-archive-hook
             (defun +maker/kill-archive-buffers ()
               (doom/kill-matching-buffers "\\.org_archive$"))))
#+end_src

**** Refile target filters

Define target filter functions.
#+begin_src elisp
(after! org
  (defun +maker/org-refile-target-verify ()
    "Remove TODO-items that are not projects from refile targets."
    (let ((todo (org-get-todo-state)))
      (if (and todo (not (equal todo "PROJ")))
          (progn (org-end-of-subtree) nil)
        t)))

  (defun +maker/org-refile-target-verify-context ()
    "Remove TODO-items that are not projects, and headings not matching GTD context from refile targets."
    (let ((tags (org-get-tags-at))
          (todo (org-get-todo-state)))
      (unless (or (and todo (not (equal todo "PROJ")))
                  (and +maker/org-view-context
                       (if (eq +maker/org-view-context 'none)
                           (cl-member-if (lambda (tag) (string-match-p "^@.+" tag)) tags)
                         (not (member +maker/org-view-context tags)))))
        t))))
#+end_src

Prevent refiling at file toplevel in agenda files.
#+begin_src elisp
(after! org
  (defun maker/org-refile-filter-targets (orig-fun &rest args)
    (let ((targets (apply orig-fun args))
          (agenda-files (mapcar #'file-name-nondirectory (org-agenda-files))))
      (cl-remove-if (lambda (x)
                      (member (car x) agenda-files))
                    targets)))
  (advice-add 'org-refile-get-targets :around #'maker/org-refile-filter-targets))
#+end_src

**** Refile commands

Define additional refile commands.
#+begin_src elisp
(after! org
  (defun +maker/org-refile-to-context (&rest _)
    "Refile current heading to targets in the currently selected scope and context."
    (interactive "P")
    (let* ((scope (unless (eq +maker/org-view-scope 'buffer) +maker/org-view-scope))
           (org-refile-targets `((,scope :maxlevel . 4)))
           (org-refile-target-verify-function #'+maker/org-refile-target-verify-context)
           current-prefix-arg)
      (call-interactively #'org-refile))))
#+end_src

**** Bindings

Customize bindings.
#+begin_src elisp
(after! org
  (map! :map org-mode-map
        :localleader
        :prefix ("r" . "Refile")
        "R"  #'org-refile-reverse
        "n"  #'+maker/org-refile-to-context))
#+end_src

*** Capture
**** Settings

Configure org-capture settings.
#+begin_src elisp
(after! org-capture
  (setq org-default-notes-file (expand-file-name "life.org" org-directory)
        org-capture-bookmark t
        org-capture-use-agenda-date t)

  ;; Override default frame parameters for the external capture frame.
  (add-to-list '+org-capture-frame-parameters '(fullscreen . nil))
  (add-to-list '+org-capture-frame-parameters '(width . 180)) ; To match org-tags-column
  (add-to-list '+org-capture-frame-parameters '(height . 0.27))

  ;; Hide header line in capture buffer.
  ;; FIXME: This does not work for org-mks select interface.
  (defadvice! maker/org-capture-frame-disable-tabs (&rest _)
    :after #'org-capture
    (when (+org-capture-frame-p)
      (centaur-tabs-local-mode 1))))
#+end_src

**** Template commands

#+begin_src elisp
(after! org-capture
  (defun +org--get-clipboard ()
    "Return clipboard contents in a portable way."
    (cond
     ((display-graphic-p)
      (gui-get-selection 'CLIPBOARD 'UTF8_STRING))
     ((fboundp 'interprogram-paste-function)
      (funcall interprogram-paste-function))
     (t nil)))

  (defun +org-capture-cliplink-url ()
    "Return org link with clipped title if X clipboard contains an HTTP(S) URL."
    (let ((content (+org--get-clipboard)))
      (when (and (stringp content) 
                 (string-match "^https?://" content))
        (org-cliplink-capture))))

  (defun +org-capture-annotation ()
    "Return clipped link if capturing from org-mode, annotation otherwise."
    (with-current-buffer (org-capture-get :original-buffer)
      (if (member major-mode '(org-mode))
          (+org-capture-cliplink-url)
        (org-capture-get :annotation)))))
#+end_src

**** Templates

Configure doct.
#+begin_src elisp
(use-package! doct
  :commands (doct)
  :config
  (setq doct-warnings t
        doct-default-entry-type 'entry))
#+end_src

Define the default capture templates.
#+begin_src elisp
(after! org-capture
  (setq org-capture-templates
        (doct '((:group "Top"
                 :file org-default-notes-file :olp ("Inbox")
                 :empty-lines 1
                 :children
                 (("Note" :keys "n"
                   :template ("* %?"
                              "\n%(+org-capture-annotation)"
                              "\n%i"))
                  ("Recipe" :keys "r"
                   :file "~/Notes/cheph.org"
                   :template ("* %?"
                              "\n%(+org-capture-annotation)"
                              "\n%i"))
                  ;; Event/Appointment for agenda
                  ;; ("Event" :keys "e"
                  ;;  :olp ("Calendrier" "Activit√©s")
                  ;;  :template ("* %? %(org-set-tags \"event\")"
                  ;;             "\n%^{Event}t"
                  ;;             "\n%(+org-capture-annotation)"
                  ;;             "\n%i"))
                  ;; ("Appointment" :keys "a"
                  ;;  :olp ("Calendrier" "Activit√©s")
                  ;;  :template ("* %? %(org-set-tags \"appointment\")"
                  ;;             "\n%^{Appointment}t"
                  ;;             "\n%(+org-capture-annotation)"
                  ;;             "\n%i"))
                  ;; Journal entry
                  ("Journal" :keys "j"
                   :datetree t :olp ("D√©veloppement" "Journal")
                   :template ("* %?"
                              "\n%i"))

                  ;; Common task templates
                  ("Task" :keys "t"
                   :template ("* TODO %? %(org-set-tags \"%{tags}\")"
                              "\n%(+org-capture-annotation)"
                              "\n%i")
                   :children
                   (("Regular" :keys "t" :tags nil)
                    ("Need" :keys "n" :tags "need")
                    (:group "Activity"
                     :template "* TODO %?%(+org-capture-annotation) %(org-set-tags \"%{activity-tag}\")"
                     :children
                     (("Read"   :keys "r" :olp ("Divertissement" "Lecture") :activity-tag "read")
                      ("Listen" :keys "l" :olp ("Divertissement" "Musique") :activity-tag "listen")
                      ("Watch"  :keys "w" :olp ("Divertissement" "Cin√©ma")  :activity-tag "watch")))
                    )))
                 )))))
#+end_src

Define generic capture templates used in other contexts.
#+begin_src elisp
(after! org-capture
  (defvar +org-capture-generic-templates
    '((:group "Generic"
       :empty-lines 1
       :children
       (("Note" :keys "n"
         :template ("* %?"
                    "\n%(+org-capture-annotation)"
                    "\n%i"))
        ;; Event/Appointment for agenda
        ;; ("Event" :keys "e"
        ;;  :template ("* %? %(org-set-tags \"event\")"
        ;;             "\n%^{Event}t"
        ;;             "\n%(+org-capture-annotation)"
        ;;             "\n%i"))
        ;; ("Appointment" :keys "a"
        ;;  :template ("* %? %(org-set-tags \"appointment\")"
        ;;             "\n%^{Appointment}t"
        ;;             "\n%(+org-capture-annotation)"
        ;;             "\n%i"))

        ;; Common task templates
        ("Task" :keys "t"
         :template ("* TODO %? %(org-set-tags \"%{tags}\")"
                    "\n%(+org-capture-annotation)"
                    "\n%i")
         :children
         (("Regular" :keys "t" :tags nil)
          (:group "Activity"
           :template "* TODO %?%(+org-capture-annotation) %(org-set-tags \"%{activity-tag}\")"
           :children
           (("Read"   :keys "r" :activity-tag "read")
            ("Listen" :keys "l" :activity-tag "listen")
            ("Watch"  :keys "w" :activity-tag "watch")))
          )))))))
#+end_src

**** Commands

Advise existing capture commands and add project capture commands.
#+begin_src elisp
(after! org-capture
  (defun maker/org-capture-target (&optional project-root)
    "Get the org capture target file based on current or selected context."
    (let* ((project-root (or project-root (projectile-project-root))))
      (cond
       ;; Use the current project notes file if available
       ((and (eq +maker/org-view-scope 'buffer)
             project-root)
        (+maker/projectile-get-project-notes-file project-root))
       ;; Use the current buffer only if in org-mode
       ((and (eq +maker/org-view-scope 'buffer)
             (eq major-mode 'org-mode))
        (buffer-file-name))
       ;; Use the selected org file if set
       ((and (stringp +maker/org-view-scope)
             (file-name-absolute-p +maker/org-view-scope))
        +maker/org-view-scope)
       ;; Fallback to default
       (t org-default-notes-file))))

  (defvar maker/org-capture--project-only nil)

  (defadvice! maker/org-context-capture-ad (fn &rest args)
    "Add additional capture templates based on current or selected context."
    :around #'org-capture
    (let* ((project-root (projectile-project-root))
           (target-file (maker/org-capture-target project-root))
           (parent-name (format "%s [%s]"
                                (if project-root "Project" "Context")
                                (file-name-base target-file)))
           (org-capture-templates
            (append org-capture-templates
                    (unless (or maker/org-capture--project-only
                                (equal target-file org-default-notes-file))
                      (doct `((,parent-name :keys "c"
                                            :file ,target-file :olp ("Inbox")
                                            :children
                                            ,+org-capture-generic-templates)))))))
      (apply fn args)))

  (defun maker/org-project-capture-ad (fn &rest args)
    "Replace default by project capture templates and invoke the given capture command."
    (let* ((project-root (projectile-acquire-root))
           (project-notes-file (+maker/projectile-get-project-notes-file project-root))
           (org-capture-templates
            (doct `((:group "Project"
                     :file ,project-notes-file :olp ("Inbox")
                     :children
                     ,+org-capture-generic-templates))))
           (maker/org-capture--project-only t))
      (apply fn args)))

  (defun maker/org-project-capture (&optional goto keys)
    "Capture something into a project."
    (interactive "P")
    (maker/org-project-capture-ad #'org-capture goto keys)))
#+end_src

**** External command

Override doom's org-capture script with my own variant.
#+begin_src sh :tangle ~/.local/bin/my/org-capture :tangle-mode (identity #o755)
#!/usr/bin/env sh
# Open an org-capture popup frame.
#
# Usage: org-capture [-k KEY] [MESSAGE]
# Examples:
#   org-capture -k n "To the mind that is still, the whole universe surrenders."

set -e

# The command to use to contact the emacs server.
EMACSCLIENT="emacsclient --socket-name graphical"

# org-capture key mapped to argument flags
while getopts "hk:" opt; do
  key="\"$OPTARG\""
  break
done
shift $((OPTIND - 1))

# use remaining args, else read from stdin if passed a single dash
str="$*"
case "$str" in
  -) str=$(cat) ;;
esac

# Non-daemon servers flicker a lot if frames are created from terminal, so we do
# it internally instead.
$EMACSCLIENT -e "(+org-capture/open-frame \"$str\" ${key:-nil})" >/dev/null
#+end_src

**** Bindings

Customize bindings.
#+begin_src elisp
(after! org
  (map! (:leader
         "X" nil

         (:prefix "n"
         :desc "Org capture"
         "x" #'org-capture)

         (:prefix "p"
          :desc "Org project capture"
          "x" #'maker/org-project-capture))

        ;; Bind all evil variants explicitly to force hint to display these
        :map org-capture-mode-map
        :n "ZQ" #'org-capture-kill
        :n "ZA" #'org-capture-refile
        :n "ZW" #'org-capture-refile
        :n "ZZ" #'org-capture-finalize))
#+end_src

*** Attachments
**** Settings

Configure org-attach settings.
#+begin_src elisp
(after! org-attach
  (setq org-attach-id-dir (expand-file-name ".attach/" org-directory)
        org-attach-dir-relative nil
        org-attach-use-inheritance t
        org-attach-method 'cp
        org-attach-preferred-new-method 'id
        org-attach-archive-delete nil
        org-attach-auto-tag "ATTACH"
        org-attach-store-link-p 'attached
        org-attach-expert nil)
  )
#+end_src

**** Bindings

Customize bindings.
#+begin_src elisp
(after! org
  (map! :map org-mode-map
        :localleader
        :prefix "a"
        ;; "a" #'org-attach
        ;; "d" #'org-attach-delete-one
        ;; "D" #'org-attach-delete-all
        ;; "f" #'+org/find-file-in-attachments
        ;; "l" #'+org/attach-file-and-insert-link
        ;; "n" #'org-attach-new
        ;; "o" #'org-attach-open
        ;; "O" #'org-attach-open-in-emacs
        ;; "r" #'org-attach-reveal
        ;; "R" #'org-attach-reveal-in-emacs
        ;; "u" #'org-attach-url
        ;; "s" #'org-attach-set-directory
        ;; "S" #'org-attach-sync
        ))
#+end_src

*** Agenda
**** Settings

Customize agenda settings.
#+begin_src elisp
(after! org
  ;; Customize window-setup style for agenda.
  (setq org-agenda-window-setup 'current-window
        org-agenda-restore-windows-after-quit nil)

  ;; General agenda setup
  (setq org-agenda-files (list org-directory)
        ;; org-agenda-sticky 't ; NOTE: Disabled, agenda is incrementally slower upon refresh
        org-agenda-span 'week
        org-agenda-start-on-weekday 1
        org-agenda-start-day nil)

  ;; Agenda settings related to items with dates.
  (setq org-agenda-skip-timestamp-if-done 't
        org-agenda-skip-scheduled-if-done 't
        org-agenda-skip-deadline-if-done nil
        org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled
        org-agenda-skip-timestamp-if-deadline-is-shown nil
        org-agenda-skip-scheduled-if-deadline-is-shown 'not-today
        org-agenda-skip-scheduled-delay-if-deadline nil
        org-agenda-show-future-repeats 't))
#+end_src

**** Appearance

Add a separator line between days.
#+begin_src elisp
(after! org
  (setq org-agenda-compact-blocks nil
        org-agenda-format-date
        (lambda (date)
          (concat
           (make-string (window-width) 8943) "\n"
           (org-agenda-format-date-aligned date)))))
#+end_src

Configure prefix.
#+begin_src elisp
(after! org
  ;; NOTE: Category is removed from todo/tags/search views since it is redundant with
  ;; my default org-super-agenda grouping and causes display issues in org-ql-view.
  (setq org-agenda-prefix-format
        '((agenda . " %i %-17:c%?-12t% s")
          (todo . " %i ") ; For category: %-17:c
          (tags . " %i ")
          (search . " %i "))))
#+end_src

Configure time grid.
#+begin_src elisp
(after! org
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          "......" "‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ")
        org-agenda-current-time-string
        "‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ now"))
#+end_src

Customize general org agenda faces.
#+begin_src elisp
(after! org
  (custom-set-faces!
    '(org-agenda-date :foreground unspecified :inherit outline-3)
    '(org-agenda-date-today :foreground unspecified :inherit outline-1)
    '(org-agenda-date-weekend :foreground unspecified :inherit org-agenda-date)
    '(org-agenda-date-weekend-today :inherit org-agenda-date-today)
    '(org-super-agenda-header :inherit org-agenda-structure)))
#+end_src

Customize org scheduled/deadline/clocked faces.
#+begin_src elisp
(after! org
  (setq org-deadline-faces
        '((1.001 . error)
          (1.0 . org-imminent-deadline)
          (0.5 . org-upcoming-deadline)
          (0.0 . org-upcoming-distant-deadline)))
  (custom-set-faces!
    '(org-scheduled :foreground unspecified :inherit default)
    '(org-scheduled-today :foreground "#ffffff")
    '(org-scheduled-previously :foreground "#ffffff")
    '(org-upcoming-distant-deadline :foreground unspecified :weight light :inherit org-warning)
    '(org-upcoming-deadline :foreground unspecified :inherit org-warning)
    '(org-imminent-deadline :weight semi-bold :inherit org-warning)
    '(org-agenda-clocking :background unspecified :foreground "#de935f" :inherit org-block)))
#+end_src

Do not show blocked tasks as dimmed by default. With my configuration they are usually projects (subtasks not done).
Also customize the face to be brighter, in case locally enabled.
#+begin_src elisp
(after! org
  (setq org-agenda-dim-blocked-tasks nil)
  (custom-set-faces! '(org-agenda-dimmed-todo-face :foreground "#717171")))
#+end_src

Always highlight the current agenda line.
#+begin_src elisp
(add-hook! org-agenda-mode (hl-line-mode 1))
#+end_src

**** Diary

Configure diary/agenda integration.
#+begin_src elisp
(after! org
  (setq org-agenda-include-diary nil
        org-agenda-diary-file (expand-file-name "life.org" org-directory)))
#+end_src

**** Filtering

Configure the custom tag filter accessible via <RET> from the tag filter prompt in agenda (f t).
Also accessible via a triple prefix on the main agenda filter command (f f)
#+begin_src elisp
(after! org
  (defun +org-agenda-exclude-events (tag)
    (when (string= tag "event")
      (concat "-" tag)))
  (setq org-agenda-auto-exclude-function #'+org-agenda-exclude-events))
#+end_src

**** Custom Views

Definition of stuck projects.
#+begin_src elisp
(after! org
  (setq org-stuck-projects
        '("+TODO=\"PROJ\""
          ("TODO" "ACTV")
          ("event" "appointment") "")))
#+end_src

Configure default sorting.
#+begin_src elisp
(after! org
  (setq org-agenda-sorting-strategy
        '((agenda habit-down time-up priority-down category-up)
          (todo category-up priority-down)
          (tags category-up priority-down)
          (search category-up))))
#+end_src

Define custom agenda views.
#+begin_src elisp
(after! org
  (defvar +maker/org-agenda-groups
        '((:name "Schedule" :time-grid t)
          (:auto-outline-path t :order 99)))

  (setq org-agenda-custom-commands
        '(("d" "Agenda for current day" agenda ""
           ((org-agenda-span 'day)
            (org-super-agenda-groups +maker/org-agenda-groups)))

          ("w" "Agenda for current week" agenda ""
           ((org-super-agenda-groups +maker/org-agenda-groups)))

          ("e" "Appointments for current week" agenda* ""
           ((org-super-agenda-groups +maker/org-agenda-groups)))

          ("l" "Log of the current week" agenda ""
           ((org-agenda-overriding-header "Activity Log")
            (org-agenda-archives-mode 't)
            (org-agenda-start-with-log-mode 'only)
            (org-agenda-log-mode-items '(closed clock state))
            (org-agenda-use-time-grid nil)
            (org-super-agenda-groups nil))))))
#+end_src

**** Commands

Add interactive functions to cycle todo states from agenda.
#+begin_src elisp
(after! org
  (defun +org-agenda-todo-prev ()
    (interactive)
    (org-agenda-todo 'left))
  (defun +org-agenda-todo-next ()
    (interactive)
    (org-agenda-todo 'right)))
#+end_src

Improve behavior of indirect-buffer spawning.
NOTE: This is not ideal but should work for my usage.
Does not integrate well with dired-view-file, which seems to permanently add 'q' binding on org buffers...
It could be interesting to use a similar approach than dired-view-file for agenda indirect buffers.
#+begin_src elisp
(after! org-agenda
  (defadvice! +maker/org-agenda-indirect-buffer (&rest _)
    :after #'org-agenda-tree-to-indirect-buffer
    (unless current-prefix-arg
      (select-window (get-buffer-window org-agenda-last-indirect-buffer))
      (centaur-tabs-local-mode 1)
      (use-local-map (copy-keymap (current-local-map)))
      (local-set-key "q" #'kill-buffer-and-window)))

  (defun +maker/org-agenda-tree-to-indirect-buffer-new ()
    (interactive)
    (let ((orig-buffer (current-buffer))
          (current-prefix-arg '(4)))
      (message "%s" orig-buffer)
      (call-interactively 'org-agenda-tree-to-indirect-buffer)
      (with-current-buffer org-last-indirect-buffer
        (setq-local doom--narrowed-base-buffer orig-buffer)))))
#+end_src

**** Hydra

Define a major-mode-hydra.
#+begin_src elisp
(after! org
  (defun org-agenda-cts ()
    (and (eq major-mode 'org-agenda-mode)
         (let ((args (get-text-property
                      (min (1- (point-max)) (point))
                      'org-last-args)))
           (nth 2 args))))

  (major-mode-hydra-define org-agenda-mode
    (:color red :title (+hydra/major-mode-title-generator 'org-agenda-mode 55))
    ("Span"
     (("zd" org-agenda-day-view (format "%s day" (if (eq 'day (org-agenda-cts)) "[x]" "[ ]")))
      ("zw" org-agenda-week-view (format "%s week" (if (eq 'week (org-agenda-cts)) "[x]" "[ ]")))
      ("zt" org-agenda-fortnight-view (format "%s fortnight" (if (eq 'fortnight (org-agenda-cts)) "[x]" "[ ]")))
      ("zm" org-agenda-month-view (format "%s month" (if (eq 'month (org-agenda-cts)) "[x]" "[ ]")))
      ("zy" org-agenda-year-view (format "%s year" (if (eq 'year (org-agenda-cts)) "[x]" "[ ]")))
      ("]" org-agenda-later "later")
      ("[" org-agenda-earlier "earlier"))
     "View"
     (("zg" org-agenda-toggle-time-grid (format "time grid: % -3S" org-agenda-use-time-grid))
      ("ze" org-agenda-entry-text-mode (format "text: % -3S" org-agenda-entry-text-mode))
      ("zA" (org-agenda-archives-mode 'files) (format "archive: %s" org-agenda-archives-mode))
      ("zl" org-agenda-log-mode (format "log: % -3S" org-agenda-show-log))
      ("zL" (org-agenda-log-mode '(4)) "log all")
      ("zc" (org-agenda-log-mode 'clockcheck) "clockcheck")
      ("zr" org-agenda-clockreport-mode (format "clockreport: % -3S" org-agenda-clockreport-mode)))
     "Filter"
     (("fc" org-agenda-filter-by-category "category")
      ("fh" org-agenda-filter-by-top-headline "top heading")
      ("ft" org-agenda-filter-by-tag "tag")
      ("fr" org-agenda-filter-by-regexp "regexp")
      ("ff" org-agenda-filter "edit")
      ("F" org-agenda-filter-remove-all "remove"))
     "Open"
     (("zf" org-agenda-follow-mode (format "follow: % -3S" org-agenda-follow-mode))
      ("S-RET" org-agenda-recenter "view other")
      ("M-RET" org-agenda-tree-to-indirect-buffer "view indirect")
      ("C-RET" org-agenda-goto "open other"))
     "Action"
     (("d" org-agenda-date-prompt "date")
      ("a" org-agenda-add-note "note" :color blue)
      ("i" org-agenda-diary-entry "journal" :color blue)
      ("r" org-agenda-refile "refile")
      ("D" org-agenda-archive-default-with-confirmation "archive"))
     "Mark"
     (("m" org-agenda-bulk-toggle "toggle")
      ("M" org-agenda-bulk-toggle-all "toggle all")
      ("U" org-agenda-bulk-unmark-all "unmark all")
      ("x" org-agenda-bulk-action "action")

      ("q" nil :color blue)
      ("<escape>" nil :color blue)))))
#+end_src

**** Bindings

Customize bindings.
#+begin_src elisp
(after! evil-org-agenda
  ;; Leader bindings
  ;; TODO: Remove the which-key description which are not overridden...
  (map!
   :leader
   ;; Simplify agenda commands in notes prefix.
   (:prefix "n"
    :desc "Org agenda"     "a" #'org-agenda
    "m" nil
    "v" nil)

   ;; Unbind agenda commands in open prefix.
   (:prefix "o"
    "a" nil
    "A" nil))

  ;; Agenda bindings
  (map! :map evil-org-agenda-mode-map
        ;; Avoid spurious bindings kicking in with ESC
        :g [escape]     #'transient-noop
        ;; This is more consistent for me
        :m [C-return]   #'org-agenda-goto
        :m "C-RET"      #'org-agenda-goto
        :m [S-return]   #'org-agenda-recenter
        :m "S-RET"      #'org-agenda-recenter
        :m [M-return]   #'org-agenda-tree-to-indirect-buffer
        :m "M-RET"      #'org-agenda-tree-to-indirect-buffer
        :m [M-S-return] #'+maker/org-agenda-tree-to-indirect-buffer-new
        :m "M-S-RET"    #'+maker/org-agenda-tree-to-indirect-buffer-new

        ;; Move cursor by items instead of lines by default
        :m "j"          #'org-agenda-next-line
        :m "k"          #'org-agenda-previous-line
        :m "M-j"        #'org-agenda-next-item
        :m "M-k"        #'org-agenda-previous-item
        :m "C-j"        #'outline-next-heading
        :m "C-k"        #'outline-previous-heading

        ;; Add equivalence for org-mode bindings
        :m "C-M-k"      #'org-agenda-priority-up
        :m "C-M-j"      #'org-agenda-priority-down
        :m "C-M-h"      #'+org-agenda-todo-prev
        :m "C-M-l"      #'+org-agenda-todo-next
        :m "C-M-S-h"    #'org-agenda-todo-previousset
        :m "C-M-S-l"    #'org-agenda-todo-nextset

        ;; Bind filter commands to 'f' prefix
        :m "ff"         #'org-agenda-filter
        :m "fh"         #'org-agenda-filter-by-top-headline
        :m "fc"         #'org-agenda-filter-by-category
        :m "fe"         #'org-agenda-filter-by-effort
        :m "fr"         #'org-agenda-filter-by-regexp
        :m "fq"         #'org-agenda-filter-by-tag
        :m "fl"         #'org-agenda-limit-interactively
        :m "F"          #'org-agenda-filter-remove-all
        :m "s^"         nil
        :m "sc"         nil
        :m "se"         nil
        :m "sr"         nil
        :m "st"         nil
        :m "ss"         nil

        ;; Bind "show" commands to 's' prefix
        :m "sh"         #'org-habit-toggle-display-in-agenda
        :m "sH"         #'org-agenda-holidays
        :m "sm"         #'org-agenda-phases-of-moon
        :m "ss"         #'org-agenda-sunrise-sunset
        :m "sq"         #'org-agenda-show-tags
        :m "sd"         #'org-agenda-convert-date
        :m "gh"         nil
        :m "gm"         nil
        :m "gs"         nil
        :m "gt"         nil
        :m "gC"         nil

        ;; Bind additional commands
        :m "S"          #'org-save-all-org-buffers
        :m "M"          #'org-agenda-bulk-toggle-all
        :m "D"          #'org-agenda-archive-default-with-confirmation
        :m "T"          #'org-agenda-set-tags
        :m "p"          #'org-agenda-priority
        :m "d"          #'org-agenda-date-prompt
        :m "cd"         #'org-agenda-date-prompt
        :m ">"          #'org-agenda-remove-restriction-lock

        :map org-agenda-mode-map
        ;; Unbind obsolete and/or misleading bindings
        :m "C-SPC"      nil
        :m "o"          #'org-agenda-open-link

        ;; Bind missing agenda-equivalent of frequent org commands
        :localleader
        "a"             #'org-attach
        "p"             #'org-agenda-priority
        "C"             #'org-timer-set-timer

        :prefix "d"
        "t"             #'org-agenda-date-prompt))
#+end_src

*** Views
**** Org QL Views

Interactive functions to display custom Org QL Views.
#+begin_src elisp
(after! org-ql
  (defvar +maker/org-view-scope 'buffer
    "The currently selected scope for Org Views.

The special symbol `buffer' means to use the current buffer.")
  (defvar +maker/org-view-context nil
    "The currently selected context tag for Org Views.

The special symbol `none' means to not match headlines with any context tag.")
  (defvar +maker/org-view-tags nil
    "The currently selected tags for Org Views.")

  ;; ‚ú¥‚ú≥üèµüåº‚òò
  (defvar +maker/org-view-groups-dashboard
    '((:name "üìÖ Scheduled" :scheduled t)
      (:name "üåÄ Projects" :todo "PROJ")
      (:auto-outline-path t))
    "Org super agenda groups for dashboard views.")

  (defvar +maker/org-view-groups-planning
    '((:name "üî• Active" :todo "ACTV") ;
      (:name "‚≠ï Top Priorities" :and (:priority>= "B" :not (:todo "PROJ")))
      (:name "üìÖ Scheduled" :scheduled t)
      (:name "üåÄ Projects" :todo "PROJ")
      ;; Life-specific heading groups
      (:name "üéß Musique" :and (:outline-path-regexp "Musique" :tag "listen"))
      (:name "üé• Cin√©ma" :and (:outline-path-regexp "Cin√©ma" :tag "watch"))
      ;; Default groups
      (:auto-outline-path t))
    "Org super agenda groups for planning views.")

  (defvar +maker/org-view-groups-backlog
    '((:name "üéØ Goals" :transformer #'+maker/org-view-goals-transformer :todo nil)
      (:auto-outline-path t))
    "Org super agenda groups for backlog views.")

  (defun +maker/org-view-goals-transformer (item)
    (org-super-agenda--when-with-marker-buffer (org-super-agenda--get-marker item)
      (s-replace-regexp "Goals\\|Objectifs" (car (last (org-get-outline-path))) item)))

  (defun +maker/org-view-upcoming ()
    (interactive)
    (+maker/org-view-make
     :buffers-files +maker/org-view-scope
     :narrow t
     :query '(and (or (scheduled)
                      (deadline auto))
                  (not (done)))
     :context +maker/org-view-context
     :tags +maker/org-view-tags
     :super-groups '((:auto-planning t))
     :title "Upcoming"))

  (defun +maker/org-view-dashboard ()
    (interactive)
    (+maker/org-view-make
     :buffers-files +maker/org-view-scope
     :narrow t
     :query '(and (todo)
                  (not (todo "SMDY" "IDEA"))
                  (not (ancestors (todo "SMDY" "IDEA")))
                  (or (todo "ACTV") (priority '>= "B")))
     :context +maker/org-view-context
     :tags +maker/org-view-tags
     :super-groups +maker/org-view-groups-dashboard
     :title "Dashboard"))

  (defun +maker/org-view-planning ()
    (interactive)
    (+maker/org-view-make
     :buffers-files +maker/org-view-scope
     :narrow t
     :query '(and (todo)
                  (not (todo "SMDY" "IDEA"))
                  (not (ancestors (todo "SMDY" "IDEA"))))
     :context +maker/org-view-context
     :tags +maker/org-view-tags
     :super-groups +maker/org-view-groups-planning
     :title "Planning"))

  (defun +maker/org-view-backlog ()
    (interactive)
    (+maker/org-view-make
     :buffers-files +maker/org-view-scope
     :narrow t
     :query '(and (or (todo)
                      (heading-regexp "^\\(Goals\\|Objectifs\\)$"))
                  (not (tags "read" "listen" "watch")))
     :context +maker/org-view-context
     :tags +maker/org-view-tags
     :super-groups +maker/org-view-groups-backlog
     :title "Backlog"))

  (cl-defun +maker/org-view-make (&key buffers-files query narrow super-groups sort title context tags)
    (let ((buffers-files (+maker/org-view-target buffers-files))
          (query (append query (+maker/org-view-make-query context tags)))
          (sort (or sort '(priority scheduled))))
      (org-ql-search buffers-files query
        :narrow narrow
        :super-groups super-groups
        :sort sort
        :title (+maker/org-view--make-title title buffers-files context tags))))

  (defun +maker/org-view-target (scope)
    (cond
     ;; Use the current buffer only if in org-mode
     ((and (equal scope 'buffer)
           (eq major-mode 'org-mode))
      (current-buffer))
     ;; Use the current project notes file if available
     ((and (equal scope 'buffer)
           (projectile-project-p))
      (+maker/projectile-get-project-notes-file))
     ;; Use the selected org file if set
     ((and (stringp scope)
           (file-name-absolute-p scope))
      scope)
     ;; Fallback to default
     (t #'org-agenda-files)))

  (defun +maker/org-view-make-query (&optional context tags)
    (append
     (when context
       (if (eq context 'none)
           '((not (tags-regexp "@.+")))
         `((tags ,context))))
     (when tags `((tags ,@tags)))))

  (defun +maker/org-view--make-title (name &optional buffers-files context tags)
    (let ((source (when buffers-files (format " in %s" buffers-files)))
          (suffix (mapconcat (lambda (it) (format "%s" it))
                             (remove nil (list context tags))
                             " ")))
      (cond ((and name (not (string-empty-p suffix))) (concat name source ": " suffix))
            ((and (not name) suffix) suffix)
            (t (concat name source))))))
#+end_src

**** Sidebar

Define sidebar views.
#+begin_src elisp
(after! org-sidebar
  (defun +maker/org-sidebar--daily-agenda-fn (source-buffer)
    "Return an Org Agenda buffer showing the daily agenda in SOURCE-BUFFER."
    (save-window-excursion (org-agenda nil "d"))
    org-agenda-buffer)

  (defun +maker/org-sidebar--upcoming-fn (source-buffer)
    "Return an Org QL View buffer showing unscheduled, un-deadlined items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Upcoming*")))
      (let ((org-ql-view-buffer display-buffer)
            (+maker/org-view-scope 'buffer))
        (save-window-excursion (+maker/org-view-upcoming)))
      display-buffer))
  (defun +maker/org-sidebar-agenda-upcoming ()
    (interactive)
    (let ((org-sidebar-default-fns '(+maker/org-sidebar--daily-agenda-fn +maker/org-sidebar--upcoming-fn)))
      (org-sidebar-toggle)))

  (defun +maker/org-sidebar--dashboard-fn (source-buffer)
    "Return an Org QL View buffer showing active and high-priority items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Dashboard*")))
      (let ((org-ql-view-buffer display-buffer)
            (+maker/org-view-scope 'buffer))
        (save-window-excursion (+maker/org-view-dashboard)))
      display-buffer))
  (defun +maker/org-sidebar-dashboard ()
    (interactive)
    (let ((org-sidebar-default-fns '(+maker/org-sidebar--dashboard-fn)))
      (org-sidebar-toggle)))

  (defun +maker/org-sidebar--planning-fn (source-buffer)
    "Return an Org QL View buffer showing active and high-priority items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Planning*")))
      (let ((org-ql-view-buffer display-buffer)
            (+maker/org-view-scope 'buffer))
        (save-window-excursion (+maker/org-view-planning)))
      display-buffer))
  (defun +maker/org-sidebar-planning ()
    (interactive)
    (let ((org-sidebar-default-fns '(+maker/org-sidebar--planning-fn)))
      (org-sidebar-toggle)))

  (defun +maker/org-sidebar--backlog-fn (source-buffer)
    "Return an Org QL View buffer showing active and high-priority items in SOURCE-BUFFER."
    (let ((display-buffer (org-ql-view--buffer "*Org Sidebar: Org QL View: Backlog*")))
      (let ((org-ql-view-buffer display-buffer)
            (+maker/org-view-scope 'buffer))
        (save-window-excursion (+maker/org-view-backlog)))
      display-buffer))
  (defun +maker/org-sidebar-backlog ()
    (interactive)
    (let ((org-sidebar-default-fns '(+maker/org-sidebar--backlog-fn)))
      (org-sidebar-toggle)))

  (setq org-sidebar-default-fns '(+maker/org-sidebar--dashboard-fn +maker/org-sidebar--planning-fn)))
#+end_src

**** Hydra

Define a view dispatcher hydra.
#+begin_src elisp
(after! (org-ql pretty-hydra)
  (defun +hydra/org-view--format-view-head (name)
    (concat name " "
            (when (not (eq +maker/org-view-scope #'org-agenda-files)) "<")
            (when +maker/org-view-context "@")
            (when +maker/org-view-tags "+")))
  (defun +hydra/org-view--format-tree-head (name)
    (concat name " "
            (when +maker/org-view-context "@")
            (when +maker/org-view-tags "+")))
  (defun +hydra/org-view--format-context-head (val)
    (format "%s %s" (if (equal +maker/org-view-context val) "[x]" "[ ]") val))
  (defun +hydra/org-view--format-tag-head (tag)
    (format "%s %s" (if (member tag +maker/org-view-tags) "[x]" "[ ]") tag))

  (defun +hydra/org-view--set-scope (scope)
    (cl-case scope
      (buffer (progn (setq +maker/org-view-scope 'buffer)))
      (file (let ((file (read-file-name "Select File: " org-directory nil (confirm-nonexistent-file-or-buffer))))
               (when file
                 (setq +maker/org-view-scope file))))
      (t (progn (setq +maker/org-view-scope #'org-agenda-files)))))

  (pretty-hydra-define +hydra/org-view
    (:color teal :separator "‚ïê" :title (+hydra/title-generator "Org Views" "tasks" 51))
    ("Agenda"
     (("ad" (org-agenda current-prefix-arg "d") "day agenda")
      ("aw" (org-agenda current-prefix-arg "w") "week agenda")
      ("ae" (org-agenda current-prefix-arg "e") "week events")
      ("al" (org-agenda current-prefix-arg "l") "week log"))
     "View"
     (("u" +maker/org-view-upcoming (+hydra/org-view--format-view-head "upcoming") :width 13)
      ("d" +maker/org-view-dashboard (+hydra/org-view--format-view-head "dashboard") :width 13)
      ("p" +maker/org-view-planning (+hydra/org-view--format-view-head "planning") :width 13)
      ("b" +maker/org-view-backlog (+hydra/org-view--format-view-head "backlog") :width 13))
     "Tree"
     (("tp" (org-ql-sparse-tree
             (append '(and (todo "PROJ"))
                     (+maker/org-view-make-query +maker/org-view-context +maker/org-view-tags)))
       (+hydra/org-view--format-tree-head "project") :width 10)
      ("tt" (org-ql-sparse-tree
             (append '(and (todo))
                     (+maker/org-view-make-query +maker/org-view-context +maker/org-view-tags)))
       (+hydra/org-view--format-tree-head "todo") :width 10)
      ("tm" (org-ql-sparse-tree
             (append '(and (tags))
                     (+maker/org-view-make-query +maker/org-view-context +maker/org-view-tags)))
       (+hydra/org-view--format-tree-head "tag") :width 10)
      ;; NOTE: Occur command does not support tags as it would hardly make sense
      ("to" (progn (org-check-for-org-mode)
                   (unless +maker/org-view-context
                     (error "Cannot show occurrences of unset context"))
                   (when (eq +maker/org-view-context 'none)
                     (error "Cannot show occurrences of `none' context"))
                   (org-occur +maker/org-view-context))
       (+hydra/org-view--format-tree-head "occur") :width 10))
     "Scope (<)"
     (("<" (+hydra/org-view--set-scope 'all)
       (format "%s all" (if (eq +maker/org-view-scope #'org-agenda-files) "[x]" "[ ]")) :width 18
       :color red)
      ("/" (+hydra/org-view--set-scope 'file)
       (if (and (stringp +maker/org-view-scope) (s-starts-with-p "/" +maker/org-view-scope))
           (format "[x] %s" (file-name-nondirectory +maker/org-view-scope))
         (format "[ ] select file")) :width 18
       :color red)
      ("." (+hydra/org-view--set-scope 'buffer)
       (format "%s current buffer" (if (equal +maker/org-view-scope 'buffer) "[x]" "[ ]")) :width 18
       :color red))
     "Context (@)"
     (("@" (setq +maker/org-view-context nil)
       (format "%s all" (if (not +maker/org-view-context) "[x]" "[ ]")) :width 11
       :color red)
      ("!" (setq +maker/org-view-context 'none) (+hydra/org-view--format-context-head 'none) :width 11 :color red)
      ("s" (setq +maker/org-view-context "@self") (+hydra/org-view--format-context-head "@self") :width 11 :color red)
      ("h" (setq +maker/org-view-context "@home") (+hydra/org-view--format-context-head "@home") :width 11 :color red)
      ("w" (setq +maker/org-view-context "@work") (+hydra/org-view--format-context-head "@work") :width 11 :color red)
      ("P" (setq +maker/org-view-context "@people") (+hydra/org-view--format-context-head "@people") :width 11 :color red))
     "Tags (+)"
     (("+" (setq +maker/org-view-tags nil)
       (format "%s all" (if (not +maker/org-view-tags) "[x]" "[ ]")) :width 10
       :color red)
      ("r" (add-to-list '+maker/org-view-tags "read") (+hydra/org-view--format-tag-head "read") :width 10 :color red)
      ("l" (add-to-list '+maker/org-view-tags "listen") (+hydra/org-view--format-tag-head "listen") :width 10 :color red)
      ("v" (add-to-list '+maker/org-view-tags "watch") (+hydra/org-view--format-tag-head "watch") :width 10 :color red)
      ("n" (add-to-list '+maker/org-view-tags "need") (+hydra/org-view--format-tag-head "need") :width 10 :color red)

      ("q" nil)
      ("<escape>" nil)))))
#+end_src

**** Bindings

Customize bindings.
#+begin_src elisp
(after! (org-ql org-sidebar)
  ;; Leader bindings
  (map! :leader
   :prefix "n"
   :desc "Org upcoming"           "u" #'+maker/org-view-upcoming
   :desc "Org upcoming sidebar"   "U" #'+maker/org-sidebar-agenda-upcoming
   :desc "Org dashboard"          "d" #'+maker/org-view-dashboard
   :desc "Org dashboard sidebar"  "D" #'+maker/org-sidebar-dashboard
   :desc "Org planning"           "p" #'+maker/org-view-planning
   :desc "Org planning sidebar"   "P" #'+maker/org-sidebar-planning
   :desc "Org backlog"            "b" #'+maker/org-view-backlog
   :desc "Org backlog sidebar"    "B" #'+maker/org-sidebar-backlog
   :desc "Org view"               "n" #'+hydra/org-view/body))
#+end_src

*** Block & Source

Configure code editing behavior.
#+begin_src elisp
(after! org
  (setq org-src-fontify-natively 't
        org-src-tab-acts-natively 't
        org-src-preserve-indentation 't
        org-src-window-setup 'current-window
        org-src-ask-before-returning-to-edit-buffer nil
        org-edit-src-persistent-message nil))
#+end_src

Fix ~evil-org-edit-src-exit~ remove evil-write to prevent error when no filename is provided.
#+begin_src elisp
(after! evil-org
  (defun evil-org-edit-src-exit ()
    "Fallback to `evil-edit-src-exit'."
    (interactive)
    (mapc #'call-interactively '(org-edit-src-exit))))
#+end_src

Fix ~evil-save-modified-and-close~ for org-mode temporary buffers.
#+begin_src elisp
(after! evil-org
  (evil-define-command evil-save-modified-and-close (file &optional bang)
    "Saves the current buffer and closes the window."
    :repeat nil
    (interactive "<f><!>")
    (if (and (local-variable-p 'org-finish-function)
             (fboundp org-finish-function))
        (funcall org-finish-function)
      (when (buffer-modified-p)
        (evil-write nil nil nil file bang))
      (evil-quit))))
#+end_src

*** Appearance

Customize org appearance.
#+begin_src elisp
(after! org
  ;; Change the ellipsis to something prettier
  (setq org-ellipsis " ‚ñæ"
        org-tags-column 0
        org-agenda-tags-column 0
        org-catch-invisible-edits 'show-and-error))
#+end_src

Customize priorities faces.
#+begin_src elisp
(after! org
  (setq org-priority-faces
        '((65 . error)
          (66 . warning)
          (67 . success)
          (68 . dired-directory)
          (69 . shadow))))
#+end_src

Customize org-modern.
#+begin_src elisp
(after! org-modern
  (setq org-modern-star 'replace
        ;; Some others: ‚óâ ‚óã ‚óà ‚ú∏ ‚úø ‚ú£ ‚ñ∑
        org-modern-replace-stars "‚óâ‚óã‚óè‚óã‚óè‚óã‚óè‚óã"
        org-modern-block-name '("¬ª" . "¬ª"))

  ;; Fix modern face for DONEPROJ
  (add-to-list 'org-modern-todo-faces `("DONEPROJ" :inverse-video t :inherit org-done))
  ;; Add ultra-bold weight to priorities
  (setq org-modern-priority-faces
        (mapcar (lambda (elt)
                  (let ((prio (car elt))
                        (face-props (cdr elt)))
                    (cons prio (plist-put face-props :weight 'bold))))
                org-modern-priority-faces))
  ;; Fix foreground for tags
  (setq org-modern-tag-faces
        (mapcar (lambda (elt)
                  (let ((tag (car elt))
                        (face-props (cdr elt)))
                    (cons tag (plist-put face-props :background "#212121"))))
                org-modern-tag-faces)))
#+end_src

*** Integration

Advise functions that jump to locations to show context around point in org-mode.
#+begin_src elisp
(after! (evil-vars undo-fu)
  (defadvice! +maker/org-jump-visibility (&rest _)
    :after (list evil-undo-function evil-redo-function
                 #'goto-last-change)
    (when (derived-mode-p 'org-mode)
      (org-show-set-visibility 'lineage))))
#+end_src

Advise functions that unexpectedly scroll window to top to recenter.
#+begin_src elisp
(after! org
  (defadvice! +maker/org-recenter (&rest _)
    :after (list #'org-toggle-heading
                 #'org-archive-subtree)
    (evil-scroll-line-to-center nil)))
#+end_src

*** Popups

Customize popup rules for org-related buffers.
#+begin_src elisp
(after! org
  (set-popup-rules!
    ;; Ignore org-edit-src-code buffers, display as regular buffers.
    '(("^\\*Org Src" :ignore t))))
#+end_src

*** Commands

Add a command to always spawn new indirect buffers.
#+begin_src elisp
(after! org
  (defun +maker/org-tree-to-indirect-buffer-new ()
    (interactive)
    (let ((orig-buffer (current-buffer))
          (current-prefix-arg '(4)))
      (call-interactively 'org-tree-to-indirect-buffer)
      (setq-local doom--narrowed-base-buffer orig-buffer)))

  (defun +maker/org-show-current-heading-tidily ()
    (interactive)  ;Inteactive
    "Show next entry, keeping other entries closed."
    (if (save-excursion (end-of-line) (outline-invisible-p))
        (progn (org-show-entry) (show-children))
      (org-overview)
      (org-reveal t)
      (when (org-on-heading-p)
        (org-show-entry)
        (show-children))
      (evil-scroll-line-to-center (line-number-at-pos)))))
#+end_src

*** Bindings

Restore original TAB behavior to cycle through current subtree recursively.
#+begin_src elisp
;; (after! evil-org
;;   (remove-hook 'org-tab-first-hook #'+org-cycle-only-current-subtree-h))
#+end_src

Customize bindings.
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        ;; Prefer smart beginning of line to digit argument? (overridden)
        :m "0"               #'evil-org-beginning-of-line
        ;; Add quick motion bindings
        :ni "C-k"     (cmds! (org-at-table-p) #'+org/table-previous-row
                             (bound-and-true-p evil-insert-state-minor-mode) #'evil-previous-line
                             #'org-backward-paragraph)
        :ni "C-j"     (cmds! (org-at-table-p) #'org-table-next-row
                             (bound-and-true-p evil-insert-state-minor-mode) #'evil-next-line
                             #'org-forward-paragraph)
        :ni "C-h"     (cmds! (org-at-table-p) #'org-table-previous-field
                             (bound-and-true-p evil-insert-state-minor-mode) #'left-char
                             #'evil-backward-word-begin)
        :ni "C-l"     (cmds! (org-at-table-p) #'org-table-next-field
                             (bound-and-true-p evil-insert-state-minor-mode) #'right-char
                             #'evil-forward-word-begin)
        ;; Prefer visible headings to same-level
        :ni "C-S-k"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'org-backward-paragraph
                             #'org-previous-visible-heading) ; org-backward-heading-same-level)
        :ni "C-S-j"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'org-forward-paragraph
                             #'org-next-visible-heading) ; org-forward-heading-same-level)
        ;; Allow subtree traversal
        :ni "C-S-h"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'evil-backward-word-begin
                             #'org-up-element)
        :ni "C-S-l"   (cmds! (bound-and-true-p evil-insert-state-minor-mode) #'evil-forward-word-begin
                             #'org-down-element)

        ;; Evil replacements
        :g "C-M-k"          #'org-shiftup
        :g "C-M-j"          #'org-shiftdown
        :g "C-M-h"          #'org-shiftleft
        :g "C-M-l"          #'org-shiftright
        :g "C-M-S-k"        #'org-shiftcontrolup
        :g "C-M-S-j"        #'org-shiftcontroldown
        :g "C-M-S-h"        #'org-shiftcontrolleft
        :g "C-M-S-l"        #'org-shiftcontrolright

        ;; Consistent narrowing commands with other modes.
        :nv "zn"            #'org-narrow-to-subtree
        :nv "zN"            #'+maker/org-tree-to-indirect-buffer-new

        ;; Bind custom implementation of prev/next fold commands for org-mode.
        ;; FIXME: +fold/next stopped working in org-mode at some point in 2021...
        :m "zj"             #'+maker/org-next-heading
        :m "zk"             #'+maker/org-previous-heading

        ;; Bind org-reveal to something more accessible and consistent.
        :n "z <return>"     #'org-reveal
        :n "z RET"          #'org-reveal
        :n "zm"             #'+maker/org-show-current-heading-tidily

        ;; Move some bindings in org-mode-map so that it can be easily overridden in derived maps.
        :nv [tab]           nil
        :nv "TAB"           nil
        :nv [S-tab]         nil
        :nv [S-iso-lefttab] nil
        :nv [backtab]       nil
        :ni [return]        nil
        :ni "RET"           nil
        :i [S-return]       nil
        :i "S-RET" nil

        :map org-mode-map
        :g "M-{"           nil
        :g "M-}"           nil
        :m [tab]           #'org-cycle
        :m "TAB"           #'org-cycle
        :m [S-tab]         #'org-shifttab
        :m [S-iso-lefttab] #'org-shifttab
        :m [backtab]       #'org-shifttab
        :n [return]        #'+org/dwim-at-point
        :n "RET"           #'+org/dwim-at-point
        :i [return]        (cmd! (org-return electric-indent-mode))
        :i "RET"           (cmd! (org-return electric-indent-mode))
        ;; This looks like a fix for doom
        :ni [S-return]     #'+org/shift-return
        :ni "S-RET"        #'+org/shift-return

        ;; Bind alternative DWIM command
        :n "S-SPC"         #'org-ctrl-c-ctrl-c
        ;; M-RET difficult choices
        ;; - normal-mode: org-ctrl-c-ret
        ;;   Always insert headings and not list items: straight to the point. Useful to split headings.
        ;;   More appropriate behavior in tables (or I don't understand how wrapping works)
        ;; - insert-mode: org-meta-return
        ;;   More appropriate to break an item/heading in two, supports the respect-content setting
        :gn [M-return]       #'org-ctrl-c-ret
        :gn "M-RET"          #'org-ctrl-c-ret
        :i [M-return]        #'org-meta-return
        :i "M-RET"           #'org-meta-return
        ;; This is more consistent for me
        :g [M-S-return]      #'org-insert-subheading
        :g "M-S-RET"         #'org-insert-subheading
        :g [C-M-return]      #'org-insert-todo-heading
        :g "C-M-RET"         #'org-insert-todo-heading
        :g [C-M-S-return]    #'org-insert-todo-subheading
        :g "C-M-S-RET"       #'org-insert-todo-subheading

        ;; Override +fold/close-all, it seems broken in org-mode
        :m "<backtab>"       #'org-shifttab
        :m "C-<iso-lefttab>" #'org-ctrl-c-tab

        (:localleader
         "p"                 #'org-priority
         "f"                 #'+org/fix-blank-lines
         "F"                 #'org-footnote-action
         "D"                 #'org-insert-drawer
         "H"                 #'org-list-make-subtree
         "O"                 #'org-property-action
         "X"                 #'org-toggle-radio-button
         "T"                 #'+maker/org-todo-with-date
         "C"                 #'org-timer-set-timer
         "I"                 #'org-timer-item
         "e"                 #'org-edit-special
         "E"                 #'org-export-dispatch
         "-"                 #'org-ctrl-c-minus
         "+"                 nil
         (:prefix ("s" . "Tree/Subtree")
                  "A"                #'org-archive-to-archive-sibling
                  "o"                #'org-toggle-ordered-property
                  "r"                nil)
         (:prefix ("c" . "Clock")
                  "s"                #'org-clock-display
                  "G"                #'+org-clock-goto-select)
         (:prefix ("g" . "Goto")
                  "C"                #'+org-clock-goto-select)
         (:prefix ("l" . "Links")
                  ;; Remove org-id-store-link since it doesn't work anyway...
                  ;; See https://github.com/doomemacs/doomemacs/issues/3085
                  "i"                nil)
         ))

  ;; TODO: which-key description overrides...
  (map! :leader
        :prefix ("n" . "Notes")
        :desc "Toggle last clock"
        "t"                #'+org/toggle-last-clock
        :desc "Goto last clock"
        "c"                #'org-clock-goto
        :desc "Goto clock history"
        "C"                #'+org-clock-goto-select)

  ;; Cancel remapping of org-set-tags-command (behavior is much more complete)
  (define-key!
    [remap org-set-tags-command] nil))
#+end_src

*** Performance

Disable flyspell by default in org-mode (laggy).
#+begin_src elisp
(remove-hook! org-mode #'flyspell-mode)
#+end_src

Remove the tangle-on-save hook and add a manual binding.
#+begin_src elisp
(remove-hook! org-mode #'+literate-enable-recompile-h)
(defun +literate-recompile ()
  "Recompile literate config to `doom-private-dir"
  (interactive)
  (+literate-recompile-maybe-h))
(map! :map org-mode-map
      :localleader
      "R" #'+literate-recompile)
#+end_src

Improve org performance by removing some candy.
See [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#why-is-emacsdoom-slow][this section of the doom FAQ]].
#+begin_src elisp
(after! org
  (setq org-fontify-whole-heading-line nil
        org-fontify-quote-and-verse-blocks nil
        ;; THIS is the main thing that improves performance when expanding trees.
        org-highlight-latex-and-related nil))
#+end_src

** Org QL

Configuration and integration with doom.
#+begin_src elisp
(use-package! org-ql
  :after org
  :config
  ;; Do not consider org QL Views as popups and use the same window behavior than agenda.
  (set-popup-rule! "^\\*Org QL View:" :ignore 't)
  (setq org-ql-view-display-buffer-action '(display-buffer-same-window))

  ;; This mechanism for selecting org views is not used. Use the org-view hydra instead.
  (setq org-ql-views nil)

  ;; Override magit's default of `display-buffer-below-selected` and restore original value.
  ;; It causes `org-ql-view-dispatch` to show in a horizontal split.
  (setq transient-display-buffer-action
        '(display-buffer-in-side-window
          (side . bottom)
          (dedicated . t)
          (inhibit-same-window . t)
          (window-parameters (no-other-window . t)))))
#+end_src

Customize bindings and integrate with doom/evil.
#+begin_src elisp
(after! org-ql-view
  ;; Configure bindings to override default evil bindings
  (evil-make-overriding-map org-ql-view-map 'normal)
  (map! :map org-ql-view-map
        :g "q" #'org-agenda-quit
        :g "r" #'org-ql-view-refresh
        :g "C-r" #'org-ql-view-dispatch
        :g "C-s" #'org-ql-view-save)
  (evil-make-overriding-map org-ql-view-list-map 'normal)
  (map! :map org-ql-view-list-map
        :n [return]     #'org-ql-view-switch
        :n "RET"        #'org-ql-view-switch
        :n "c"          #'org-ql-view-customize
        :n "q"          #'bury-buffer))
#+end_src

** Org sidebar

Configuration and integration with doom.
#+begin_src elisp
(use-package! org-sidebar
  :config
  ;; Make org-ql-view windows not selectable by 'other-window'
  (setq org-ql-view-no-other-window t))
#+end_src

*** Tree

Make tree sidebar buffers hidden.
#+begin_src elisp
(after! org-sidebar
  (cl-defun org-sidebar-tree-view-buffer (&key (buffer (current-buffer)) &allow-other-keys)
    "Return a tree-view buffer for BUFFER."
    (-let* ((buffer-name (format " *Tree: %s*" (buffer-name buffer))) ; NOTE: EDIT
            ((min max) (with-current-buffer buffer
                         (list (point-min) (point-max))))
            (existing-buffer (get-buffer buffer-name))
            tree-buffer)
      (when existing-buffer
        ;; Buffer with name already exists.
        (if (buffer-base-buffer existing-buffer)
            ;; Buffer is indirect: kill it so we can remake it.
            (kill-buffer existing-buffer)
          ;; Buffer is not indirect: something is probably wrong, so warn.
          (warn "Existing tree buffer that is not indirect: %s" existing-buffer)))
      (setf tree-buffer (clone-indirect-buffer buffer-name nil 'norecord))
      (with-current-buffer tree-buffer
        (use-local-map org-sidebar-tree-map)
        (setf mode-line-format nil
              header-line-format (concat "Tree: " (buffer-name buffer)))
        (toggle-truncate-lines 1)
        (centaur-tabs-local-mode 1) ; NOTE: EDIT
        (save-excursion
          (goto-char min)
          (if (org-before-first-heading-p)
              (progn
                ;; Narrow buffer to exclude pre-heading content.
                (outline-next-heading)
                (setf min (point)))
            ;; Tree view only shows one subtree: expand its branches.
            (outline-show-branches)))
        (narrow-to-region min max)
        (save-excursion
          ;; Hide visible entry bodies.
          (goto-char (point-min))
          (when (org-before-first-heading-p)
            (outline-next-visible-heading 1))
          (cl-loop do (outline-hide-body)
                   while (outline-next-visible-heading 1)))
        (unless (org-before-first-heading-p)
          (outline-back-to-heading)))
      tree-buffer)))
#+end_src

Custom toggle function to autofocus the tree sidebar.
#+begin_src elisp
(after! org-sidebar
  ;;
  (defun +maker/org-sidebar-tree-toggle ()
    (interactive)
    (org-sidebar-tree-toggle)
    (let* ((tree-window (--first (window-parameter it 'org-sidebar-tree-window)
                                 (window-at-side-list nil org-sidebar-tree-side))))
      (when tree-window (select-window tree-window)))))
#+end_src

*** Sidebar

Make sure truncate line is enabled instead of toggled.
#+begin_src elisp
(after! org-sidebar
  (remove-hook 'org-ql-sidebar-buffer-setup-hook #'toggle-truncate-lines)
  (add-hook! 'org-ql-sidebar-buffer-setup-hook
    (defun maker/org-sidebar-buffer-setup ()
      (toggle-truncate-lines 1))))
#+end_src

Workaround issue displaying sidebar buffers.
#+begin_src elisp
;; (after! org-sidebar
;;   ;; NOTE: This was NOT happening when I started using sidebar, and suddenly started to happen
;;   ;; while I was working on other emacs stuff. Need to identify the cause for  this.
;;   (add-hook! 'org-sidebar-window-after-display-hook
;;     (defun maker/org-sidebar-fix-display ()
;;       (force-window-update (selected-window))
;;       (redisplay))))
#+end_src

Allow regular org-agenda buffers to be present in sidebar.
#+begin_src elisp
(after! org-sidebar
  (defun org-sidebar-refresh ()
    "Refresh sidebar buffers.
  Refreshes the current sidebar buffer and other associated sidebar
  buffers."
    (interactive)
    (save-window-excursion
      (let ((source-buffer org-sidebar-source-buffer)
            (display-buffers (buffer-local-value 'org-sidebar-sidebar-buffers org-sidebar-source-buffer)))
        (--each display-buffers
          (when (buffer-live-p it)
            (with-current-buffer it
              (let ((old-buffer-name (buffer-name)))
                (cond (org-ql-view-buffers-files (org-ql-view-refresh)) ; NOTE: EDIT
                      (t (org-agenda-redo)))
                ;; Restore buffer name (because `org-ql-view-refresh' changes it).
                (rename-buffer old-buffer-name)
                (setf org-sidebar-source-buffer source-buffer) ; NOTE: EDIT
                (org-sidebar--prepare-buffer))))))))

  (defun org-sidebar--prepare-buffer ()
    "Prepare current buffer as a sidebar buffer.
  This is not used for `org-sidebar-tree' buffers."
    (let ((inhibit-read-only t))
      (when org-ql-view-title ; NOTE: EDIT
        (setf header-line-format (org-ql-view--header-line-format :title org-ql-view-title)))
      (use-local-map org-sidebar-map)
      ;; (goto-char (point-min)) ; TODO Gives initial focus but resets during refresh also...
      (run-hook-with-args 'org-ql-sidebar-buffer-setup-hook))))
#+end_src

Improve sidebar window behavior: dedicated, fixed-size, ...
#+begin_src elisp
(after! org-sidebar
  (cl-defun org-sidebar--display-buffers (buffers &key window-parameters)
    "Display BUFFERS in the sidebar.
  WINDOW-PARAMETERS are applied to each window that is displayed."
    (declare (indent defun))
    (when-let* ((side-windows (window-at-side-list nil org-sidebar-side))
                (sidebar-buffers (--select (buffer-local-value 'org-sidebar-source-buffer it)
                                           (mapcar #'window-buffer side-windows)))
                (sidebar-windows (mapcar #'get-buffer-window sidebar-buffers)))
      ;; Delete existing org-sidebar windows on our side.
      (mapc #'delete-window sidebar-windows))
    (let ((slot 0)
          (window-parameters (append (list (cons 'no-delete-other-windows nil))
                                     window-parameters)))
      (--each buffers
        (when-let* ((window (+popup-display-buffer-stacked-side-window-fn ; NOTE: EDIT
                             it
                             (list (cons 'side org-sidebar-side)
                                   (cons 'slot slot)
                                   (cons 'dedicated t) ; NOTE: EDIT
                                   (cons 'window-width .20) ; NOTE: EDIT
                                   (cons 'preserve-size (cons t nil)) ; NOTE: EDIT
                                   (cons 'window-parameters window-parameters)))))
          (with-selected-window window
            (run-hooks 'org-sidebar-window-after-display-hook))
          (if (eq slot 0)
              (select-window window)) ; NOTE: EDIT (goto-char call no longer focuses window for some reason)
          (cl-incf slot))))))
#+end_src

Improve toggling behavior:
- Do not toggle off if the given list of function differs from the current sidebar
- Allow changing view from the sidebar buffer
- Allow toggling off from the sidebar buffer
#+begin_src elisp
(after! org-sidebar
  (defvar-local org-sidebar-source-fns nil
    "Org sidebar functions that this sidebar buffer was generated from.")

  (defun org-sidebar (fns)
    "Display the Org Sidebar.
Interactively, display the sidebars configured in
`org-sidebar-default-fns'.
FNS should be one or a list of functions which return a buffer to
be displayed in the sidebar.  Each one is called with the current
buffer as its argument."
    (interactive (list org-sidebar-default-fns))
    (when org-sidebar-sidebar-buffers
      ;; Kill existing sidebar buffers for the source buffer.
      (mapc #'kill-buffer org-sidebar-sidebar-buffers)
      (setf org-sidebar-sidebar-buffers nil))
    (let* ((source-buffer (current-buffer))
           (fns (cl-etypecase fns
                  (list fns)
                  (atom (list fns))))
           (display-buffers (cl-loop for fn in fns
                                     collect (funcall fn source-buffer))))
      (when display-buffers
        (setf org-sidebar-sidebar-buffers display-buffers)
        (--each display-buffers
          (with-current-buffer it
            (org-sidebar--prepare-buffer)
            (setf org-sidebar-source-fns fns) ; NOTE: EDIT
            (setf org-sidebar-source-buffer source-buffer)))
        (org-sidebar--display-buffers display-buffers
          :window-parameters (list (cons 'org-sidebar-window t)
                                   (cons 'org-sidebar-source-buffer-point-min (point-min)))))))

  (defun org-sidebar-toggle (&optional fns)
    "Toggle default sidebar window.
If it is open and shows the view for the current buffer, delete
it.  Otherwise, show it for current buffer."
    (interactive)
    (let* ((fns (or fns org-sidebar-default-fns)) ; NOTE: EDIT
           (source-buffer (current-buffer))
           (point-min (point-min))
           (sidebar-window (--first (window-parameter it 'org-sidebar-window)
                                    (window-at-side-list nil org-sidebar-side))))
      ;; NOTE: EDIT: if the sidebar window is selected, use the sidebar source-buffer instead.
      (if (eq sidebar-window (selected-window))
          (setq source-buffer
                (buffer-local-value 'org-sidebar-source-buffer (window-buffer sidebar-window))
                point-min (with-current-buffer source-buffer (point-min))))
      ;; We only compare the first sidebar window, but that should be good enough.
      (if (and sidebar-window
               (with-current-buffer (window-buffer sidebar-window)
                 ;; NOTE: EDIT: Compare source functions to avoid toggling off when requesting another view.
                 (and (eq fns (buffer-local-value 'org-sidebar-source-fns (current-buffer)))
                      (eq org-sidebar-source-buffer source-buffer)
                      ;; Compare point-min to detect narrowed buffers.
                      (eq (window-parameter sidebar-window 'org-sidebar-source-buffer-point-min)
                          point-min))))
          ;; Sidebar is for current buffer: delete sidebar windows.
          (mapc #'delete-window (--select (window-parameter it 'org-sidebar-window)
                                          (window-at-side-list nil org-sidebar-side)))
        ;; Sidebar is for a different buffer: show sidebar for current buffer.
        (with-current-buffer source-buffer ; NOTE: EDIT
          (org-sidebar fns)))))

  (defun +maker/org-sidebar-close ()
    "Close the org-sidebar window"
    (interactive)
    (mapc #'delete-window (--select (window-parameter it 'org-sidebar-window)
                                    (window-at-side-list nil org-sidebar-side)))))
#+end_src

Attempt to prevent narrowed org files (directly or indirectly) from being widened when selecting entries from org views.
#+begin_src elisp
(after! org-sidebar
  (defun maker/org-agenda-switch-to (&optional delete-other-windows)
    "Go to the Org mode file which contains the item at point.
When optional argument DELETE-OTHER-WINDOWS is non-nil, the
displayed Org file fills the frame."
    (interactive)
    (if (and org-return-follows-link
             (not (org-get-at-bol 'org-marker))
             (org-in-regexp org-link-bracket-re))
        (org-link-open-from-string (match-string 0))
      (let* ((marker (or (org-get-at-bol 'org-marker)
                         (org-agenda-error)))
             (buffer (marker-buffer marker))
             (pos (marker-position marker))
             ;; NOTE: EDIT
             (in-sidebar-window (eq (selected-window) (--first (window-parameter it 'org-sidebar-window)
                                                               (window-at-side-list nil org-sidebar-side)))))
        (unless buffer (user-error "Trying to switch to non-existent buffer"))
        (pop-to-buffer-same-window buffer)
        (when delete-other-windows
          (display-buffer (current-buffer) '(org-display-buffer-full-frame)))
        ;; NOTE: EDIT
        (unless in-sidebar-window
          (widen))
        (goto-char pos)
        (when (derived-mode-p 'org-mode)
          (org-fold-show-context 'agenda)
          (run-hooks 'org-agenda-after-show-hook)))))
  (advice-add #'org-agenda-switch-to :override #'maker/org-agenda-switch-to)

  (defun maker/org-agenda-goto (&optional highlight)
    "Go to the entry at point in the corresponding Org file."
    (interactive)
    (let* ((marker (or (org-get-at-bol 'org-marker)
		       (org-agenda-error)))
	   (buffer (marker-buffer marker))
	   (pos (marker-position marker))
           ;; NOTE: EDIT
           (in-sidebar-window (eq (selected-window) (--first (window-parameter it 'org-sidebar-window)
                                                             (window-at-side-list nil org-sidebar-side)))))
      
      (switch-to-buffer-other-window buffer)
      ;; NOTE: EDIT
      (unless in-sidebar-window
        (widen))
      (push-mark)
      (goto-char pos)
      (when (derived-mode-p 'org-mode)
        (org-fold-show-context 'agenda)
        (recenter (/ (window-height) 2))
        (org-back-to-heading t)
        (let ((case-fold-search nil))
	  (when (re-search-forward org-complex-heading-regexp nil t)
	    (goto-char (match-beginning 4)))))
      (run-hooks 'org-agenda-after-show-hook)
      (and highlight (org-highlight (line-beginning-position)
                                    (line-end-position)))))
  (advice-add #'org-agenda-goto :override #'maker/org-agenda-goto))
#+end_src

Restore ~org-sidebar-window~ window parameter when switching workspaces, otherwise sidebar commands are failing to find the existing window.
It is unclear why the parameter is not saved/restored automatically.
#+begin_src elisp
(after! org-sidebar
  (defun +maker/org-sidebar--persp-restore-window-param (_)
    "Restore window-parameter `org-sidebar-window' on persp change."
    (mapc (lambda (win)
        (set-window-parameter win 'org-sidebar-window t))
      (--select (eq (window-parameter it 'window-side) org-sidebar-side)
                (window-at-side-list nil org-sidebar-side))))
  (add-hook! 'persp-activated-functions #'+maker/org-sidebar--persp-restore-window-param))
#+end_src

*** Bindings

Integrate with doom/evil bindings.
#+begin_src elisp
(after! org-sidebar
  ;; Leader bindings
  (map! :leader :prefix "n"
        :desc "Org task sidebar"  "o" #'org-sidebar-toggle
        :desc "Org tree sidebar"  "O" #'+maker/org-sidebar-tree-toggle)

  ;; q must delete ALL open sidebar windows...
  (map! :map org-sidebar-map
        "q" #'+maker/org-sidebar-close)

  ;; Configure bindings to override default org/evil bindings
  (evil-make-overriding-map org-sidebar-tree-map 'normal)
  (map! :map org-sidebar-tree-map
        :n [return]        #'org-sidebar-tree-jump
        :n "RET"           #'org-sidebar-tree-jump
        :n [tab]           #'org-sidebar-tree-cycle
        :n "TAB"           #'org-sidebar-tree-cycle
        :n [S-tab]         #'org-sidebar-tree-cycle-global
        :n [S-iso-lefttab] #'org-sidebar-tree-cycle-global
        :n [backtab]       #'org-sidebar-tree-cycle-global

        :m "q"             #'org-sidebar-tree-toggle)
  (add-hook! 'org-sidebar-window-after-display-hook #'evil-normalize-keymaps))
#+end_src

** Org super agenda

Configuration and integration with doom.
#+begin_src elisp
(use-package! org-super-agenda
  :config
  (org-super-agenda-mode)
  (setq org-super-agenda-header-prefix "‚óã " ; Needed for outline mode to recognize headings
        org-super-agenda-hide-empty-groups 't
        org-super-agenda-keep-order nil) ; Perf-hungry, enable if noticing sort issues

  ;; Default super-groups.
  (setq org-super-agenda-groups
        '((:auto-outline-path t :order 99))))
#+end_src

Add selector to org-super-agenda.
TODO: Contribute this. Now unused though.
#+begin_src elisp
(after! org-super-agenda
  (org-super-agenda--defgroup outline-path-regexp
    "Group items whose outline path match any of the given regular expressions.
  Argument may be a string or list of strings, each of which should
  be a regular expression.  You'll probably want to override the
  section name for this group."
    :section-name (concat "Outline paths matching regexps: "
                          (s-join " OR "
                                  (--map (s-wrap it "\"")
                                         args)))
    :let* ((case-fold-search t))
    :test (org-super-agenda--when-with-marker-buffer (org-super-agenda--get-marker item)
            (let ((outline-path (s-join "/" (org-get-outline-path))))
              (cl-loop for regexp in args
                       thereis (string-match-p regexp outline-path))))))
#+end_src

Integrate with outline-minor-mode to allow folding agenda days and groups.
#+begin_src elisp
(after! org-super-agenda
  (defvar org-super-agenda-auto-fold-groups '())

  ;; Function borrowed from new fork of origami.el https://github.com/emacs-origami/origami.el/blob/master/origami.el#L1024
  (defun outline-auto-agenda (pattern-or-patterns function)
    "Search buffer and apply the FUNCTION on each line.
PATTERN-OR-PATTERNS is a string or a list of strings to search"
    (interactive)
    (let ((patterns (if (listp pattern-or-patterns) pattern-or-patterns (list pattern-or-patterns))))
      (save-excursion
        (dolist (pattern patterns)
          (goto-char (point-min))
          (while (re-search-forward pattern nil t 1)
            (unless (outline-invisible-p)
              (funcall function)))))))

  (defun outline-agenda-setup ()
    (setq-local outline-regexp "\\([A-Za-z]+\\|‚ãØ\\|‚óã \\)")
    (setq-local outline-level #'outline-level)
    (setq-local outline-blank-line t)
    (setq-local outline-heading-alist
                `(("Monday" . 2)
                  ("Tuesday" . 2)
                  ("Wednesday" . 2)
                  ("Thursday" . 2)
                  ("Friday" . 2)
                  ("Saturday" . 2)
                  ("Sunday" . 2)
                  ("‚ãØ" . 2)
                  (,org-super-agenda-header-prefix . 3)))
    (outline-auto-agenda org-super-agenda-auto-fold-groups #'outline-hide-subtree))

  (add-hook! 'org-agenda-mode-hook #'outline-minor-mode)
  (add-hook! 'org-agenda-finalize-hook #'outline-agenda-setup))
#+end_src

Make outline ellipsis the same than org ellipsis.
#+begin_src elisp
(after! org-super-agenda
  (defvar outline-display-table (make-display-table))
  (set-display-table-slot outline-display-table 'selective-display
                          (vector " " (make-glyph-code ?‚ñæ 'shadow)))
  (defun set-outline-display-table ()
    (setf buffer-display-table outline-display-table))

  (add-hook 'outline-mode-hook 'set-outline-display-table)
  (add-hook 'outline-minor-mode-hook 'set-outline-display-table))
#+end_src

Remap all bindings from org-agenda-mode-map which are not overridden by evil.
- https://github.com/alphapapa/org-super-agenda/issues/50
- https://github.com/noctuid/evil-guide#prevent-text-property-maps-from-overriding-evil
#+begin_src elisp
(after! org-super-agenda
  (setq org-super-agenda-header-map (make-sparse-keymap))
  (map! :map org-super-agenda-header-map
        "q"             #'org-agenda-quit
        "r"             #'org-agenda-redo))

(after! evil-org-agenda
  (map! :map evil-org-agenda-mode-map
        :m "TAB"           #'outline-cycle
        :m "<tab>"         #'outline-cycle
        :m "<backtab>"     #'outline-cycle-buffer))
#+end_src

** Perspective

Use a different workspace directory for each daemon instances.
#+begin_src elisp
(after! persp-mode
  (add-hook! 'after-make-frame-functions
    (defun +maker/set-persp-save-dir-for-server (_)
      (unless (or (string-empty-p server-name) (equal server-name "server"))
        (setq persp-save-dir (concat doom-etc-dir "workspaces@" server-name "/"))))))
#+end_src

Restore uniquify settings, against developer advice. I need this.
#+begin_src elisp
(add-hook! persp-mode
  (defun +workspace-force-uniquify-buffer-style ()
    (setq uniquify-buffer-name-style 'forward)))
#+end_src

Do not save indirect buffers in session.
FIXME: Saving the 'vars' argument in [[file:~/.config/emacs/modules/ui/workspaces/config.el::defvar +workspaces--indirect-buffers-to-restore nil][doom's workspace configuration]] breaks the session file.
It is then impossible to load the session file (Invalid read syntax: #).
Also it seems that without saving 'vars', indirect buffers are restored as clones of the base buffer, so not useful at all.
See also https://github.com/Bad-ptr/persp-mode.el/issues/93
#+begin_src elisp
(add-hook! 'persp-filter-save-buffers-functions
  (defun +workspaces-indirect-buffer-p (buf)
    (buffer-base-buffer buf)))
#+end_src

** Projectile

Customize general projectile options.
#+begin_src elisp
(after! projectile
  :config
  (setq projectile-track-known-projects-automatically nil
        ;; Open dired when switching projects
        projectile-switch-project-action #'projectile-dired
        ;; Make compilation buffers project-specific
        compilation-buffer-name-function #'projectile-compilation-buffer-name
        compilation-save-buffers-predicate #'projectile-current-project-buffer-p))
#+end_src

Add project name in the modeline.
#+begin_src elisp
(after! projectile
  :config
  (setq doom-modeline-project-name 't))
#+end_src

Add helper function to retrieve the notes file for a project.
#+begin_src elisp
(after! projectile
  (defun +maker/projectile-get-project-notes-file (&optional project-root)
    (let* ((project-root (or project-root (projectile-project-root)))
           (project-name (projectile-project-name project-root)))
      (when project-root
        (format "%s%s.org" (file-name-as-directory project-root) project-name)))))
#+end_src

Customize bindings.
#+begin_src elisp
(after! (projectile which-key)
  ;; Remove previous which-key descriptions.
  ;; TODO: Encapsulate in a function and use a regex.
  (cl-delete-if
   (lambda (x)
     (member (car x)
             '(("\\`M-SPC p t\\'")
               ("\\`SPC p t\\'")
               ("\\`M-SPC p g\\'")
               ("\\`SPC p g\\'")
               ("\\`M-SPC p D\\'")
               ("\\`SPC p D\\'")
               ("\\`M-SPC p C\\'")
               ("\\`SPC p C\\'"))))
   which-key-replacement-alist)
  (map! :leader :prefix "p"
        ;; Adapt default bindings
        :desc "List project todos"           "l"   #'magit-todos-list
        :desc "Find test file"               "t"   #'projectile-find-test-file
        :desc "Discover projects in folder"  "A"   #'+default/discover-projects
        :desc "Compile in project"           "B"   #'project-compile
        :desc "Configure project"            "C"   #'projectile-configure-project
        :desc "Install project"              "I"   #'projectile-install-project
        :desc "Run GDB in project"           "D"   #'projectile-run-gdb
        :desc "Repeat last command"          ";"   #'projectile-repeat-last-command
        ;; Bind additional commands.
        :desc "Find impl/test"               "O"   #'projectile-find-implementation-or-test
        :desc "Replace in project"           "%"   #'projectile-replace
        :desc "Replace regexp in project"    "M-%" #'projectile-replace-regexp
        :desc "Open dired"                   "-"   #'projectile-dired))
#+end_src

** Rainbow identifiers

#+begin_src elisp
(use-package! rainbow-identifiers
  :config
  (setq rainbow-identifiers-choose-face-function 'rainbow-identifiers-cie-l*a*b*-choose-face
        rainbow-identifiers-cie-l*a*b*-lightness 87
        rainbow-identifiers-cie-l*a*b*-saturation 17))
#+end_src

** Scroll on jump

Define a global mode for scroll-on-jump and bind to relevant commands.
Disabled for now, scrolling does not work nicely in org-mode (or when there is folded content in general)
#+begin_src elisp
;; (use-package! scroll-on-jump
;;   :after evil
;;   :hook (doom-first-file . scroll-on-jump-mode)
;;   :config
;;   (setq scroll-on-jump-duration 0.4)

;;   ;; XXX: For some really obscure reason, the order in which these functions
;;   ;; are declared defines which one will actually work. Currently turning off
;;   ;; doesn't work, unless this code is re-evaluated from the emacs instance.
;;   ;; If the turn-off function is declared after the turn-on, then turning on
;;   ;; will similarly not work. Someone help me understand this plz.
;;   (defun scroll-on-jump--turn-off ()
;;     (scroll-on-jump-advice-remove set-mark-command)
;;     (scroll-on-jump-advice-remove goto-last-change)
;;     (scroll-on-jump-advice-remove goto-last-change-reverse)
;;     ;; (scroll-on-jump-advice-remove evil-undo)
;;     ;; (scroll-on-jump-advice-remove evil-redo)
;;     ;; (scroll-on-jump-advice-remove evil-goto-mark)
;;     (scroll-on-jump-advice-remove evil-goto-mark-line)
;;     (scroll-on-jump-advice-remove evil-ex-search-next)
;;     (scroll-on-jump-advice-remove evil-ex-search-previous)
;;     (scroll-on-jump-advice-remove evil-ex-search-forward)
;;     (scroll-on-jump-advice-remove evil-ex-search-backward))
;;   (defun scroll-on-jump--turn-on ()
;;     (scroll-on-jump-advice-add set-mark-command)
;;     (scroll-on-jump-advice-add goto-last-change)
;;     (scroll-on-jump-advice-add goto-last-change-reverse)
;;     ;; (scroll-on-jump-advice-add evil-undo)
;;     ;; (scroll-on-jump-advice-add evil-redo)
;;     ;; (scroll-on-jump-advice-add evil-goto-mark) ; Also triggers on paste - undesired
;;     (scroll-on-jump-advice-add evil-goto-mark-line)
;;     (scroll-on-jump-advice-add evil-ex-search-next)
;;     (scroll-on-jump-advice-add evil-ex-search-previous)
;;     (scroll-on-jump-advice-add evil-ex-search-forward)
;;     (scroll-on-jump-advice-add evil-ex-search-backward))

;;   (define-minor-mode scroll-on-jump-mode
;;     "Minor-mode to animate scroll and recenter when the point jumps."
;;     :group 'scroll-on-jump
;;     :global t
;;     (if scroll-on-jump-mode
;;         (scroll-on-jump--turn-on)
;;       (scroll-on-jump--turn-off))))
#+end_src

** TLDR

Improve tldr integration.
#+begin_src elisp
(use-package! tldr
  :config
  ;; Use the same popup settings than for man/woman (w smaller size)
  (defadvice! +popup--use-popup-window-for-tldr (fn &rest args)
    :around #'tldr
    (letf! ((#'switch-to-buffer-other-window #'pop-to-buffer))
      (apply fn args)))
  (set-popup-rule! "^\\*tldr"
    :vslot -6 :size 0.35 :select t :quit t :ttl 0)

  ;; Add global binding
  (map! :leader :prefix "h"
        "l" #'tldr))
#+end_src

** Treemacs

Configure treemacs appearance and behavior.
#+begin_src elisp
(use-package! treemacs
  :init
  (setq doom-themes-treemacs-theme "all-the-icons"
        +treemacs-git-mode 'deferred)
  :config
  (setq treemacs-recenter-after-file-follow 'always)
  (custom-set-faces!
    '(treemacs-root-face :inherit (variable-pitch font-lock-builtin-face))
    '(treemacs-all-the-icons-root-face :inherit font-lock-builtin-face)
    '(treemacs-fringe-indicator-face :inherit cursor)))
#+end_src

Customize bindings.
#+begin_src elisp
(after! treemacs-evil
  (defun treemacs-toggle-node-nested ()
    (interactive)
    (treemacs-toggle-node '(4)))

  (defun treemacs-visit-node-nofocus ()
    (interactive)
    (treemacs-visit-node-default '(4)))

  (evil-define-key* 'treemacs treemacs-mode-map
    (kbd "h")          #'treemacs-goto-parent-node
    (kbd "l")          #'treemacs-toggle-node
    (kbd "<")          #'treemacs-root-up
    (kbd ">")          #'treemacs-root-down
    (kbd "L")          #'treemacs-toggle-node-nested
    (kbd "C")          #'treemacs-copy-file
    (kbd "M")          #'treemacs-move-file
    (kbd "x")          #'treemacs-delete-file
    (kbd "<S-return>") #'treemacs-visit-node-nofocus)
  (map! :map treemacs-mode-map "d" nil "m" nil))
#+end_src

** Undo fu

Configure undo-fu to allow for undo in region.
#+begin_src emacs-lisp
(after! undo-fu
  (setq undo-fu-allow-undo-in-region t
        undo-fu-ignore-keyboard-quit t))
#+end_src

** Undo tree

Customize undo-tree visualizer.
Disabled since I've fallback to undo-fu as undo-tree is too unstable (and slow).
See https://github.com/hlissner/doom-emacs/issues/1407
#+begin_src elisp
;; (use-package! undo-tree
;;   :config
;;   (setq undo-tree-visualizer-diff nil)
;;   :bind (:map evil-normal-state-map
;;          ("U" . undo-tree-visualize)))
#+end_src

** Visual fill column

#+begin_src elisp
(use-package! visual-fill-column
  :config
  (setq-default visual-fill-column-center-text t)
  (setq visual-fill-column-adjust-for-text-scale t
        visual-fill-column-fringes-outside-margins t
        visual-fill-column-enable-sensible-window-split nil)
  (add-hook! (helpful-mode Man-mode woman-mode)
             #'visual-fill-column-mode))
#+end_src

** Vterm

Configure vterm buffer naming scheme.
#+begin_src elisp
(use-package! vterm
  :config
  (setq vterm-buffer-name-string "vterm %s"))
#+end_src

** Vertico

Customize vertico bindings to simplify usage of embark.
#+begin_src elisp
(after! vertico
  (map! :map vertico-map
        "M-k" #'previous-history-element
        "M-j" #'next-history-element
        "C-r" #'minibuffer-complete-history
        "M-a" #'embark-act
        "M-o" #'embark-collect
        "M-e" #'embark-export
        "C-M-SPC" #'embark-select
        "M-E" #'+vertico/embark-export-write
        "M-d" #'consult-dir
        "M-f" #'consult-dir-jump-file
        ))
#+end_src

** Which-key

Reduce the delay before the which-key buffer is displayed.
#+begin_src elisp
(after! which-key
  (setq which-key-idle-delay 0.5))
#+end_src

Replace =evil-= like prefixes by a unicode symbol to reduce verbosity.
#+begin_src elisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-/:]?\\(?:a-\\)?\\(.*\\)") . (nil . "‚Äπ\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "¬´\\1"))
   ))
#+end_src

** Xclip

#+begin_src elisp
;; NOTE: For this to work under wayland, wl-clipboard must be installed.
(add-hook! 'tty-setup-hook
  (defun doom-init-clipboard-in-tty-emacs-h ()
    ;; Fix the clipboard in tty Emacs by piping clipboard I/O through xclip,
    ;; xsel, pb{copy,paste}, wl-copy, termux-clipboard-get, or getclip (cygwin);
    ;; depending on what is available.
    (and (require 'xclip nil t)
         (with-demoted-errors "%s" (xclip-mode +1)))))
#+end_src

** YASnippet

Nested snippets are good, enable that.
#+begin_src elisp
(use-package! yasnippet
  :config
  (setq yas-triggers-in-field t))
#+end_src

Rebind auto-yasnippet commands.
#+begin_src elisp
(use-package! auto-yasnippet
  :config
  (map!
   :nvi [C-tab] nil
   (:leader :prefix "c"
    :desc "Expand auto-snippet" "y" #'aya-expand
    :desc "Create auto-snippet" "Y" #'aya-create)

   ;; Use yas-next-field instead of yas-next-field-or-maybe-expand
   ;; The latter is too confusing, most of the time I don't need to expand snippets inside snippet fields.
   (:map yas-keymap
    "TAB"   #'yas-next-field
    "<tab>" #'yas-next-field)
))
#+end_src

